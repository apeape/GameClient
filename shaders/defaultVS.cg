/*-----------------------------------------------------------------------

 GameSpaceLib (C) Copyright 2008-2010 André Santee
 http://www.asantee.net/gamespace/
 http://groups.google.com/group/gamespacelib

  ENGLISH
  -------

    This file is part of GameSpaceLib.

    GameSpaceLib is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    GameSpaceLib is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with GameSpaceLib. If not, see
    <http://www.gnu.org/licenses/>.

  PORTUGUES
  ---------

    Este arquivo é parte da GameSpaceLib.

    O GameSpaceLib é software livre; você pode redistribuí-lo e/ou
    modificá-lo sob os termos da Licença Pública Menos Geral (LGPL)
    GNU, conforme publicada pela Free Software Foundation; tanto a
    versão 3 da Licença como (a seu critério) qualquer versão mais
    nova.

    O GameSpaceLib é distribuído na expectativa de ser útil, mas
    SEM QUALQUER GARANTIA; sem mesmo a garantia implícita de
    COMERCIALIZAÇÃO ou de ADEQUAÇÃO A QUALQUER PROPÓSITO EM
    PARTICULAR. Consulte a Licença Pública Geral Menor (LGPL) GNU
    para obter mais detalhes.
 
    Você deve ter recebido uma cópia da Licença Pública Menos Geral
    GNU junto com este programa; se não, veja na página
    <http://www.gnu.org/licenses/>.

-----------------------------------------------------------------------*/

// the following global uniform parameters are set automaticaly
// by the GameSpaceLib runtime

// sprite and screen properties:
uniform float4x4 viewMatrix;     // orthogonal matrix for the screen space
uniform float4x4 rotationMatrix; // sprite rotation matrix
uniform float2 screenSize;       // current screen size
uniform float2 size;             // sprite width and height
uniform float2 entityPos;        // sprite position
uniform float2 center;           // sprite origin (in pixels)
uniform float2 bitmapSize;       // sprite size
uniform float2 rectPos;          // texture rect cut position (in pixels)
uniform float2 rectSize;         // texture rect cut size (in pixels)
uniform float2 scroll;           // texture scroll parameter
uniform float2 multiply;         // texture multiply
uniform float4 color0;           // left-top vertex color
uniform float4 color1;           // right-top vertex color
uniform float4 color2;           // left-bottom vertex color
uniform float4 color3;           // right-bottom vertex color
uniform float2 flipAdd;          // this is added to the vertex position to flip it
uniform float2 flipMul;          // this is multiplied by the vertex position do flip it
uniform float2 cameraPos;
uniform float depth;

// returns the sprite vertex position according to it's
// origin in screen space and rotation angle
float4 transformSprite(float3 position)
{
	// flips the sprite (if the parameters are set to flip)
	float4 newPos = float4(position, 1);

	// scales and position the sprite center
	newPos = newPos * float4(size,1,1) - float4(center, 0, 0);

	// rotates the sprite
	newPos = mul(rotationMatrix, newPos);

	// position the sprite according to the screen space
	newPos += float4(entityPos,0,0)-float4(screenSize/2,0,0)-float4(cameraPos,0,0);

	// inverts the y coordinate
	newPos *= float4(1,-1,1,1);
	return mul(viewMatrix, newPos);
}

// returns the texture coordinate according to the rect
float2 transformCoord(float2 texCoord)
{
	// adjusts the texture coordinate according to the cut-rect
	float2 newCoord = texCoord * (rectSize/bitmapSize);
	newCoord += (rectPos/bitmapSize);

	// scrolls and multiplies the texture
	return (newCoord);
}

// GS_SPRITE::DrawSprite:
// main sprite program
void main(	float3 position : POSITION,
			float2 texCoord : TEXCOORD0,
			out float4 oPosition : POSITION,
			out float4 oColor    : COLOR0,
			out float2 oTexCoord0 : TEXCOORD0,
			out float2 oTexCoord1 : TEXCOORD1)
{
	float4 outPos = transformSprite(position);
	outPos.z = 1-depth;
	oPosition = outPos;
	float2 coord = transformCoord(texCoord);
	oTexCoord0 = oTexCoord1 = coord;
	oColor = color0;
}

void particle(	float3 position : POSITION,
				float2 texCoord : TEXCOORD0,
				out float4 oPosition : POSITION,
				out float4 oColor    : COLOR0,
				out float2 oTexCoord0 : TEXCOORD0,
				uniform float4 ambientLight,
				uniform float3 lightPos,
				uniform float3 lightColor,
				uniform float lightRange)
{
	float4 outPos = transformSprite(position);
	outPos.z = 1-depth;
	oPosition = outPos;
	float2 coord = transformCoord(texCoord);
	oTexCoord0 = coord;

	//float4 outColor = ambientLight;

	/*{
		float3 diff = outPos.xyz-lightPos;
		float squaredDist = dot(diff,diff);
		float squaredRange = lightRange*lightRange;
		squaredRange = max(squaredDist, squaredRange);
		float attenBias = 1-(squaredDist/squaredRange);
		outColor += float4(lightColor,0)*attenBias;
	}*/

	oColor = color0;
}