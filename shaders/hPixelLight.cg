/*-----------------------------------------------------------------------

 Ethanon Engine (C) Copyright 2009-2010 André Santee
 http://www.asantee.net/ethanon/

  ENGLISH
  -------

    This file is part of Ethanon Engine.

    Ethanon Engine is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    Ethanon Engine is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with Ethanon Engine. If not, see
    <http://www.gnu.org/licenses/>.

  PORTUGUÊS
  ---------

    Este arquivo é parte da Ethanon Engine.

    Ethanon Engine é software livre; você pode redistribuí-lo e/ou
    modificá-lo sob os termos da Licença Pública Menos Geral (LGPL)
    GNU, conforme publicada pela Free Software Foundation; tanto a
    versão 3 da Licença como (a seu critério) qualquer versão mais
    nova.

    Ethanon Engine é distribuído na expectativa de ser útil, mas
    SEM QUALQUER GARANTIA; sem mesmo a garantia implícita de
    COMERCIALIZAÇÃO ou de ADEQUAÇÃO A QUALQUER PROPÓSITO EM
    PARTICULAR. Consulte a Licença Pública Geral Menor (LGPL) GNU
    para obter mais detalhes.

    Você deve ter recebido uma cópia da Licença Pública Menos Geral
    GNU junto com este programa; se não, veja na página
    <http://www.gnu.org/licenses/>.

-----------------------------------------------------------------------*/


void main(float2 texCoord : TEXCOORD0,
		  float3 pixelPos3D : TEXCOORD1,
		  float4 color0     : COLOR0,
		  out float4 oColor : COLOR,
		  uniform sampler2D diffuse,
		  uniform sampler2D normalMap,
		  uniform float lightIntensity,
		  uniform float3 lightPos,
		  uniform float2 screenSize,
		  uniform float lightRange,
		  uniform float4 lightColor,
		  uniform float2 pivotAdjust,
		  uniform float4x4 rotMatrix)
{
	const float4 diffuseColor = tex2D(diffuse, texCoord);
	float3 normalColor = tex2D(normalMap, texCoord);

	const float3 lightVec = pixelPos3D-lightPos;
	lightColor.a = 1.0f;

	normalColor = -normalize(2*(normalColor-0.5));
	//normalColor = mul(rotMatrix,float4(normalColor,1)).xyz;

	float diffuseLight = dot(normalize(lightVec), normalColor);

	float squaredDist = dot(lightVec,lightVec);
	float squaredRange = lightRange*lightRange;

	squaredRange = max(squaredDist, squaredRange);
	const float attenBias = 1-(squaredDist/squaredRange);

	oColor = (diffuseColor*color0*diffuseLight*attenBias*lightColor*lightIntensity)*diffuseColor.w;
}

void mainSpecular(float2 texCoord : TEXCOORD0,
		  float3 pixelPos3D : TEXCOORD1,
		  float4 color0     : COLOR0,
		  out float4 oColor : COLOR,
		  uniform sampler2D diffuse,
		  uniform sampler2D normalMap,
		  uniform sampler2D glossMap,
		  uniform float specularPower,
		  uniform float lightIntensity,
		  uniform float3 lightPos,
		  uniform float2 screenSize,
		  uniform float lightRange,
		  uniform float4 lightColor,
		  uniform float2 pivotAdjust,
		  uniform float3 fakeEyePos,
		  uniform float4x4 rotMatrix,
		  uniform float specularBrightness)
{
	const float4 diffuseColor = tex2D(diffuse, texCoord);
	float3 normalColor = tex2D(normalMap, texCoord).xyz;
	const float4 glossColor = tex2D(glossMap, texCoord)*specularBrightness;

	const float3 lightVec = (pixelPos3D-lightPos);
	const float3 eyeVec = (pixelPos3D-fakeEyePos);
	
	const float lightVecLength = length(lightVec);
	const float eyeVecLength = length(eyeVec);
	const float3 halfVec = normalize(lightVec/lightVecLength+eyeVec/eyeVecLength);
	lightColor.a = 1.0f;

	normalColor = -normalize(2*(normalColor-0.5));
	//normalColor = mul(rotMatrix,float4(normalColor,1)).xyz;

	float diffuseLight = dot(lightVec/lightVecLength, (normalColor));

	float squaredDist = dot(lightVec,lightVec);
	float squaredRange = lightRange*lightRange;

	squaredRange = max(squaredDist, squaredRange);
	const float attenBias = 1-(squaredDist/squaredRange);

	const float4 specular = lightColor*pow(saturate(dot(normalColor, halfVec)), specularPower);

	oColor = ((diffuseColor*color0*diffuseLight*lightColor*lightIntensity)+specular*diffuseColor.w*glossColor)*attenBias;
}
