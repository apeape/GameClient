<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nuclex.Support</name>
    </assembly>
    <members>
        <member name="T:Nuclex.Support.AffineThreadPoolTest">
            <summary>Unit Test for the CPU core-affine thread pool</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestQueueUserWorkItem">
            <summary>Tests whether the QueueUserWorkItem() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestQueueUserWorkItemWithState">
            <summary>
              Verifies that the QueueUserWorkItem() method is passing the state parameter
              on to the callback
            </summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestExceptionFromUserWorkItem">
            <summary>
              Tests whether the thread pool can handle an exception from a user work item
            </summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestMaxThreadsProperty">
            <summary>
              Verifies that the affine thread pool's maximum thread count equals
              the number of logical processors in the system
            </summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestGetProcessThread">
            <summary>
              Verifies that the ProcessThread instance for a system thread id can
              be determined using the GetProcessThread() method
            </summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestDefaultExceptionHandler">
            <summary>
              Tests whether the afine thread pool's default exception handler works
              as expected
            </summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestWaitingWorkItemsProperty">
            <summary>
              Verifies that the waiting work items count and active thread count are
              updated by the thread pool.
            </summary>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPoolTest.TestTask">
            <summary>ThreadPool task that can be used for testing</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestTask.#ctor">
            <summary>Initializes a new test task</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestTask.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.TestTask.Callback(System.Object)">
            <summary>Callback that can be added to the thread pool as a task</summary>
            <param name="state">User defined state</param>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPoolTest.TestTask.LastCallbackState">
            <summary>
              State parameter that was provide when the callback was called
            </summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPoolTest.TestTask.callbackEvent">
            <summary>Event that will be set when the callback is invoked</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPoolTest.TestTask.CallbackEvent">
            <summary>Event that will be set when the callback is executed</summary>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPoolTest.WaitTask">
            <summary>ThreadPool task that can be used for testing</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.WaitTask.#ctor">
            <summary>Initializes a new test task</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.WaitTask.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPoolTest.WaitTask.Callback(System.Object)">
            <summary>Callback that can be added to the thread pool as a task</summary>
            <param name="state">User defined state</param>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPoolTest.WaitTask.LastCallbackState">
            <summary>
              State parameter that was provide when the callback was called
            </summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPoolTest.WaitTask.startEvent">
            <summary>Event that will be set when the callback has started</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPoolTest.WaitTask.finishEvent">
            <summary>Event that will be set when the callback has finished</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPoolTest.WaitTask.waitEvent">
            <summary>Event used to block the callback</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPoolTest.WaitTask.StartEvent">
            <summary>Event that will be set when the callback has started</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPoolTest.WaitTask.FinishEvent">
            <summary>Event that will be set when the callback has finished</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPoolTest.WaitTask.WaitEvent">
            <summary>Event that blocks the callback</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.Deque`1">
            <summary>A double-ended queue that allocates memory in blocks</summary>
            <typeparam name="ItemType">Type of the items being stored in the queue</typeparam>
            <remarks>
              <para>
                The double-ended queue allows items to be appended to either side of the queue
                without a hefty toll on performance. Like its namesake in C++, it is implemented
                using multiple arrays.
              </para>
              <para>
                Therefore, it's not only good at coping with lists that are modified at their
                beginning, but also at handling huge data sets since enlarging the deque doesn't
                require items to be copied around and still can be accessed by index.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.#ctor">
            <summary>Initializes a new deque</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.#ctor(System.Int32)">
            <summary>Initializes a new deque using the specified block size</summary>
            <param name="blockSize">Size of the individual memory blocks used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Contains(`0)">
            <summary>Determines whether the deque contains the specified item</summary>
            <param name="item">Item the deque will be scanned for</param>
            <returns>True if the deque contains the item, false otherwise</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the deque into an array</summary>
            <param name="array">Array the contents of the deque will be copied into</param>
            <param name="arrayIndex">Array index the deque contents will begin at</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.GetEnumerator">
            <summary>Obtains a new enumerator for the contents of the deque</summary>
            <returns>The new enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.findIndex(System.Int32,System.Int32@,System.Int32@)">
            <summary>Calculates the block index and local sub index of an entry</summary>
            <param name="index">Index of the entry that will be located</param>
            <param name="blockIndex">Index of the block the entry is contained in</param>
            <param name="subIndex">Local sub index of the entry within the block</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.isCompatibleObject(System.Object)">
            <summary>
              Determines whether the provided object can be placed in the deque
            </summary>
            <param name="value">Value that will be checked for compatibility</param>
            <returns>True if the value can be placed in the deque</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.verifyCompatibleObject(System.Object)">
            <summary>Verifies that the provided object matches the deque's type</summary>
            <param name="value">Value that will be checked for compatibility</param>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.count">
            <summary>Number if items currently stored in the deque</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.blockSize">
            <summary>Size of a single deque block</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.blocks">
            <summary>Memory blocks being used to store the deque's data</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.firstBlockStartIndex">
            <summary>Starting index of data in the first block</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.lastBlockEndIndex">
            <summary>End index of data in the last block</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.AddFirst(`0)">
            <summary>Inserts an item at the beginning of the double-ended queue</summary>
            <param name="item">Item that will be inserted into the queue</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.AddLast(`0)">
            <summary>Appends an item to the end of the double-ended queue</summary>
            <param name="item">Item that will be appended to the queue</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Insert(System.Int32,`0)">
            <summary>Inserts the item at the specified index</summary>
            <param name="index">Index the item will be inserted at</param>
            <param name="item">Item that will be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.shiftLeftAndInsert(System.Int32,`0)">
            <summary>
              Shifts all items before the insertion point to the left and inserts
              the item at the specified index
            </summary>
            <param name="index">Index the item will be inserted at</param>
            <param name="item">Item that will be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.shiftRightAndInsert(System.Int32,`0)">
            <summary>
              Shifts all items after the insertion point to the right and inserts
              the item at the specified index
            </summary>
            <param name="index">Index the item will be inserted at</param>
            <param name="item">Item that will be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Obtains a new enumerator for the contents of the deque</summary>
            <returns>The new enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the deque</summary>
            <param name="value">Item that will be added to the deque</param>
            <returns>The index at which the new item was added</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Contains(System.Object)">
            <summary>Checks whether the deque contains the specified item</summary>
            <param name="value">Item the deque will be scanned for</param>
            <returns>True if the deque contained the specified item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>Determines the index of the item in the deque</summary>
            <param name="value">Item whose index will be determined</param>
            <returns>The index of the specified item in the deque</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>Inserts an item into the deque at the specified location</summary>
            <param name="index">Index at which the item will be inserted</param>
            <param name="value">Item that will be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Remove(System.Object)">
            <summary>Removes the specified item from the deque</summary>
            <param name="value">Item that will be removed from the deque</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#Generic#ICollection{ItemType}#Add(`0)">
            <summary>Adds an item into the deque</summary>
            <param name="item">Item that will be added to the deque</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the deque into an array</summary>
            <param name="array">Array the contents of the deque will be copied into</param>
            <param name="index">Index at which writing into the array will begin</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Clear">
            <summary>Removes all items from the deque</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Remove(`0)">
            <summary>Removes the specified item from the deque</summary>
            <param name="item">Item that will be removed from the deque</param>
            <returns>True if the item was found and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.RemoveFirst">
            <summary>Removes the first item in the double-ended queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.RemoveLast">
            <summary>Removes the last item in the double-ended queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.RemoveAt(System.Int32)">
            <summary>Removes the item at the specified index</summary>
            <param name="index">Index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.removeFromLeft(System.Int32)">
            <summary>
              Removes an item from the left side of the queue by shifting all items that
              come before it to the right by one
            </summary>
            <param name="index">Index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.removeFromRight(System.Int32)">
            <summary>
              Removes an item from the right side of the queue by shifting all items that
              come after it to the left by one
            </summary>
            <param name="index">Index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.IndexOf(`0)">
            <summary>
              Determines the index of the first occurence of the specified item in the deque
            </summary>
            <param name="item">Item that will be located in the deque</param>
            <returns>The index of the item or -1 if it wasn't found</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Count">
            <summary>Number of items contained in the double ended queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Item(System.Int32)">
            <summary>Accesses an item by its index</summary>
            <param name="index">Index of the item that will be accessed</param>
            <returns>The item at the specified index</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.First">
            <summary>The first item in the double-ended queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Last">
            <summary>The last item in the double-ended queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#IList#IsFixedSize">
            <summary>Whether the deque has a fixed size</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#IList#IsReadOnly">
            <summary>Whether the deque is read-only</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Item(System.Int32)">
            <summary>Accesses an item in the deque by its index</summary>
            <param name="index">Index of the item that will be accessed</param>
            <returns>The item at the specified index</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#Generic#ICollection{ItemType}#IsReadOnly">
            <summary>Whether the collection is read-only</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the deque is thread-synchronized</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root of the instance</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.Deque`1.Enumerator">
            <summary>Enumerates over the items in a deque</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Enumerator.#ctor(Nuclex.Support.Collections.Deque{`0})">
            <summary>Initializes a new deque enumerator</summary>
            <param name="deque">Deque whose items will be enumerated</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Enumerator.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next item</summary>
            <returns>True if there was a next item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Enumerator.Reset">
            <summary>Resets the enumerator to its initial position</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.deque">
            <summary>Deque the enumerator belongs to</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.blockSize">
            <summary>Size of the blocks in the deque</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.lastBlock">
            <summary>Index of the last block in the deque</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.lastBlockEndIndex">
            <summary>End index of the items in the deque's last block</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.currentBlockIndex">
            <summary>Index of the block the enumerator currently is in</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.currentBlock">
            <summary>Reference to the block being enumerated</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.subIndex">
            <summary>Index in the current block</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Enumerator.Current">
            <summary>The item at the enumerator's current position</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>The item at the enumerator's current position</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.DequeTest">
            <summary>Unit Test for the double ended queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestAddLast">
            <summary>Verifies that the AddLast() method of the deque is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestAddFirst">
            <summary>Verifies that the AddFirst() method of the deque is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveFirst">
            <summary>
              Verifies that the RemoveFirst() method of the deque is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveLast">
            <summary>
              Verifies that the RemoveLast() method of the deque is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestInsert">
            <summary>Verifies that the Insert() method works in all cases</summary>
            <remarks>
              We have several different cases here that will be tested. The deque can
              shift items to the left or right (depending on which end is closer to
              the insertion point) and the insertion point may fall in an only partially
              occupied block, requiring elaborate index calculations
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestInsertNonNormalized">
            <summary>
              Verifies that the Insert() method works in all cases when the deque doesn't
              start at a block boundary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveAt">
            <summary>Verifies the the RemoveAt() method works in all cases</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveAtNonNormalized">
            <summary>
              Verifies the the RemoveAt() method works in all cases when the deque doesn't
              start at a block boundary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveAtEmptiesLeftBlock">
            <summary>
              Tests whether the RemoveAt() method keeps the state of the deque intact when
              it has to remove a block from the left end of the deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveAtEmptiesRightBlock">
            <summary>
              Tests whether the RemoveAt() method keeps the state of the deque intact when
              it has to remove a block from the right end of the deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnAccessFirstInEmptyDeque">
            <summary>
              Validates that an exception is thrown if the 'First' property is accessed
              in an empty deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnAccessLastInEmptyDeque">
            <summary>
              Validates that an exception is thrown if the 'Last' property is accessed
              in an empty deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnRemoveFirstFromEmptyDeque">
            <summary>
              Validates that an exception is thrown if the first item is attempted to be 
              removed from an empty deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnRemoveLastFromEmptyDeque">
            <summary>
              Validates that an exception is thrown if the last item is attempted to be 
              removed from an empty deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIndexAssignment">
            <summary>
              Verifies that items can be assigned by their index
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnInvalidIndex">
            <summary>
              Verifies that an exception is thrown if an invalid index is accessed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIndexOf(System.Int32)">
            <summary>Tests the IndexOf() method</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIndexOfNonNormalized(System.Int32)">
            <summary>
              Tests the IndexOf() method with the deque not starting at a block boundary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestEnumerator">
            <summary>Verifies that the deque's enumerator works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestObjectEnumerator">
            <summary>Verifies that the deque's enumerator works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnInvalidEnumeratorPosition">
            <summary>
              Verifies that an exception is thrown if the enumerator is accessed in
              an invalid position
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestClearSmallDeque">
            <summary>Tests whether a small deque can be cleared</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestClearLargeDeque">
            <summary>Tests whether a large deque can be cleared</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestAddObject">
            <summary>Verifies that the non-typesafe Add() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnAddIncompatibleObject">
            <summary>
              Tests whether an exception is thrown if the non-typesafe Add() method is
              used to add an incompatible object into the deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestAdd">
            <summary>Verifies that the Add() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestContains">
            <summary>Tests whether the Contains() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestContainsObject">
            <summary>Tests the non-typesafe Contains() method</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIndexOfObject">
            <summary>Tests the non-typesafe Contains() method</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestInsertObject">
            <summary>Tests wether the non-typesafe Insert() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnInsertIncompatibleObject">
            <summary>
              Verifies that an exception is thrown if an incompatible object is inserted
              into the deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIsFixedObject">
            <summary>Validates that the IsFixedObject property is set to false</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIsSynchronized">
            <summary>Validates that the IsSynchronized property is set to false</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestObjectIndexAssignment">
            <summary>
              Verifies that items can be assigned by their index using the non-typesafe
              IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIncompatibleObjectIndexAssignment">
            <summary>
              Tests whether an exception is thrown if an incompatible object is assigned
              to the deque
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemove">
            <summary>Verifies that the Remove() method is working correctly</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveObject">
            <summary>Tests the non-typesafe remove method</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestRemoveIncompatibleObject">
            <summary>
              Tests the non-typesafe remove method used to remove an incompatible object
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestIsReadOnly">
            <summary>
              Validates that the IsReadOnly property of the deque returns false
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestCopyToObjectArray">
            <summary>Tests the non-typesafe CopyTo() method</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestCopyToArray">
            <summary>Tests the CopyTo() method</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnCopyToIncompatibleObjectArray">
            <summary>
              Verifies that the non-typesafe CopyTo() method throws an exception if
              the array is of an incompatible type
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.TestThrowOnCopyToTooSmallArray">
            <summary>
              Verifies that the CopyTo() method throws an exception if the target array
              is too small
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.createNonNormalizedDeque(System.Int32)">
            <summary>
              Creates a deque whose first element does not coincide with a block boundary
            </summary>
            <param name="count">Number of items the deque will be filled with</param>
            <returns>The newly created deque</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.DequeTest.createDeque(System.Int32)">
            <summary>Creates a deque filled with the specified number of items
            </summary>
            <param name="count">Number of items the deque will be filled with</param>
            <returns>The newly created deque</returns>
        </member>
        <member name="T:Nuclex.Support.Collections.IObservableCollection`1">
            <summary>Interface for collections that can be observed</summary>
            <typeparam name="ItemType">Type of items managed in the collection</typeparam>
        </member>
        <member name="E:Nuclex.Support.Collections.IObservableCollection`1.ItemAdded">
            <summary>Raised when an item has been added to the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.IObservableCollection`1.ItemRemoved">
            <summary>Raised when an item is removed from the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.IObservableCollection`1.Clearing">
            <summary>Raised when the collection is about to be cleared</summary>
            <remarks>
              This could be covered by calling ItemRemoved for each item currently
              contained in the collection, but it is often simpler and more efficient
              to process the clearing of the entire collection as a special operation.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Collections.IObservableCollection`1.Cleared">
            <summary>Raised when the collection has been cleared of its items</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.IRecyclable">
            <summary>Allows an object to be returned to its initial state</summary>
            <remarks>
              <para>
                This interface is typically implemented by objects which can be recycled
                in order to avoid the construction overhead of a heavyweight class and to
                eliminate garbage by reusing instances.
              </para>
              <para>
                Recyclable objects should have a parameterless constructor and calling
                their Recycle() method should bring them back into the state they were
                in right after they had been constructed.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.IRecyclable.Recycle">
            <summary>Returns the object to its initial state</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ItemEventArgs`1">
            <summary>
              Arguments class for collections wanting to hand over an item in an event
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ItemEventArgs`1.#ctor(`0)">
            <summary>Initializes a new event arguments supplier</summary>
            <param name="item">Item to be supplied to the event handler</param>
        </member>
        <member name="F:Nuclex.Support.Collections.ItemEventArgs`1.item">
            <summary>Item to be passed to the event handler</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ItemEventArgs`1.Item">
            <summary>Obtains the collection item the event arguments are carrying</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ItemEventArgsTest">
            <summary>Unit Test for the item event argument container</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ItemEventArgsTest.TestIntegerArgument">
            <summary>
              Tests whether an integer argument can be stored in the argument container
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ItemEventArgsTest.TestStringArgument">
            <summary>
              Tests whether a string argument can be stored in the argument container
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableCollection`1">
            <summary>Collection which fires events when items are added or removed</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.#ctor">
            <summary>
              Initializes a new instance of the ObservableCollection class that is empty.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
              Initializes a new instance of the ObservableCollection class as a wrapper
              for the specified list.
            </summary>
            <param name="list">The list that is wrapped by the new collection.</param>
            <exception cref="T:System.ArgumentNullException">
               List is null.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.ClearItems">
            <summary>Removes all elements from the Collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.InsertItem(System.Int32,`0)">
            <summary>
              Inserts an element into the ObservableCollection at the specified index
            </summary>
            <param name="index">
              The object to insert. The value can be null for reference types.
            </param>
            <param name="item">The zero-based index at which item should be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.RemoveItem(System.Int32)">
            <summary>
              Removes the element at the specified index of the ObservableCollection
            </summary>
            <param name="index">The zero-based index of the element to remove</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.SetItem(System.Int32,`0)">
            <summary>Replaces the element at the specified index</summary>
            <param name="index">
              The new value for the element at the specified index. The value can be null
              for reference types
            </param>
            <param name="item">The zero-based index of the element to replace</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.OnAdded(`0)">
            <summary>Fires the 'ItemAdded' event</summary>
            <param name="item">Item that has been added to the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.OnRemoved(`0)">
            <summary>Fires the 'ItemRemoved' event</summary>
            <param name="item">Item that has been removed from the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.OnClearing">
            <summary>Fires the 'Clearing' event</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.OnCleared">
            <summary>Fires the 'Cleared' event</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.ItemAdded">
            <summary>Raised when an item has been added to the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.ItemRemoved">
            <summary>Raised when an item is removed from the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.Clearing">
            <summary>Raised when the collection is about to be cleared</summary>
            <remarks>
              This could be covered by calling ItemRemoved for each item currently
              contained in the collection, but it is often simpler and more efficient
              to process the clearing of the entire collection as a special operation.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.Cleared">
            <summary>Raised when the collection has been cleared</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableCollectionTest">
            <summary>Unit Test for the observable collection class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.Setup">
            <summary>Initialization routine executed before each test is run</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.TestClearingEvent">
            <summary>Tests whether the Clearing event is fired</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.TestItemAddedEvent">
            <summary>Tests whether the ItemAdded event is fired</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.TestItemRemovedEvent">
            <summary>Tests whether the ItemRemoved event is fired</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.TestItemReplacement">
            <summary>Tests whether items in the collection can be replaced</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.TestListConstructor">
            <summary>Tests whether the ItemRemoved event is fired</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableCollectionTest.mockery">
            <summary>Mock object factory</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableCollectionTest.mockedSubscriber">
            <summary>The mocked observable collection subscriber</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableCollectionTest.observedCollection">
            <summary>An observable collection to which a mock will be subscribed</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableCollectionTest.IObservableCollectionSubscriber">
            <summary>Interface used to test the observable collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.IObservableCollectionSubscriber.Clearing(System.Object,System.EventArgs)">
            <summary>Called when the collection is about to clear its contents</summary>
            <param name="sender">Collection that is clearing its contents</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.IObservableCollectionSubscriber.Cleared(System.Object,System.EventArgs)">
            <summary>Called when the collection has been cleared of its contents</summary>
            <param name="sender">Collection that was cleared of its contents</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.IObservableCollectionSubscriber.ItemAdded(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.Int32})">
            <summary>Called when an item is added to the collection</summary>
            <param name="sender">Collection to which an item is being added</param>
            <param name="arguments">Contains the item that is being added</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollectionTest.IObservableCollectionSubscriber.ItemRemoved(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.Int32})">
            <summary>Called when an item is removed from the collection</summary>
            <param name="sender">Collection from which an item is being removed</param>
            <param name="arguments">Contains the item that is being removed</param>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableDictionary`2">
            <summary>A dictionary that sneds out change notifications</summary>
            <typeparam name="KeyType">Type of the keys used in the dictionary</typeparam>
            <typeparam name="ValueType">Type of the values used in the dictionary</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.#ctor">
            <summary>Initializes a new observable dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>Initializes a new observable Dictionary wrapper</summary>
            <param name="dictionary">Dictionary that will be wrapped</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the System.WeakReference class, using deserialized
              data from the specified serialization and stream objects.
            </summary>
            <param name="info">
              An object that holds all the data needed to serialize or deserialize the
              current System.WeakReference object.
            </param>
            <param name="context">
              (Reserved) Describes the source and destination of the serialized stream
              specified by info.
            </param>
            <exception cref="T:System.ArgumentNullException">
              The info parameter is null.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
              Determines whether the specified KeyValuePair is contained in the Dictionary
            </summary>
            <param name="item">KeyValuePair that will be checked for</param>
            <returns>True if the provided KeyValuePair was contained in the Dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the Dictionary contains the specified key</summary>
            <param name="key">Key that will be checked for</param>
            <returns>
              True if an entry with the specified key was contained in the Dictionary
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.GetEnumerator">
            <summary>Creates a new enumerator for the Dictionary</summary>
            <returns>The new Dictionary enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.TryGetValue(`0,`1@)">
            <summary>
              Attempts to retrieve the item with the specified key from the Dictionary
            </summary>
            <param name="key">Key of the item to attempt to retrieve</param>
            <param name="value">
              Output parameter that will receive the key upon successful completion
            </param>
            <returns>
              True if the item was found and has been placed in the output parameter
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.Add(`0,`1)">
            <summary>Inserts an item into the Dictionary</summary>
            <param name="key">Key under which to add the new item</param>
            <param name="value">Item that will be added to the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.Remove(`0)">
            <summary>Removes the item with the specified key from the Dictionary</summary>
            <param name="key">Key of the elementes that will be removed</param>
            <returns>True if an item with the specified key was found and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.Clear">
            <summary>Removes all items from the Dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.OnAdded(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Fires the 'ItemAdded' event</summary>
            <param name="item">Item that has been added to the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.OnRemoved(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Fires the 'ItemRemoved' event</summary>
            <param name="item">Item that has been removed from the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.OnClearing">
            <summary>Fires the 'Clearing' event</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.OnCleared">
            <summary>Fires the 'Cleared' event</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a new object enumerator for the Dictionary</summary>
            <returns>The new object enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>Adds an item into the Dictionary</summary>
            <param name="key">Key under which the item will be added</param>
            <param name="value">Item that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>Determines whether the specified key exists in the Dictionary</summary>
            <param name="key">Key that will be checked for</param>
            <returns>True if an item with the specified key exists in the Dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>Returns a new entry enumerator for the dictionary</summary>
            <returns>The new entry enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>Removes an item from the Dictionary</summary>
            <param name="key">Key of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Inserts an already prepared element into the Dictionary</summary>
            <param name="item">Prepared element that will be added to the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Clear">
            <summary>Removes all items from the Dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Removes all items from the Dictionary</summary>
            <param name="itemToRemove">Item that will be removed from the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary contents will be copied into</param>
            <param name="index">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Serializes the Dictionary</summary>
            <param name="info">
              Provides the container into which the Dictionary will serialize itself
            </param>
            <param name="context">
              Contextual informations about the serialization environment
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)">
            <summary>Called after all objects have been successfully deserialized</summary>
            <param name="sender">Nicht unterstützt</param>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableDictionary`2.typedDictionary">
            <summary>The wrapped Dictionary under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableDictionary`2.objectDictionary">
            <summary>The wrapped Dictionary under its object interface</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.ItemAdded">
            <summary>Raised when an item has been added to the dictionary</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.ItemRemoved">
            <summary>Raised when an item is removed from the dictionary</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.Clearing">
            <summary>Raised when the dictionary is about to be cleared</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.Cleared">
            <summary>Raised when the dictionary has been cleared</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.IsReadOnly">
            <summary>Whether the directory is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.Count">
            <summary>Number of elements contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.Keys">
            <summary>Collection of all keys contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.Values">
            <summary>Collection of all values contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.Item(`0)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>Whether the size of the Dictionary is fixed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Keys">
            <summary>Returns a collection of all keys in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Values">
            <summary>Returns a collection of all values stored in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
            <returns>The item with the specified key</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the Dictionary is synchronized for multi-threaded usage</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root on which the Dictionary locks</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableDictionary`2.SerializedDictionary">
            <summary>
              Dictionary wrapped used to reconstruct a serialized read only dictionary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.SerializedDictionary.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the System.WeakReference class, using deserialized
              data from the specified serialization and stream objects.
            </summary>
            <param name="info">
              An object that holds all the data needed to serialize or deserialize the
              current System.WeakReference object.
            </param>
            <param name="context">
              (Reserved) Describes the source and destination of the serialized stream
              specified by info.
            </param>
            <exception cref="T:System.ArgumentNullException">
              The info parameter is null.
            </exception>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableDictionaryTest">
            <summary>Unit Test for the observable dictionary wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.Setup">
            <summary>Initialization routine executed before each test is run</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestDefaultConstructor">
            <summary>
              Verifies that the default constructor of the observable dictionary works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestCopyConstructor">
            <summary>
              Verifies that the copy constructor of the observable dictionary works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestIsReadOnly">
            <summary>Verifies that the IsReadOnly property is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestContains">
            <summary>
              Checks whether the Contains() method of the observable dictionary is able to
              determine if the dictionary contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestContainsKey">
            <summary>
              Checks whether the Contains() method of the observable dictionary is able to
              determine if the dictionary contains a key
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestCopyToArray">
            <summary>
              Verifies that the CopyTo() of the observable dictionary works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestTypesafeEnumerator">
            <summary>
              Tests whether the typesafe enumerator of the observable dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestGetKeysCollection">
            <summary>
              Tests whether the keys collection of the observable dictionary can be queried
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestGetValuesCollection">
            <summary>
              Tests whether the values collection of the observable dictionary can be queried
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestTryGetValue">
            <summary>
              Tests whether the TryGetValue() method of the observable dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRetrieveValueByIndexer">
            <summary>
              Tests whether the retrieval of values using the indexer of the observable
              dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRetrieveNonExistingValueByIndexer">
            <summary>
              Tests whether an exception is thrown if the indexer of the observable dictionary
              is used to attempt to retrieve a non-existing value
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestAddViaGenericIDictionary">
            <summary>
              Checks whether the Add() methods works via the generic
              IDictionary&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRemoveViaGenericIDictionary">
            <summary>
              Checks whether the Remove() method works via the generic
              IDictionary&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRetrieveValueByIndexerViaGenericIDictionary">
            <summary>
              Tests whether the TryGetValue() method of the observable dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestReplaceByIndexerViaGenericIDictionary">
            <summary>
              Verifies that the indexer can be used to insert an item via the generic
              IDictionar&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestClearViaIDictionary">
            <summary>
              Checks whether the Clear() method of observable dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestAddViaIDictionary">
            <summary>
              Checks whether the Add() method works via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestContainsViaIDictionary">
            <summary>
              Checks whether the Contains() method of the observable dictionary is able to
              determine if the dictionary contains an item via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestEnumeratorViaIDictionary">
            <summary>
              Checks whether the GetEnumerator() method of the observable dictionary
              returns a working enumerator if accessed via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestIsFixedSizeViaIList">
            <summary>
              Checks whether the IsFixedSize property of the observable dictionary returns
              the expected result for a read only dictionary based on a dynamic dictionary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestGetKeysCollectionViaIDictionary">
            <summary>
              Tests whether the keys collection of the observable dictionary can be queried
              via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestGetValuesCollectionViaIDictionary">
            <summary>
              Tests whether the values collection of the observable dictionary can be queried
              via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRemoveViaIDictionary">
            <summary>
              Checks whether Remove() method works via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRetrieveValueByIndexerViaIDictionary">
            <summary>
              Tests whether the retrieval of values using the indexer of the observable
              dictionary is working via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestReplaceByIndexerViaIDictionary">
            <summary>
              Verifies the indexer can be used to insert an item via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestAddViaGenericICollection">
            <summary>
              Checks whether Add() method is working via the generic
              ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestClearViaGenericICollection">
            <summary>
              Checks whether the Clear() method is working via the generic
              ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestRemoveViaGenericICollection">
            <summary>
              Checks whether the Remove() method is working via the
              generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestCopyToArrayViaICollection">
            <summary>
              Verifies that the CopyTo() of the observable dictionary works when called
              via the the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.TestSerialization">
            <summary>
              Test whether the observable dictionary can be serialized
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.createTestDictionary">
            <summary>
              Creates a new observable dictionary filled with some values for testing
            </summary>
            <returns>The newly created observable dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.makeObservable(System.Collections.Generic.IDictionary{System.Int32,System.String})">
            <summary>
              Creates a new observable dictionary filled with some values for testing
            </summary>
            <returns>The newly created observable dictionary</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableDictionaryTest.mockery">
            <summary>Mock object factory</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableDictionaryTest.mockedSubscriber">
            <summary>The mocked observable collection subscriber</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableDictionaryTest.observedDictionary">
            <summary>An observable dictionary to which a mock will be subscribed</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableDictionaryTest.IObservableDictionarySubscriber">
            <summary>Interface used to test the observable dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.IObservableDictionarySubscriber.Clearing(System.Object,System.EventArgs)">
            <summary>Called when the dictionary is about to clear its contents</summary>
            <param name="sender">Dictionary that is clearing its contents</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.IObservableDictionarySubscriber.Cleared(System.Object,System.EventArgs)">
            <summary>Called when the dictionary has been clear of its contents</summary>
            <param name="sender">Dictionary that was cleared of its contents</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.IObservableDictionarySubscriber.ItemAdded(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.Collections.Generic.KeyValuePair{System.Int32,System.String}})">
            <summary>Called when an item is added to the dictionary</summary>
            <param name="sender">Dictionary to which an item is being added</param>
            <param name="arguments">Contains the item that is being added</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionaryTest.IObservableDictionarySubscriber.ItemRemoved(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.Collections.Generic.KeyValuePair{System.Int32,System.String}})">
            <summary>Called when an item is removed from the dictionary</summary>
            <param name="sender">Dictionary from which an item is being removed</param>
            <param name="arguments">Contains the item that is being removed</param>
        </member>
        <member name="T:Nuclex.Support.Collections.PairPriorityQueue`2">
            <summary>Queue that dequeues items in order of their priority</summary>
            <remarks>
              This variant of the priority queue uses an external priority value. If the
              priority data type implements the IComparable interface, the user does not
              even
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.#ctor">
            <summary>Initializes a new non-intrusive priority queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>Initializes a new non-intrusive priority queue</summary>
            <param name="priorityComparer">Comparer used to compare the item priorities</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.Peek">
            <summary>Returns the topmost item in the queue without dequeueing it</summary>
            <returns>The topmost item in the queue</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.Dequeue">
            <summary>Takes the item with the highest priority off from the queue</summary>
            <returns>The item with the highest priority in the list</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.Enqueue(`0,`1)">
            <summary>Puts an item into the priority queue</summary>
            <param name="priority">Priority of the item to be queued</param>
            <param name="item">Item to be queued</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.Clear">
            <summary>Removes all items from the priority queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the priority queue into an array</summary>
            <param name="array">Array to copy the priority queue into</param>
            <param name="index">Starting index for the destination array</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.GetEnumerator">
            <summary>Returns a typesafe enumerator for the priority queue</summary>
            <returns>A new enumerator for the priority queue</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator for the priority queue</summary>
            <returns>A new enumerator for the priority queue</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.PairPriorityQueue`2.internalQueue">
            <summary>Intrusive priority queue being wrapped by this class</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PairPriorityQueue`2.Count">
            <summary>Total number of items in the priority queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PairPriorityQueue`2.SyncRoot">
            <summary>
              Obtains an object that can be used to synchronize accesses to the priority queue
              from different threads
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PairPriorityQueue`2.IsSynchronized">
            <summary>Whether operations performed on this priority queue are thread safe</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PairPriorityQueue`2.PairComparer">
            <summary>Compares two priority queue entries based on their priority</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.PairComparer.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>Initializes a new entry comparer</summary>
            <param name="priorityComparer">Comparer used to compare entry priorities</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.PairComparer.Compare(Nuclex.Support.Collections.PriorityItemPair{`0,`1},Nuclex.Support.Collections.PriorityItemPair{`0,`1})">
            <summary>Compares the left entry to the right entry</summary>
            <param name="left">Entry on the left side</param>
            <param name="right">Entry on the right side</param>
            <returns>The relationship of the two entries</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.PairPriorityQueue`2.PairComparer.priorityComparer">
            <summary>Comparer used to compare the priorities of the entries</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PairPriorityQueueTest">
            <summary>Unit Test for the priority queue class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueueTest.TestCount">
            <summary>Tests to ensure the count property is properly updated</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueueTest.TestOrdering">
            <summary>Tests to ensure that the priority collection actually sorts items</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueueTest.TestPeek">
            <summary>Tests to ensure that the priority collection's Peek() method works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueueTest.TestCopyTo">
            <summary>Tests whether the priority collection can copy itself into an array</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueueTest.TestSyncRoot">
            <summary>
              Tests whether the priority collection provides a synchronization root
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueueTest.TestEnumerator">
            <summary>
              Tests whether the priority collection provides a working type-safe enumerator
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.Parentable`1">
            <summary>Base class for objects that can be parented to an owner</summary>
            <typeparam name="ParentType">Type of the parent object</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.Parentable`1.OnParentChanged(`0)">
            <summary>Invoked whenever the instance's owner changes</summary>
            <remarks>
              When items are parented for the first time, the oldParent argument will
              be null. Also, if the element is removed from the collection, the
              current parent will be null.
            </remarks>
            <param name="oldParent">Previous owner of the instance</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Parentable`1.SetParent(`0)">
            <summary>Assigns a new parent to this instance</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Parentable`1.parent">
            <summary>Current parent of this object</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Parentable`1.Parent">
            <summary>The parent object that owns this instance</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ParentableTest">
            <summary>Unit Test for the Parentable class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentableTest.TestParentAssignment">
            <summary>
              Tests whether a parent can be assigned and then retrieved from
              the parentable object
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentableTest.TestParentChangedNotification">
            <summary>
              Tests whether a parent can be assigned and then retrieved from
              the parentable object
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ParentableTest.TestParentable">
            <summary>Parentable object that can be the child of an int</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentableTest.TestParentable.#ctor">
            <summary>Initializes a new instance of the parentable test class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentableTest.TestParentable.GetParent">
            <summary>The parent object that owns this instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentableTest.TestParentable.OnParentChanged(System.Int32)">
            <summary>Invoked whenever the instance's owner changes</summary>
            <remarks>
              When items are parented for the first time, the oldParent argument will
              be null. Also, if the element is removed from the collection, the
              current parent will be null.
            </remarks>
            <param name="oldParent">Previous owner of the instance</param>
        </member>
        <member name="F:Nuclex.Support.Collections.ParentableTest.TestParentable.parentChangedCalled">
            <summary>Whether the OnParentChanged method has been called</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ParentableTest.TestParentable.ParentChangedCalled">
            <summary>Whether the OnParentChanged method has been called</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ParentingCollection`2">
            <summary>Collection that automatically assigns an owner to all its elements</summary>
            <remarks>
              This collection automatically assigns a parent object to elements that
              are managed in it. The elements have to derive from the Parentable&lt;&gt;
              base class.
            </remarks>
            <typeparam name="ParentType">Type of the parent object to assign to items</typeparam>
            <typeparam name="ItemType">Type of the items being managed in the collection</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.Reparent(`0)">
            <summary>Reparents all elements in the collection</summary>
            <param name="parent">New parent to take ownership of the items</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.ClearItems">
            <summary>Clears all elements from the collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.InsertItem(System.Int32,`1)">
            <summary>Inserts a new element into the collection</summary>
            <param name="index">Index at which to insert the element</param>
            <param name="item">Item to be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.RemoveItem(System.Int32)">
            <summary>Removes an element from the collection</summary>
            <param name="index">Index of the element to remove</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.SetItem(System.Int32,`1)">
            <summary>Takes over a new element that is directly assigned</summary>
            <param name="index">Index of the element that was assigned</param>
            <param name="item">New item</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.DisposeItems">
            <summary>Disposes all items contained in the collection</summary>
            <remarks>
              <para>
                This method is intended to support collections that need to dispose their
                items. It will unparent all of the collection's items and call Dispose()
                on any item that implements IDisposable.
              </para>
              <para>
                Do not call this method from your destructor as it will access the
                contained items in order to unparent and to Dispose() them, which leads
                to undefined behavior since the object might have already been collected
                by the GC. Call it only if your object is being manually disposed.
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Collections.ParentingCollection`2.parent">
            <summary>Parent this collection currently belongs to</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ParentingCollectionTest">
            <summary>Unit Test for the Parenting Collection class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestPropagatePreassignedParent">
            <summary>
              Tests whether the parenting collection propagates its parent to an item that
              is added to the collection after the collection's aprent is already assigned
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestPropagateParentChange">
            <summary>
              Tests whether the parenting collection propagates a new parent to all items
              contained in it when its parent is changed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestPropagateParentOnReplace">
            <summary>
              Tests whether the parenting collection propagates its parent to an item that
              is added to the collection after the collection's aprent is already assigned
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestUnsetParentOnRemoveItem">
            <summary>
              Tests whether the parenting collection unsets the parent when an item is removed
              from the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestUnsetParentOnClear">
            <summary>
              Tests whether the parenting collection unsets the parent when all item are
              removed from the collection by clearing it
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestDisposeItems">
            <summary>
              Tests whether the parenting collection calls Dispose() on all contained items
              that implement IDisposable when its DisposeItems() method is called
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ParentingCollectionTest.TestParentable">
            <summary>Parentable object that can be the child of an int</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestParentable.#ctor">
            <summary>Initializes a new instance of the parentable test class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestParentable.GetParent">
            <summary>The parent object that owns this instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestParentable.Dispose">
            <summary>Immediately releases all resources owned by the item</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ParentingCollectionTest.TestParentable.disposeCalled">
            <summary>Whether Dispose() has been called on this item</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ParentingCollectionTest.TestParentable.DisposeCalled">
            <summary>Whether Dispose() has been called on this item</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ParentingCollectionTest.TestParentingCollection">
            <summary>Parentable object that can be the child of an int</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestParentingCollection.SetParent(System.Int32)">
            <summary>Changes the parent of the collection</summary>
            <param name="parent">New parent to assign to the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollectionTest.TestParentingCollection.DisposeItems">
            <summary>Disposes all items contained in the collection</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.Pool`1">
            <summary>Pool that recycles objects in order to avoid garbage build-up</summary>
            <typeparam name="ItemType">Type of objects being pooled</typeparam>
            <remarks>
              <para>
                Use this class to recycle objects instead of letting them become garbage,
                creating new instances each time. The Pool class is designed to either be
                used on its own or as a building block for a static class that wraps it.
              </para>
              <para>
                Special care has to be taken to revert the entire state of a recycled
                object when it is returned to the pool. For example, events will need to
                have their subscriber lists emptied to avoid sending out events to the
                wrong subscribers and accumulating more and more subscribers each time
                they are reused.
              </para>
              <para>
                To simplify such cleanup, pooled objects can implement the IRecyclable
                interface. When an object is returned to the pool, the pool will
                automatically call its IRecyclable.Recycle() method.
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Collections.Pool`1.DefaultPoolSize">
            <summary>Default number of recyclable objects the pool will store</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.#ctor">
            <summary>Initializes a new pool using the default capacity</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.#ctor(System.Int32)">
            <summary>Initializes a new pool using a user-specified capacity</summary>
            <param name="capacity">Capacity of the pool</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.Get">
            <summary>
              Returns a new or recycled instance of the types managed by the pool
            </summary>
            <returns>A new or recycled instance</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.Redeem(`0)">
            <summary>
              Redeems an instance that is no longer used to be recycled by the pool
            </summary>
            <param name="item">The instance that will be redeemed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.callRecycleIfSupported(`0)">
            <summary>
              Calls the Recycle() method on an objects if it implements
              the IRecyclable interface
            </summary>
            <param name="item">
              Object whose Recycle() method will be called if supported by the object
            </param>
        </member>
        <member name="F:Nuclex.Support.Collections.Pool`1.items">
            <summary>Objects being retained for recycling</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Pool`1.capacity">
            <summary>Capacity of the pool</summary>
            <remarks>
              Required because the Queue class doesn't allow this value to be retrieved
            </remarks>
        </member>
        <member name="P:Nuclex.Support.Collections.Pool`1.Capacity">
            <summary>Number of objects the pool can retain</summary>
            <remarks>
              Changing this value causes the pool to be emtpied. It is recommended that
              you only read the pool's capacity, never change it.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Collections.PoolTest">
            <summary>Unit tests for the Pool class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PoolTest.TestGet">
            <summary>
              Verifies that the pool can return newly constructed objects
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PoolTest.TestGetRecycled">
            <summary>
              Verifies that the pool will return a recycled object if one is available
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PoolTest.TestRedeem">
            <summary>
              Tests whether the pool can redeem objects that are no longer used
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PoolTest.TestRecycle">
            <summary>
              Tests whether the Recycle() method is called at the appropriate time
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PoolTest.TestPoolSize">
            <summary>Verifies that the pool's Capacity is applied correctly</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PoolTest.TestClass">
            <summary>Used to test the pool</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PoolTest.TestClass.Recycle">
            <summary>Returns the object to its initial state</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PoolTest.TestClass.Recycled">
            <summary>Whether the instance has been recycled</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityItemPair`2">
            <summary>An pair of a priority and an item</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPair`2.#ctor(`0,`1)">
            <summary>Initializes a new priority / item pair</summary>
            <param name="priority">Priority of the item in the pair</param>
            <param name="item">Item to be stored in the pair</param>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityItemPair`2.Priority">
            <summary>Priority assigned to this priority / item pair</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityItemPair`2.Item">
            <summary>Item contained in this priority / item pair</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPair`2.ToString">
            <summary>Converts the priority / item pair into a string</summary>
            <returns>A string describing the priority / item pair</returns>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityItemPairTest">
            <summary>Unit Test for the Priority/Item pair class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPairTest.TestDefaultConstructor">
            <summary>Tests whether the pair's default constructor works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPairTest.TestPriorityRetrieval">
            <summary>Tests whether the priority can be retrieved from the pair</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPairTest.TestItemRetrieval">
            <summary>Tests whether the item can be retrieved from the pair</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPairTest.TestToStringWithValidStrings">
            <summary>Tests whether the ToString() methods works with valid strings</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPairTest.TestToStringWithNullStrings">
            <summary>Tests whether the ToString() methods works with null strings</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityItemPairTest.ToStringNullReturner">
            <summary>Test class in which ToString() can return null</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPairTest.ToStringNullReturner.ToString">
            <summary>
              Returns a System.String that represents the current System.Object
            </summary>
            <returns>A System.String that represents the current System.Object</returns>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityQueue`1">
            <summary>Queue that dequeues items in order of their priority</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.#ctor">
            <summary>
              Initializes a new priority queue using IComparable for comparing items
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>Initializes a new priority queue</summary>
            <param name="comparer">Comparer to use for ordering the items</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Peek">
            <summary>Returns the topmost item in the queue without dequeueing it</summary>
            <returns>The topmost item in the queue</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Dequeue">
            <summary>Takes the item with the highest priority off from the queue</summary>
            <returns>The item with the highest priority in the list</returns>
            <exception cref="T:System.InvalidOperationException">When the queue is empty</exception>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enqueue(`0)">
            <summary>Puts an item into the priority queue</summary>
            <param name="item">Item to be queued</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Clear">
            <summary>Removes all items from the priority queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the priority queue into an array</summary>
            <param name="array">Array to copy the priority queue into</param>
            <param name="index">Starting index for the destination array</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.GetEnumerator">
            <summary>Returns a typesafe enumerator for the priority queue</summary>
            <returns>A new enumerator for the priority queue</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.bubbleUp(System.Int32,`0)">
            <summary>Moves an item upwards in the heap tree</summary>
            <param name="index">Index of the item to be moved</param>
            <param name="item">Item to be moved</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.trickleDown(System.Int32,`0)">
            <summary>Move the item downwards in the heap tree</summary>
            <param name="index">Index of the item to be moved</param>
            <param name="item">Item to be moved</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.getLeftChild(System.Int32)">
            <summary>Obtains the left child item in the heap tree</summary>
            <param name="index">Index of the item whose left child to return</param>
            <returns>The left child item of the provided parent item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.getParent(System.Int32)">
            <summary>Calculates the parent entry of the item on the heap</summary>
            <param name="index">Index of the item whose parent to calculate</param>
            <returns>The index of the parent to the specified item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.growHeap">
            <summary>Increases the size of the priority collection's heap</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator for the priority queue</summary>
            <returns>A new enumerator for the priority queue</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.comparer">
            <summary>Comparer used to order the items in the priority queue</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.count">
            <summary>Total number of items in the priority queue</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.capacity">
            <summary>Available space in the priority queue</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.heap">
            <summary>Tree containing the items in the priority queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.Count">
            <summary>Total number of items in the priority queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.SyncRoot">
            <summary>
              Obtains an object that can be used to synchronize accesses to the priority queue
              from different threads
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.IsSynchronized">
            <summary>Whether operations performed on this priority queue are thread safe</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityQueue`1.Enumerator">
            <summary>Enumerates all items contained in a priority queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.#ctor(Nuclex.Support.Collections.PriorityQueue{`0})">
            <summary>Initializes a new priority queue enumerator</summary>
            <param name="priorityQueue">Priority queue to be enumerated</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.Reset">
            <summary>Resets the enumerator to its initial state</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.MoveNext">
            <summary>Moves to the next item in the priority queue</summary>
            <returns>True if a next item was found, false if the end has been reached</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.Dispose">
            <summary>Releases all resources used by the enumerator</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.index">
            <summary>Index of the current item in the priority queue</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.priorityQueue">
            <summary>The priority queue whose items this instance enumerates</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.System#Collections#Generic#IEnumerator{ItemType}#Current">
            <summary>The current item being enumerated</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>The current item being enumerated</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityQueueTest">
            <summary>Unit Test for the priority queue class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueueTest.TestCount">
            <summary>Tests to ensure the count property is properly updated</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueueTest.TestOrdering">
            <summary>Tests to ensure that the priority collection actually sorts items</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueueTest.TestPeekEmptyQueue">
            <summary>
              Verifies that an exception is thrown when Peek() is called on an empty queue
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueueTest.TestDequeueEmptyQueue">
            <summary>
              Verifies that an exception is thrown when Dequeue() is called on an empty queue
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueueTest.TestLargeQueue">
            <summary>
              Verifies that the priority queue can handle large amounts of data
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityQueueTest.FloatComparer">
            <summary>Comparer for two floating point values</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueueTest.FloatComparer.Default">
            <summary>The default instance of this comparer</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueueTest.FloatComparer.Compare(System.Single,System.Single)">
            <summary>Compares two floating points against each other</summary>
            <param name="left">First float to compare</param>
            <param name="right">Second float to compare</param>
            <returns>The relationship of the two floats to each other</returns>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyCollection`1">
            <summary>Wraps a Collection and prevents users from modifying it</summary>
            <typeparam name="ItemType">Type of items to manage in the Collection</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>Initializes a new read-only Collection wrapper</summary>
            <param name="collection">Collection that will be wrapped</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.Contains(`0)">
            <summary>Determines whether the List contains the specified item</summary>
            <param name="item">Item that will be checked for</param>
            <returns>True if the specified item is contained in the List</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the List into an array</summary>
            <param name="array">Array the List will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.GetEnumerator">
            <summary>Returns a new enumerator over the contents of the List</summary>
            <returns>The new List contents enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#Generic#ICollection{ItemType}#Add(`0)">
            <summary>Adds an item to the end of the List</summary>
            <param name="item">Item that will be added to the List</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#Generic#ICollection{ItemType}#Clear">
            <summary>Removes all items from the List</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#Generic#ICollection{ItemType}#Remove(`0)">
            <summary>Removes the specified item from the List</summary>
            <param name="item">Item that will be removed from the List</param>
            <returns>True of the specified item was found in the List and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a new enumerator over the contents of the List</summary>
            <returns>The new List contents enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the List into an array</summary>
            <param name="array">Array the List will be copied into</param>
            <param name="index">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyCollection`1.typedCollection">
            <summary>The wrapped Collection under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyCollection`1.objectCollection">
            <summary>The wrapped Collection under its object interface</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyCollection`1.Count">
            <summary>The number of items current contained in the List</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyCollection`1.IsReadOnly">
            <summary>Whether the List is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the List is synchronized for multi-threaded usage</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root on which the List locks</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyCollectionTest">
            <summary>Unit Test for the read only collection wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestCopyConstructor">
            <summary>
              Verifies that the copy constructor of the read only collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestIsReadOnly">
            <summary>Verifies that the IsReadOnly property returns true</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestCopyToArray">
            <summary>
              Verifies that the CopyTo() of the read only collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestContains">
            <summary>
              Checks whether the Contains() method of the read only collection is able to
              determine if the collection contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestThrowOnAdd">
            <summary>
              Ensures that the Add() method of the read only collection throws an exception
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestThrowOnRemove">
            <summary>
              Ensures that the Remove() method of the read only collection throws an exception
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestThrowOnClear">
            <summary>
              Ensures that the Clear() method of the read only collection throws an exception
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestTypesafeEnumerator">
            <summary>
              Tests whether the typesafe enumerator of the read only collection is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestCopyToArrayViaICollection">
            <summary>
              Verifies that the CopyTo() of the read only collection works if invoked via
              the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollectionTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyDictionary`2">
            <summary>Wraps a dictionary and prevents users from modifying it</summary>
            <typeparam name="KeyType">Type of the keys used in the dictionary</typeparam>
            <typeparam name="ValueType">Type of the values used in the dictionary</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the System.WeakReference class, using deserialized
              data from the specified serialization and stream objects.
            </summary>
            <param name="info">
              An object that holds all the data needed to serialize or deserialize the
              current System.WeakReference object.
            </param>
            <param name="context">
              (Reserved) Describes the source and destination of the serialized stream
              specified by info.
            </param>
            <exception cref="T:System.ArgumentNullException">
              The info parameter is null.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>Initializes a new read-only dictionary wrapper</summary>
            <param name="dictionary">Dictionary that will be wrapped</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
              Determines whether the specified KeyValuePair is contained in the Dictionary
            </summary>
            <param name="item">KeyValuePair that will be checked for</param>
            <returns>True if the provided KeyValuePair was contained in the Dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the Dictionary contains the specified key</summary>
            <param name="key">Key that will be checked for</param>
            <returns>
              True if an entry with the specified key was contained in the Dictionary
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.GetEnumerator">
            <summary>Creates a new enumerator for the Dictionary</summary>
            <returns>The new Dictionary enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
              Attempts to retrieve the item with the specified key from the Dictionary
            </summary>
            <param name="key">Key of the item to attempt to retrieve</param>
            <param name="value">
              Output parameter that will receive the key upon successful completion
            </param>
            <returns>
              True if the item was found and has been placed in the output parameter
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{KeyType@ValueType}#Add(`0,`1)">
            <summary>Inserts an item into the Dictionary</summary>
            <param name="key">Key under which to add the new item</param>
            <param name="value">Item that will be added to the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{KeyType@ValueType}#Remove(`0)">
            <summary>Removes the item with the specified key from the Dictionary</summary>
            <param name="key">Key of the elementes that will be removed</param>
            <returns>True if an item with the specified key was found and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a new object enumerator for the Dictionary</summary>
            <returns>The new object enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Clear">
            <summary>Removes all items from the Dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>Adds an item into the Dictionary</summary>
            <param name="key">Key under which the item will be added</param>
            <param name="value">Item that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>Determines whether the specified key exists in the Dictionary</summary>
            <param name="key">Key that will be checked for</param>
            <returns>True if an item with the specified key exists in the Dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>Returns a new entry enumerator for the dictionary</summary>
            <returns>The new entry enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>Removes an item from the Dictionary</summary>
            <param name="key">Key of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Inserts an already prepared element into the Dictionary</summary>
            <param name="item">Prepared element that will be added to the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Clear">
            <summary>Removes all items from the Dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Removes all items from the Dictionary</summary>
            <param name="itemToRemove">Item that will be removed from the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary contents will be copied into</param>
            <param name="index">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Serializes the Dictionary</summary>
            <param name="info">
              Provides the container into which the Dictionary will serialize itself
            </param>
            <param name="context">
              Contextual informations about the serialization environment
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)">
            <summary>Called after all objects have been successfully deserialized</summary>
            <param name="sender">Nicht unterstützt</param>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyDictionary`2.typedDictionary">
            <summary>The wrapped Dictionary under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyDictionary`2.objectDictionary">
            <summary>The wrapped Dictionary under its object interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyDictionary`2.readonlyKeyCollection">
            <summary>ReadOnly wrapper for the keys collection of the Dictionary</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyDictionary`2.readonlyValueCollection">
            <summary>ReadOnly wrapper for the values collection of the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.IsReadOnly">
            <summary>Whether the directory is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.Count">
            <summary>Number of elements contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.Keys">
            <summary>Collection of all keys contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.Values">
            <summary>Collection of all values contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.Item(`0)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{KeyType@ValueType}#Item(`0)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>Whether the size of the Dictionary is fixed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Keys">
            <summary>Returns a collection of all keys in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Values">
            <summary>Returns a collection of all values stored in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
            <returns>The item with the specified key</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the Dictionary is synchronized for multi-threaded usage</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root on which the Dictionary locks</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyDictionary`2.SerializedDictionary">
            <summary>
              Dictionary wrapped used to reconstruct a serialized read only dictionary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.SerializedDictionary.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the System.WeakReference class, using deserialized
              data from the specified serialization and stream objects.
            </summary>
            <param name="info">
              An object that holds all the data needed to serialize or deserialize the
              current System.WeakReference object.
            </param>
            <param name="context">
              (Reserved) Describes the source and destination of the serialized stream
              specified by info.
            </param>
            <exception cref="T:System.ArgumentNullException">
              The info parameter is null.
            </exception>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyDictionaryTest">
            <summary>Unit Test for the read only dictionary wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestCopyConstructor">
            <summary>
              Verifies that the copy constructor of the read only dictionary works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestIsReadOnly">
            <summary>Verifies that the IsReadOnly property returns true</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestContains">
            <summary>
              Checks whether the Contains() method of the read only dictionary is able to
              determine if the dictionary contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestContainsKey">
            <summary>
              Checks whether the Contains() method of the read only dictionary is able to
              determine if the dictionary contains a key
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestCopyToArray">
            <summary>
              Verifies that the CopyTo() of the read only dictionary works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestTypesafeEnumerator">
            <summary>
              Tests whether the typesafe enumerator of the read only dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestGetKeysCollection">
            <summary>
              Tests whether the keys collection of the read only dictionary can be queried
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestGetValuesCollection">
            <summary>
              Tests whether the values collection of the read only dictionary can be queried
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestTryGetValue">
            <summary>
              Tests whether the TryGetValue() method of the read only dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestRetrieveValueByIndexer">
            <summary>
              Tests whether the retrieval of values using the indexer of the read only
              dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnRetrieveNonExistingValueByIndexer">
            <summary>
              Tests whether an exception is thrown if the indexer of the read only dictionary
              is used to attempt to retrieve a non-existing value
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnAddViaGenericIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Add() method is called via the generic IDictionary&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnRemoveViaGenericIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Remove() method is called via the generic IDictionary&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestRetrieveValueByIndexerViaGenericIDictionary">
            <summary>
              Tests whether the TryGetValue() method of the read only dictionary is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnReplaceByIndexerViaGenericIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              indexer is used to insert an item via the generic IDictionar&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnClearViaIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Clear() method is called via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnAddViaIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Add() method is called via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestContainsViaIDictionary">
            <summary>
              Checks whether the Contains() method of the read only dictionary is able to
              determine if the dictionary contains an item via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestEnumeratorViaIDictionary">
            <summary>
              Checks whether the GetEnumerator() method of the read only dictionary returns
              a working enumerator if accessed via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestIsFixedSizeViaIList">
            <summary>
              Checks whether the IsFixedSize property of the read only dictionary returns
              the expected result for a read only dictionary based on a dynamic dictionary
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestGetKeysCollectionViaIDictionary">
            <summary>
              Tests whether the keys collection of the read only dictionary can be queried
              via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestGetValuesCollectionViaIDictionary">
            <summary>
              Tests whether the values collection of the read only dictionary can be queried
              via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnRemoveViaIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Remove() method is called via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestRetrieveValueByIndexerViaIDictionary">
            <summary>
              Tests whether the retrieval of values using the indexer of the read only
              dictionary is working via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnReplaceByIndexerViaIDictionary">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              indexer is used to insert an item via the IDictionary interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnAddViaGenericICollection">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Add() method is used via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnClearViaGenericICollection">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Clear() method is used via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestThrowOnRemoveViaGenericICollection">
            <summary>
              Checks whether the read only dictionary will throw an exception if its
              Remove() method is used via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestCopyToArrayViaICollection">
            <summary>
              Verifies that the CopyTo() of the read only dictionary works when called
              via the the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.TestSerialization">
            <summary>
              Test whether the read only dictionary can be serialized
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.createTestDictionary">
            <summary>
              Creates a new read-only dictionary filled with some values for testing
            </summary>
            <returns>The newly created read-only dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionaryTest.makeReadOnly(System.Collections.Generic.IDictionary{System.Int32,System.String})">
            <summary>
              Creates a new read-only dictionary filled with some values for testing
            </summary>
            <returns>The newly created read-only dictionary</returns>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyList`1">
            <summary>Wraps a List and prevents users from modifying it</summary>
            <typeparam name="ItemType">Type of items to manage in the List</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new read-only List wrapper</summary>
            <param name="list">List that will be wrapped</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.IndexOf(`0)">
            <summary>Retrieves the index of an item within the List</summary>
            <param name="item">Item whose index will be returned</param>
            <returns>The zero-based index of the specified item in the List</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.Contains(`0)">
            <summary>Determines whether the List contains the specified item</summary>
            <param name="item">Item that will be checked for</param>
            <returns>True if the specified item is contained in the List</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the List into an array</summary>
            <param name="array">Array the List will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.GetEnumerator">
            <summary>Returns a new enumerator over the contents of the List</summary>
            <returns>The new List contents enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#IList{ItemType}#Insert(System.Int32,`0)">
            <summary>Inserts an item into the List</summary>
            <param name="index">Zero-based index before which the item will be inserted</param>
            <param name="item">Item that will be inserted into the List</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#IList{ItemType}#RemoveAt(System.Int32)">
            <summary>Removes an item from the list</summary>
            <param name="index">Zero-based index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#ICollection{ItemType}#Add(`0)">
            <summary>Adds an item to the end of the List</summary>
            <param name="item">Item that will be added to the List</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#ICollection{ItemType}#Clear">
            <summary>Removes all items from the List</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#ICollection{ItemType}#Remove(`0)">
            <summary>Removes the specified item from the List</summary>
            <param name="item">Item that will be removed from the List</param>
            <returns>True of the specified item was found in the List and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a new enumerator over the contents of the List</summary>
            <returns>The new List contents enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Clear">
            <summary>Removes all items from the List</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the end of the List</summary>
            <param name="value">Item that will be added to the List</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Contains(System.Object)">
            <summary>Determines whether the List contains the specified item</summary>
            <param name="value">Item that will be checked for</param>
            <returns>True if the specified item is contained in the List</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>Retrieves the index of an item within the List</summary>
            <param name="value">Item whose index will be returned</param>
            <returns>The zero-based index of the specified item in the List</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>Inserts an item into the List</summary>
            <param name="index">Zero-based index before which the item will be inserted</param>
            <param name="value">Item that will be inserted into the List</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Remove(System.Object)">
            <summary>Removes the specified item from the List</summary>
            <param name="value">Item that will be removed from the List</param>
            <returns>True of the specified item was found in the List and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>Removes an item from the list</summary>
            <param name="index">Zero-based index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the List into an array</summary>
            <param name="array">Array the List will be copied into</param>
            <param name="index">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyList`1.typedList">
            <summary>The wrapped List under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyList`1.objectList">
            <summary>The wrapped List under its object interface</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.Item(System.Int32)">
            <summary>Accesses the List item with the specified index</summary>
            <param name="index">Zero-based index of the List item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.Count">
            <summary>The number of items current contained in the List</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.IsReadOnly">
            <summary>Whether the List is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#IList{ItemType}#Item(System.Int32)">
            <summary>Accesses the List item with the specified index</summary>
            <param name="index">Zero-based index of the List item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#IsFixedSize">
            <summary>Whether the size of the List is fixed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Item(System.Int32)">
            <summary>Accesses the List item with the specified index</summary>
            <param name="index">Zero-based index of the List item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the List is synchronized for multi-threaded usage</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root on which the List locks</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyListTest">
            <summary>Unit Test for the read only list wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestCopyConstructor">
            <summary>
              Verifies that the copy constructor of the read only list works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestIsReadOnly">
            <summary>Verifies that the IsReadOnly property returns true</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestCopyToArray">
            <summary>
              Verifies that the CopyTo() of the read only list works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestContains">
            <summary>
              Checks whether the Contains() method of the read only list is able to
              determine if the list contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestIndexOf">
            <summary>
              Checks whether the IndexOf() method of the read only list is able to
              determine if the index of an item in the list
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestRetrieveByIndexer">
            <summary>
              Checks whether the indexer method of the read only list is able to
              retrieve items from the list
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnInsertViaGenericIList">
            <summary>
              Checks whether the read only list will throw an exception if its Insert() method
              is called via the generic IList&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnRemoveViaGenericIList">
            <summary>
              Checks whether the read only list will throw an exception if its RemoveAt() method
              is called via the generic IList&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestRetrieveByIndexerViaGenericIList">
            <summary>
              Checks whether the indexer method of the read only list will throw an exception
              if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnReplaceByIndexerViaGenericIList">
            <summary>
              Checks whether the indexer method of the read only list will throw an exception
              if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnAddViaGenericICollection">
            <summary>
              Checks whether the read only list will throw an exception if its Add() method
              is called via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnClearViaGenericICollection">
            <summary>
              Checks whether the read only list will throw an exception if its Clear() method
              is called via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnRemoveViaGenericICollection">
            <summary>
              Checks whether the read only list will throw an exception if its Remove() method
              is called via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestTypesafeEnumerator">
            <summary>
              Tests whether the typesafe enumerator of the read only list is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnClearViaIList">
            <summary>
              Checks whether the read only list will throw an exception if its Clear() method
              is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnAddViaIList">
            <summary>
              Checks whether the read only list will throw an exception if its Add() method
              is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestContainsViaIList">
            <summary>
              Checks whether the Contains() method of the read only list is able to
              determine if the list contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestIndexOfViaIList">
            <summary>
              Checks whether the IndexOf() method of the read only list is able to
              determine if the index of an item in the list
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnInsertViaIList">
            <summary>
              Checks whether the read only list will throw an exception if its Insert() method
              is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestIsFixedSizeViaIList">
            <summary>
              Checks whether the IsFixedSize property of the read only list returns the
              expected result for a read only list based on a fixed array
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnRemoveViaIList">
            <summary>
              Checks whether the read only list will throw an exception if its Remove() method
              is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnRemoveAtViaIList">
            <summary>
              Checks whether the read only list will throw an exception if its Remove() method
              is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestRetrieveByIndexerViaIList">
            <summary>
              Checks whether the indexer method of the read only list will throw an exception
              if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestThrowOnReplaceByIndexerViaIList">
            <summary>
              Checks whether the indexer method of the read only list will throw an exception
              if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestCopyToArrayViaICollection">
            <summary>
              Verifies that the CopyTo() of the read only list works if invoked via
              the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyListTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReverseComparer`1">
            <summary>
              Compares two values in reverse or reverses the output of another comparer
            </summary>
            <typeparam name="ComparedType">Type of values to be compared</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparer`1.#ctor">
            <summary>Initializes a new reverse comparer</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparer`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
              Initializes the comparer to provide the inverse results of another comparer
            </summary>
            <param name="comparerToReverse">Comparer whose results will be inversed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparer`1.Compare(`0,`0)">
            <summary>Compares the left value to the right value</summary>
            <param name="left">Value on the left side</param>
            <param name="right">Value on the right side</param>
            <returns>The relationship of the two values</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.ReverseComparer`1.comparer">
            <summary>The default comparer from the .NET framework</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReverseComparerTest">
            <summary>Unit Test for the ReverseComparer helper class</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparerTest.TestDefaultConstructor">
            <summary>
              Tests whether the default constructor of the reverse comparer works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparerTest.TestFullConstructor">
            <summary>
              Tests whether the full constructor of the reverse comparer works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparerTest.TestReversedDefaultComparer">
            <summary>
              Tests whether the full constructor of the reverse comparer works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparerTest.TestReversedCustomComparer">
            <summary>
              Tests whether the full constructor of the reverse comparer works
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReverseComparerTest.FortyTwoComparer">
            <summary>Special comparer in which 42 is larger than everything</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparerTest.FortyTwoComparer.Compare(System.Int32,System.Int32)">
            <summary>Compares the left value to the right value</summary>
            <param name="left">Value on the left side</param>
            <param name="right">Value on the right side</param>
            <returns>The relationship of the two values</returns>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPool">
            <summary>Alternative Thread pool providing one thread for each core</summary>
            <remarks>
              <para>
                Unlike the normal thread pool, the affine thread pool provides only as many
                threads as there are CPU cores available on the current platform. This makes
                it more suitable for tasks you want to spread across all available cpu cores
                explicitely.
              </para>
              <para>
                However, it's not a good match if you want to run blocking or waiting tasks
                inside the thread pool because the limited available threads will become
                congested quickly. It is encouraged to use this class in parallel with
                .NET's own thread pool, putting tasks that can block into the .NET thread
                pool and task that perform pure processing into the affine thread pool.
              </para>
              <para>
                Implementation based on original code provided by Stephen Toub
                (stoub at microsoft ignorethis dot com)
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.Processors">
            <summary>Number of CPU cores available on the system</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.#cctor">
            <summary>Initializes the thread pool</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
            <summary>Queues a user work item to the thread pool</summary>
            <param name="callback">
              A WaitCallback representing the delegate to invoke when a thread in the 
              thread pool picks up the work item
            </param>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)">
            <summary>Queues a user work item to the thread pool.</summary>
            <param name="callback">
              A WaitCallback representing the delegate to invoke when a thread in the 
              thread pool picks up the work item
            </param>
            <param name="state">
              The object that is passed to the delegate when serviced from the thread pool
            </param>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.DefaultExceptionHandler(System.Exception)">
            <summary>
              Default handler used to respond to unhandled exceptions in ThreadPool threads
            </summary>
            <param name="exception">Exception that has occurred</param>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.ProcessQueuedItems">
            <summary>A thread worker function that processes items from the work queue</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.GetProcessThread(System.Int32)">
            <summary>Retrieves the ProcessThread for the calling thread</summary>
            <returns>The ProcessThread for the calling thread</returns>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.getNextWorkItem">
            <summary>Obtains the next work item from the queue</summary>
            <returns>The next work item in the queue</returns>
            <remarks>
              If the queue is empty, the call will block until an item is added to
              the queue and the calling thread was the one picking it up.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.ExceptionHandler">
            <summary>Delegate used to handle assertion checks in the code</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.GetCurrentThreadId">
            <summary>Retrieves the calling thread's thread id</summary>
            <returns>The thread is of the calling thread</returns>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.hardwareThreads">
            <summary>Available hardware threads the thread pool threads pick from</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.userWorkItems">
            <summary>Queue of all the callbacks waiting to be executed.</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.workAvailable">
            <summary>
              Used to let the threads in the thread pool wait for new work to appear.
            </summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.workerThreads">
            <summary>List of all worker threads at the disposal of the thread pool.</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.inUseThreads">
            <summary>Number of threads currently active.</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPool.MaxThreads">
            <summary>Gets the number of threads at the disposal of the thread pool</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPool.ActiveThreads">
            <summary>Gets the number of currently active threads in the thread pool</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPool.WaitingWorkItems">
            <summary>
              Gets the number of callback delegates currently waiting in the thread pool
            </summary>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPool.ExceptionDelegate">
            <summary>Delegate used by the thread pool to report unhandled exceptions</summary>
            <param name="exception">Exception that has not been handled</param>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPool.UserWorkItem">
            <summary>Used to hold a callback delegate and the state for that delegate.</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.UserWorkItem.#ctor(System.Threading.WaitCallback,System.Object)">
            <summary>Initialize the callback holding object.</summary>
            <param name="callback">Callback delegate for the callback.</param>
            <param name="state">State with which to call the callback delegate.</param>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.UserWorkItem.Callback">
            <summary>Callback delegate for the callback.</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.UserWorkItem.State">
            <summary>State with which to call the callback delegate.</summary>
        </member>
        <member name="T:Nuclex.Support.EnumHelper">
            <summary>Helper methods for enumerations</summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelper.GetHighestValue``1">
            <summary>Returns the highest value encountered in an enumeration</summary>
            <typeparam name="EnumType">
              Enumeration of which the highest value will be returned
            </typeparam>
            <returns>The highest value in the enumeration</returns>
        </member>
        <member name="M:Nuclex.Support.EnumHelper.GetLowestValue``1">
            <summary>Returns the lowest value encountered in an enumeration</summary>
            <typeparam name="EnumType">
              Enumeration of which the lowest value will be returned
            </typeparam>
            <returns>The lowest value in the enumeration</returns>
        </member>
        <member name="M:Nuclex.Support.EnumHelper.GetValues``1">
            <summary>Retrieves a list of all values contained in an enumeration</summary>
            <typeparam name="EnumType">
              Type of the enumeration whose values will be returned
            </typeparam>
            <returns>All values contained in the specified enumeration</returns>
            <remarks>
              This method produces collectable garbage so it's best to only call it once
              and cache the result.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.EnumHelper.GetValuesXbox360``1">
            <summary>Retrieves a list of all values contained in an enumeration</summary>
            <typeparam name="EnumType">
              Type of the enumeration whose values will be returned
            </typeparam>
            <returns>All values contained in the specified enumeration</returns>
        </member>
        <member name="T:Nuclex.Support.EnumHelperTest">
            <summary>Unit Test for the enumeration helper class</summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestGetValuesXbox360">
            <summary>
              Verifies that the enum helper can list the members of an enumeration
              manually (as it needs to be done on the XBox 360)
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestGetValues">
            <summary>
              Verifies that the enum helper can list the members of an enumeration
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestGetHighestValue">
            <summary>
              Verifies that the enum helper can locate the highest value in an enumeration
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestGetLowestValue">
            <summary>
              Verifies that the enum helper can locate the lowest value in an enumeration
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestThrowOnNonEnumTypeXbox360">
            <summary>
              Tests whether an exception is thrown if the GetValuesXbox360() method is
              used on a non-enumeration type
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestThrowOnNonEnumType">
            <summary>
              Tests whether an exception is thrown if the GetValues() method is used on
              a non-enumeration type
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestLowestValueInEmptyEnumeration">
            <summary>
              Verifies that the default value for an enumeration is returned if
              the GetLowestValue() method is used on an empty enumeration
            </summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelperTest.TestHighestValueInEmptyEnumeration">
            <summary>
              Verifies that the default value for an enumeration is returned if
              the GetHighestValue() method is used on an empty enumeration
            </summary>
        </member>
        <member name="T:Nuclex.Support.EnumHelperTest.TestEnumeration">
            <summary>An enumeration used for unit testing</summary>
        </member>
        <member name="F:Nuclex.Support.EnumHelperTest.TestEnumeration.One">
            <summary>First arbitrary enumeration value</summary>
        </member>
        <member name="F:Nuclex.Support.EnumHelperTest.TestEnumeration.Three">
            <summary>Third arbitrary enumeration value</summary>
        </member>
        <member name="F:Nuclex.Support.EnumHelperTest.TestEnumeration.Two">
            <summary>Second arbitrary enumeration value</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PrototypeFactory`2">
            <summary>Factory that creates instances by cloning a prototype</summary>
            <typeparam name="ProductType">Type of product created by the factory</typeparam>
            <typeparam name="ConcreteType">Type of the prototype that will be cloned</typeparam>
        </member>
        <member name="T:Nuclex.Support.Plugins.IAbstractFactory`1">
            <summary>Abstract factory for a concrete type</summary>
            <typeparam name="ProductType">
              Interface or base class of the product of the factory
            </typeparam>
        </member>
        <member name="M:Nuclex.Support.Plugins.IAbstractFactory`1.CreateInstance">
            <summary>
              Creates a new instance of the type to which the factory is specialized
            </summary>
            <returns>The newly created instance</returns>
        </member>
        <member name="T:Nuclex.Support.Plugins.IAbstractFactory">
            <summary>Abstract factory for a concrete type</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.IAbstractFactory.CreateInstance">
            <summary>
              Creates a new instance of the type to which the factory is specialized
            </summary>
            <returns>The newly created instance</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactory`2.#ctor(`1)">
            <summary>Initializes a new prototype based factory</summary>
            <param name="prototype">Prototype instance that will be cloned</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactory`2.CreateInstance">
            <summary>
              Creates a new instance of the type to which the factory is specialized
            </summary>
            <returns>The newly created instance</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactory`2.Nuclex#Support#Plugins#IAbstractFactory#CreateInstance">
            <summary>
              Creates a new instance of the type to which the factory is specialized
            </summary>
            <returns>The newly created instance</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactory`2.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="F:Nuclex.Support.Plugins.PrototypeFactory`2.prototype">
            <summary>The prototype object</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PrototypeFactoryTest">
            <summary>Unit Test for the prototype-based factory class</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactoryTest.TestGenericInstanceCreation">
            <summary>
              Tests whether the prototype-based factory behaves correctly by creating
              new instances of its product using clones of its assigned prototype.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactoryTest.TestInstanceCreation">
            <summary>
              Tests whether the prototype-based factory behaves correctly by creating
              new instances of its product using clones of its assigned prototype.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactoryTest.TestPrototypeDisposal">
            <summary>
              Tests whether the prototype is disposed if it implements the IDisposable
              interface and the factory is explicitely disposed.
            </summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PrototypeFactoryTest.IProduct">
            <summary>Interface used for the product in the unit test</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.PrototypeFactoryTest.IProduct.Value">
            <summary>Some value associated with the product</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PrototypeFactoryTest.ConcretePrototype">
            <summary>
              Class derived from the abstract base to serve as concrete product for
              testing the factory employer
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactoryTest.ConcretePrototype.#ctor(System.Int32)">
            <summary>Initializes a new instance of the prototype product</summary>
            <param name="value">Value that will be associated with this instance</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactoryTest.ConcretePrototype.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactoryTest.ConcretePrototype.System#ICloneable#Clone">
            <summary>Creates an identical copy of the instance</summary>
            <returns>An identical copy of the instance</returns>
        </member>
        <member name="F:Nuclex.Support.Plugins.PrototypeFactoryTest.ConcretePrototype.value">
            <summary>Value associated with the product</summary>
        </member>
        <member name="F:Nuclex.Support.Plugins.PrototypeFactoryTest.ConcretePrototype.disposed">
            <summary>Whether the instance has been disposed</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.PrototypeFactoryTest.ConcretePrototype.Value">
            <summary>Value the product has been associated with</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.PrototypeFactoryTest.ConcretePrototype.IsDisposed">
            <summary>Whether the prototype instance has been disposed</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.GenericTimeSourceTest">
            <summary>Unit Test for the generic scheduler time source</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSourceTest.TestDefaultConstructor">
            <summary>
              Verifies that the time source's default constructor is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSourceTest.TestCurrentUtcTime">
            <summary>
              Verifies that the time source can provide the current UTC time
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSourceTest.TestTicksWithStopwatch">
            <summary>
              Verifies that the default time source's tick property is working if
              the Stopwatch class is used to measure time
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSourceTest.TestTicksWithTickCount">
            <summary>
              Verifies that the default time source's tick property is working if
              Environment.TickCount is used to measure time
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSourceTest.TestWaitOne">
            <summary>
              Verifies that the default time source's WaitOne() method works correctly
            </summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.ISchedulerService">
            <summary>Service that allows the scheduled invocation of tasks</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ISchedulerService.NotifyAt(System.DateTime,System.Threading.WaitCallback)">
            <summary>Schedules a notification at the specified absolute time</summary>
            <param name="notificationTime">
              Absolute time at which the notification will occur
            </param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
            <remarks>
              The notification is scheduled for the indicated absolute time. If the system
              enters/leaves daylight saving time or the date/time is changed (for example
              when the system synchronizes with an NTP server), this will affect
              the notification. So if you need to be notified after a fixed time, use
              the NotifyIn() method instead.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ISchedulerService.NotifyEach(System.Int32,System.Int32,System.Threading.WaitCallback)">
            <summary>
              Schedules a recurring notification after the specified amount of milliseconds
            </summary>
            <param name="delayMilliseconds">
              Milliseconds after which the first notification will occur
            </param>
            <param name="intervalMilliseconds">
              Interval in milliseconds at which the notification will be repeated
            </param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ISchedulerService.NotifyEach(System.TimeSpan,System.TimeSpan,System.Threading.WaitCallback)">
            <summary>
              Schedules a recurring notification after the specified time span
            </summary>
            <param name="delay">Delay after which the first notification will occur</param>
            <param name="interval">Interval at which the notification will be repeated</param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ISchedulerService.NotifyIn(System.Int32,System.Threading.WaitCallback)">
            <summary>
              Schedules a notification after the specified amount of milliseconds
            </summary>
            <param name="delayMilliseconds">
              Number of milliseconds after which the notification will occur
            </param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ISchedulerService.NotifyIn(System.TimeSpan,System.Threading.WaitCallback)">
            <summary>Schedules a notification after the specified time span</summary>
            <param name="delay">Delay after which the notification will occur</param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ISchedulerService.Cancel(System.Object)">
            <summary>Cancels a scheduled notification</summary>
            <param name="notificationHandle">
              Handle of the notification that will be cancelled
            </param>
        </member>
        <member name="P:Nuclex.Support.Scheduling.ISchedulerService.TimeSource">
            <summary>Time source being used by the scheduler</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.ITimeSource">
            <summary>Provides time measurement and change notification services</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ITimeSource.WaitOne(System.Threading.AutoResetEvent,System.Int64)">
            <summary>Waits for an AutoResetEvent to become signalled</summary>
            <param name="waitHandle">WaitHandle the method will wait for</param>
            <param name="ticks">Number of ticks to wait</param>
            <returns>
              True if the WaitHandle was signalled, false if the timeout was reached
              or the time source thinks its time to recheck the system date/time.
            </returns>
            <remarks>
              Depending on whether the system will provide notifications when date/time
              is adjusted, the time source will be forced to let this method block for
              less than the indicated time before returning a timeout in order to give
              the caller a chance to recheck the system time.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Scheduling.ITimeSource.DateTimeAdjusted">
            <summary>Called when the system date/time are adjusted</summary>
            <remarks>
              An adjustment is a change out of the ordinary, eg. when a time synchronization
              alters the current system time, when daylight saving time takes effect or
              when the user manually adjusts the system date/time.
            </remarks>
        </member>
        <member name="P:Nuclex.Support.Scheduling.ITimeSource.CurrentUtcTime">
            <summary>Current system time in UTC format</summary>
        </member>
        <member name="P:Nuclex.Support.Scheduling.ITimeSource.Ticks">
            <summary>How long the time source has been running</summary>
            <remarks>
              There is no guarantee this value starts at zero (or anywhere near it) when
              the time source is created. The only requirement for this value is that it
              keeps increasing with the passing of time and that it stays unaffected
              (eg. doesn't skip or jump back) when the system date/time are changed.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Scheduling.Scheduler">
            <summary>Schedules actions for execution at a future point in time</summary>
            <summary>Schedules actions for execution at a future point in time</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.TicksPerMillisecond">
            <summary>One tick is 100 ns, meaning 10000 ticks equal 1 ms</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.#ctor">
            <summary>Initializes a new scheduler using the default time source</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.#ctor(Nuclex.Support.Scheduling.ITimeSource)">
            <summary>Initializes a new scheduler using the specified time source</summary>
            <param name="timeSource">Time source the scheduler will use</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.NotifyAt(System.DateTime,System.Threading.WaitCallback)">
            <summary>Schedules a notification at the specified absolute time</summary>
            <param name="notificationTime">
              Absolute time at which the notification will occur
            </param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
            <remarks>
              The notification is scheduled for the indicated absolute time. If the system
              enters/leaves daylight saving time or the date/time is changed (for example
              when the system synchronizes with an NTP server), this will affect
              the notification. So if you need to be notified after a fixed time, use
              the NotifyIn() method instead.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.NotifyIn(System.TimeSpan,System.Threading.WaitCallback)">
            <summary>Schedules a notification after the specified time span</summary>
            <param name="delay">Delay after which the notification will occur</param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.NotifyIn(System.Int32,System.Threading.WaitCallback)">
            <summary>
              Schedules a notification after the specified amount of milliseconds
            </summary>
            <param name="delayMilliseconds">
              Number of milliseconds after which the notification will occur
            </param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.NotifyEach(System.TimeSpan,System.TimeSpan,System.Threading.WaitCallback)">
            <summary>
              Schedules a recurring notification after the specified time span
            </summary>
            <param name="delay">Delay after which the first notification will occur</param>
            <param name="interval">Interval at which the notification will be repeated</param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.NotifyEach(System.Int32,System.Int32,System.Threading.WaitCallback)">
            <summary>
              Schedules a recurring notification after the specified amount of milliseconds
            </summary>
            <param name="delayMilliseconds">
              Milliseconds after which the first notification will occur
            </param>
            <param name="intervalMilliseconds">
              Interval in milliseconds at which the notification will be repeated
            </param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.Cancel(System.Object)">
            <summary>Cancels a scheduled notification</summary>
            <param name="notificationHandle">
              Handle of the notification that will be cancelled
            </param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.dateTimeAdjusted(System.Object,System.EventArgs)">
            <summary>Called when the system date/time have been adjusted</summary>
            <param name="sender">Time source which detected the adjustment</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.scheduleNotification(Nuclex.Support.Scheduling.Scheduler.Notification)">
            <summary>Schedules a notification for processing by the timer thread</summary>
            <param name="notification">Notification that will be scheduled</param>
            <returns>The scheduled notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.runTimerThread">
            <summary>Executes the timer thread</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.getNextDueNotification">
            <summary>Retrieves the notification that is due next</summary>
            <returns>The notification that is due next</returns>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.timeSource">
            <summary>Time source used by the scheduler</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.timerThread">
            <summary>Thread that will wait for the next scheduled event</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.notifications">
            <summary>Notifications in the scheduler's queue</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.notificationWaitEvent">
            <summary>Event used by the timer thread to wait for the next notification</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.endRequested">
            <summary>Whether the timer thread should end</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.dateTimeAdjustedDelegate">
            <summary>Delegate for the dateTimeAdjusted() method</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.CreateTimeSource(System.Boolean)">
            <summary>Creates a new default time source for the scheduler</summary>
            <param name="useWindowsTimeSource">
              Whether the specialized windows time source should be used
            </param>
            <returns>The newly created time source</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.CreateDefaultTimeSource">
            <summary>Creates a new default time source for the scheduler</summary>
            <returns>The newly created time source</returns>
        </member>
        <member name="P:Nuclex.Support.Scheduling.Scheduler.TimeSource">
            <summary>Time source being used by the scheduler</summary>
        </member>
        <member name="P:Nuclex.Support.Scheduling.Scheduler.DefaultTimeSource">
            <summary>Returns the default time source for the scheduler</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.Scheduler.Notification">
            <summary>Scheduled notification</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.Notification.#ctor(System.Int64,System.Int64,System.DateTime,System.Threading.WaitCallback)">
            <summary>Initializes a new notification</summary>
            <param name="intervalTicks">
              Interval in which the notification will re-executed
            </param>
            <param name="nextDueTicks">
              Time source ticks the notification is next due at
            </param>
            <param name="absoluteUtcTime">
              Absolute time in UTC at which the notification is due
            </param>
            <param name="callback">
              Callback to be invoked when the notification is due
            </param>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.Notification.IntervalTicks">
            <summary>
              Ticks specifying the interval in which the notification will be re-executed
            </summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.Notification.NextDueTicks">
            <summary>Next due time for this notification</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.Notification.AbsoluteUtcTime">
            <summary>Absolute time in UTC at which the notification is due</summary>
            <remarks>
              Only stored for notifications scheduled in absolute time, meaning they
              have to be adjusted if the system date/time changes
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.Notification.Callback">
            <summary>Callback that will be invoked when the notification is due</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.Notification.Cancelled">
            <summary>Whether the notification has been cancelled</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.Scheduler.NotificationComparer">
            <summary>Compares two notifications to each other</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.NotificationComparer.Default">
            <summary>The default instance of the notification comparer</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.NotificationComparer.Compare(Nuclex.Support.Scheduling.Scheduler.Notification,Nuclex.Support.Scheduling.Scheduler.Notification)">
            <summary>Compares two notifications to each other based on their time</summary>
            <param name="left">Notification that will be compared on the left side</param>
            <param name="right">Notification that will be comapred on the right side</param>
            <returns>The relation of the two notification's times to each other</returns>
        </member>
        <member name="T:Nuclex.Support.Scheduling.Scheduler.TimeSourceSingleton">
            <summary>
              Manages the singleton instance of the scheduler's default time source
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.TimeSourceSingleton.#cctor">
            <summary>
              Explicit static constructor to guarantee the singleton is initialized only
              when a static member of this class is accessed.
            </summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.TimeSourceSingleton.Instance">
            <summary>The singleton instance of the default time source</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.GenericTimeSource">
            <summary>
              Generic time source implementation using the Stopwatch or Environment.TickCount
            </summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.GenericTimeSource.TicksPerMillisecond">
            <summary>Number of ticks (100 ns intervals) in a millisecond</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.GenericTimeSource.TimeAdjustmentToleranceTicks">
            <summary>Tolerance for the detection of a date/time adjustment</summary>
            <remarks>
              If the current system date/time jumps by more than this tolerance into any
              direction, the default time source will trigger the DateTimeAdjusted event.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSource.#cctor">
            <summary>Initializes the static fields of the default time source</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSource.#ctor">
            <summary>Initializes the default time source</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSource.#ctor(System.Boolean)">
            <summary>Initializes the default time source</summary>
            <param name="useStopwatch">
              Whether to use the Stopwatch class for measuring time
            </param>
            <remarks>
              <para>
                Normally it's a good idea to use the default constructor. If the Stopwatch
                is unable to use the high-resolution timer, it will fall back to
                DateTime.Now (as stated on MSDN). This is bad because then the tick count
                will jump whenever the system time changes (eg. when the system synchronizes
                its time with a time server).
              </para>
              <para>
                Your can safely use this constructor if you always set its arugment to 'false',
                but then your won't profit from the high-resolution timer if one is available.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSource.WaitOne(System.Threading.AutoResetEvent,System.Int64)">
            <summary>Waits for an AutoResetEvent to become signalled</summary>
            <param name="waitHandle">WaitHandle the method will wait for</param>
            <param name="ticks">Number of ticks to wait</param>
            <returns>
              True if the WaitHandle was signalled, false if the timeout was reached
            </returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSource.OnDateTimeAdjusted(System.Object,System.EventArgs)">
            <summary>Called when the system time is changed</summary>
            <param name="sender">Not used</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSource.checkForTimeAdjustment">
            <summary>
              Checks whether the system/date time have been adjusted since the last call
            </summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.GenericTimeSource.lastCheckedDateTimeTicks">
            <summary>Last local time we checked for a date/time adjustment</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.GenericTimeSource.lastCheckedStopwatchTicks">
            <summary>Timer ticks at which we last checked the local time</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.GenericTimeSource.tickFrequency">
            <summary>Number of ticks per Stopwatch time unit</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.GenericTimeSource.useStopwatch">
            <summary>Whether ot use the Stopwatch class for measuring time</summary>
        </member>
        <member name="E:Nuclex.Support.Scheduling.GenericTimeSource.DateTimeAdjusted">
            <summary>Called when the system date/time are adjusted</summary>
            <remarks>
              An adjustment is a change out of the ordinary, eg. when a time synchronization
              alters the current system time, when daylight saving time takes effect or
              when the user manually adjusts the system date/time.
            </remarks>
        </member>
        <member name="P:Nuclex.Support.Scheduling.GenericTimeSource.CurrentUtcTime">
            <summary>Current system time in UTC format</summary>
        </member>
        <member name="P:Nuclex.Support.Scheduling.GenericTimeSource.Ticks">
            <summary>How long the time source has been running</summary>
            <remarks>
              There is no guarantee this value starts at zero (or anywhere near it) when
              the time source is created. The only requirement for this value is that it
              keeps increasing with the passing of time and that it stays unaffected
              (eg. doesn't skip or jump back) when the system date/time are changed.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Scheduling.SchedulerTest">
            <summary>Unit Test for the scheduler</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestCreateWindowsTimeSource">
            <summary>
              Test whether the Scheduler can explicitely create a windows time source
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestCreateGenericTimeSource">
            <summary>
              Test whether the Scheduler can explicitely create a generic time source
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestCreateDefaultTimeSource">
            <summary>
              Test whether the Scheduler can automatically choose the right time source
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestDefaultConstructor">
            <summary>
              Verifies that the default constructor of the scheduler is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestThrowOnNotifyAtWithUnspecifiedDateTimeKind">
            <summary>
              Verifies that the default constructor of the scheduler is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestNotifyAt">
            <summary>
              Tests whether the NotifyAt() method invokes the callback at the right time
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestNotifyAtWithDateTimeAdjustment">
            <summary>
              Verifies that a notification at an absolute time is processed correctly
              if a time synchronization occurs during the wait.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestCancelNotification">
            <summary>Tests whether the scheduler's Cancel() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestInverseOrderNotification">
            <summary>
              Tests the scheduler with two notifications that are scheduled in inverse
              order of their due time.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestTwoNotificationsAtSameTime">
            <summary>
              Tests the scheduler with two notifications that are scheduled to
              occur at the exact same time
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestNotifyEachWithMilliseconds">
            <summary>
              Verifies that the scheduler's NotifyEach() method is working correctly
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestNotifyEachWithTimespan">
            <summary>
              Verifies that the scheduler's NotifyEach() method is working correctly
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestCancelFinalNotification">
            <summary>
              Reproduction case for a bug that occurred when the final notification in
              the scheduler was cancelled (call to PriorityQueue.Peek() on empty queue)
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.makeUtc(System.DateTime)">
            <summary>Returns the provided date/time value as a utc time value</summary>
            <param name="dateTime">Date/time value that will be returned as UTC</param>
            <returns>The provided date/time value as UTC</returns>
            <remarks>
              This doesn't convert the time, it just returns the exact same date and time
              but tags it as UTC by setting the DateTimeKind to UTC.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Scheduling.SchedulerTest.MockTimeSource">
            <summary>Mocked time source</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.MockTimeSource.#ctor(System.DateTime)">
            <summary>Initializes a new mocked time source</summary>
            <param name="utcStartTime">Start time in UTC format</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.MockTimeSource.WaitOne(System.Threading.AutoResetEvent,System.Int64)">
            <summary>Waits for an AutoResetEvent to become signalled</summary>
            <param name="waitHandle">WaitHandle the method will wait for</param>
            <param name="ticks">Number of ticks to wait</param>
            <returns>
              True if the WaitHandle was signalled, false if the timeout was reached
              or the time source thinks its time to recheck the system date/time.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.MockTimeSource.AdvanceTime(System.TimeSpan)">
            <summary>Advances the time of the time source</summary>
            <param name="timeSpan">
              Time span by which to advance the time source's time
            </param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.MockTimeSource.AdjustTime(System.DateTime)">
            <summary>Manually triggers the date time adjusted event</summary>
            <param name="newUtcTime">New simulation time to jump to</param>
        </member>
        <member name="F:Nuclex.Support.Scheduling.SchedulerTest.MockTimeSource.autoResetEvent">
            <summary>Auto reset event the time source is currently waiting on</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.SchedulerTest.MockTimeSource.eventDueTicks">
            <summary>Ticks at which the auto reset event will be due</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.SchedulerTest.MockTimeSource.currentTicks">
            <summary>Current time source tick counter</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.SchedulerTest.MockTimeSource.currentTime">
            <summary>Current system time and date</summary>
        </member>
        <member name="E:Nuclex.Support.Scheduling.SchedulerTest.MockTimeSource.DateTimeAdjusted">
            <summary>Called when the system date/time are adjusted</summary>
        </member>
        <member name="P:Nuclex.Support.Scheduling.SchedulerTest.MockTimeSource.CurrentUtcTime">
            <summary>Current system time in UTC format</summary>
        </member>
        <member name="P:Nuclex.Support.Scheduling.SchedulerTest.MockTimeSource.Ticks">
            <summary>How long the time source has been running</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.SchedulerTest.TestSubscriber">
            <summary>Subscriber used to test the scheduler notifications</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestSubscriber.#ctor">
            <summary>Initializes a new test subscriber</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestSubscriber.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestSubscriber.Callback(System.Object)">
            <summary>Callback method that can be subscribed to the scheduler</summary>
            <param name="state">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.SchedulerTest.TestSubscriber.WaitForCallback(System.Int32)">
            <summary>Blocks ther caller until the callback is invoked</summary>
            <param name="milliseconds">
              Maximum number of milliseconds to wait for the callback
            </param>
            <returns>True if the callback was invoked, false if the call timed out</returns>
        </member>
        <member name="F:Nuclex.Support.Scheduling.SchedulerTest.TestSubscriber.callbackCount">
            <summary>Callback invocation count</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.SchedulerTest.TestSubscriber.waitHandle">
            <summary>WaitHandle used to wait for the callback</summary>
        </member>
        <member name="P:Nuclex.Support.Scheduling.SchedulerTest.TestSubscriber.CallbackCount">
            <summary>Number of times the callback has been invoked</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.WindowsTimeSource">
            <summary>
              Time source that makes use of additional features only available on Windows
            </summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.WindowsTimeSource.TicksPerMillisecond">
            <summary>Number of ticks (100 ns intervals) in a millisecond</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSource.#ctor">
            <summary>Initializes a new Windows time source</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSource.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSource.WaitOne(System.Threading.AutoResetEvent,System.Int64)">
            <summary>Waits for an AutoResetEvent to become signalled</summary>
            <param name="waitHandle">WaitHandle the method will wait for</param>
            <param name="ticks">Number of ticks to wait</param>
            <returns>
              True if the WaitHandle was signalled, false if the timeout was reached
            </returns>
        </member>
        <member name="F:Nuclex.Support.Scheduling.WindowsTimeSource.onDateTimeAdjustedDelegate">
            <summary>Delegate for the timeChanged() callback method</summary>
        </member>
        <member name="P:Nuclex.Support.Scheduling.WindowsTimeSource.Available">
            <summary>
              Whether the Windows time source can be used on the current platform
            </summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.WindowsTimeSourceTest">
            <summary>Unit Test for the windows time source</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSourceTest.TestDefaultConstructor">
            <summary>
              Verifies that the time source's default constructor is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSourceTest.TestCurrentUtcTime">
            <summary>
              Verifies that the time source can provide the current UTC time
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSourceTest.TestTicks">
            <summary>
              Verifies that the time source's tick property is working if
              the Stopwatch class is used to measure time
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSourceTest.TestWaitOne">
            <summary>
              Verifies that the time source's WaitOne() method works correctly
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSourceTest.TestTimeChange">
            <summary>
              Verifies that the default time source's WaitOne() method works correctly
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSourceTest.TestAvailability">
            <summary>
              Tests whether the Windows-specific time source can reports its availability on
              the current platform
            </summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.WindowsTimeSourceTest.TestWindowsTimeSource">
            <summary>Windows time source used for testing</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSourceTest.TestWindowsTimeSource.ForceTimeChange">
            <summary>
              Forces a time change notification even if the system time was not adjusted
            </summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.WindowsTimeSourceTest.TestTimeChangedSubscriber">
            <summary>Dummy subscriber used to test the time changed event</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSourceTest.TestTimeChangedSubscriber.TimeChanged(System.Object,System.EventArgs)">
            <summary>Callback subscribed to the TimeChanged event</summary>
            <param name="sender">Not used</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="F:Nuclex.Support.Scheduling.WindowsTimeSourceTest.TestTimeChangedSubscriber.CallCount">
            <summary>Number of times the callback was invoked</summary>
        </member>
        <member name="T:Nuclex.Support.Semaphore">
            <summary>A reverse counting semaphore</summary>
            <remarks>
              <para>
                This semaphore counts in reverse, which means you can Release() the semaphore
                as often as you'd like a thread calling WaitOne() to be let through. You
                can use it in the traditional sense and have any Thread calling WaitOne()
                make sure to call Release() afterwards, or you can, for example, Release() it
                whenever work becomes available and let threads take work from the Semaphore
                by calling WaitOne() alone.
              </para>
              <para>
                Implementation notes (ignore this if you just want to use the Semaphore)
              </para>
              <para>
                We could design a semaphore that uses an auto reset event, where the thread
                that gets to pass immediately sets the event again if the semaphore isn't full
                yet to let another thread pass.
              </para>
              <para>
                However, this would mean that when a semaphore receives a large number of
                wait requests, assuming it would allow, for example, 25 users at once, the
                thread scheduler would see only 1 thread become eligible for execution. Then
                that thread would unlock the next and so on. In short, we wait 25 times
                for the thread scheduler to wake up a thread until all users get through.
              </para>
              <para>
                So we chose a ManualResetEvent, which will wake up more threads than
                neccessary and possibly cause a period of intense competition for getting
                a lock on the resource, but will make the thread scheduler see all threads
                become eligible for execution.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Semaphore.#ctor">
            <summary>Initializes a new semaphore</summary>
        </member>
        <member name="M:Nuclex.Support.Semaphore.#ctor(System.Int32)">
            <summary>Initializes a new semaphore</summary>
            <param name="count">
              Number of users that can access the resource at the same time
            </param>
        </member>
        <member name="M:Nuclex.Support.Semaphore.#ctor(System.Int32,System.Int32)">
            <summary>Initializes a new semaphore</summary>
            <param name="initialCount">
              Initial number of users accessing the resource 
            </param>
            <param name="maximumCount">
              Maximum numbr of users that can access the resource at the same time
            </param>
        </member>
        <member name="M:Nuclex.Support.Semaphore.Dispose(System.Boolean)">
            <summary>Immediately releases all resources owned by the instance</summary>
            <param name="explicitDisposing">
              Whether Dispose() has been called explictly
            </param>
        </member>
        <member name="M:Nuclex.Support.Semaphore.WaitOne(System.Int32,System.Boolean)">
            <summary>
              Waits for the resource to become available and locks it
            </summary>
            <param name="millisecondsTimeout">
              Number of milliseconds to wait at most before giving up
            </param>
            <param name="exitContext">
              True to exit the synchronization domain for the context before the wait (if
              in a synchronized context), and reacquire it afterward; otherwise, false.
            </param>
            <returns>
              True if the resource was available and is now locked, false if
              the timeout has been reached.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Semaphore.WaitOne">
            <summary>
              Waits for the resource to become available and locks it
            </summary>
            <returns>
              True if the resource was available and is now locked, false if
              the timeout has been reached.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Semaphore.WaitOne(System.TimeSpan,System.Boolean)">
            <summary>
              Waits for the resource to become available and locks it
            </summary>
            <param name="timeout">
              Time span to wait for the lock before giving up
            </param>
            <param name="exitContext">
              True to exit the synchronization domain for the context before the wait (if
              in a synchronized context), and reacquire it afterward; otherwise, false.
            </param>
            <returns>
              True if the resource was available and is now locked, false if
              the timeout has been reached.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Semaphore.Release">
            <summary>
              Releases a lock on the resource. Note that for a reverse counting semaphore,
              it is legal to Release() the resource before locking it.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Semaphore.createEvent">
            <summary>Creates the event used to make threads wait for the resource</summary>
        </member>
        <member name="F:Nuclex.Support.Semaphore.manualResetEvent">
            <summary>Event used to make threads wait if the semaphore is full</summary>
        </member>
        <member name="F:Nuclex.Support.Semaphore.free">
            <summary>Number of users currently accessing the resource</summary>
            <remarks>
              Since this is a reverse counting semaphore, it will be negative if
              the resource is available and 0 if the semaphore is full.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.SemaphoreTest">
            <summary>Unit Test for the Semaphore class</summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestReverseCountingConstructor">
            <summary>
              Test whether a semaphore can be initialized with reverse counting
            </summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestLimitConstructor">
            <summary>
              Test whether a semaphore can be initialized with a maximum user count
            </summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestFullConstructor">
            <summary>
              Test whether a semaphore can be initialized with an initial user
              count and a maximum user count
            </summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestThrowOnMoreInitialUsersThanMaximumUsers">
            <summary>
              Verifies that the right exception is thrown if a semaphore is initialized
              with a larger number of initial users than the maximum number of users.
            </summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestWaitTimeout">
            <summary>
              Verifies that the semaphore can time out if the resource does not become
              available within the time limit specified by the user
            </summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestWaitTimeoutWithTimeSpan">
            <summary>
              Verifies that the semaphore can time out if the resource does not become
              available within the time limit specified by the user, if the time limit
              is specified using the TimeSpan class
            </summary>
        </member>
        <member name="M:Nuclex.Support.SemaphoreTest.TestThrowOnWaitWithTooLargeTimeSpan">
            <summary>
              Tests whether an exception is thrown if the WaitOne() method is called
              with a time span that is too large for the underlying synchronization API
            </summary>
        </member>
        <member name="T:Nuclex.Support.IO.PartialStream">
            <summary>Wraps a stream and exposes only a limited region of its data</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.#ctor(System.IO.Stream,System.Int64,System.Int64)">
            <summary>Initializes a new partial stream</summary>
            <param name="stream">
              Stream the wrapper will make a limited region accessible of
            </param>
            <param name="start">
              Start index in the stream which becomes the beginning for the wrapper
            </param>
            <param name="length">
              Length the wrapped stream should report and allow access to
            </param>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.Flush">
            <summary>
              Clears all buffers for this stream and causes any buffered data to be written
              to the underlying device.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Reads a sequence of bytes from the stream and advances the position of
              the file pointer by the number of bytes read.
            </summary>
            <param name="buffer">Buffer that will receive the data read from the stream</param>
            <param name="offset">
              Offset in the buffer at which the stream will place the data read
            </param>
            <param name="count">Maximum number of bytes that will be read</param>
            <returns>
              The number of bytes that were actually read from the stream and written into
              the provided buffer
            </returns>
            <exception cref="T:System.NotSupportedException">
              The wrapped stream does not support reading
            </exception>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Changes the position of the file pointer</summary>
            <param name="offset">
              Offset to move the file pointer by, relative to the position indicated by
              the <paramref name="origin" /> parameter.
            </param>
            <param name="origin">
              Reference point relative to which the file pointer is placed
            </param>
            <returns>The new absolute position within the stream</returns>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.SetLength(System.Int64)">
            <summary>Changes the length of the stream</summary>
            <param name="value">New length the stream shall have</param>
            <exception cref="T:System.NotSupportedException">
              Always, the stream chainer does not support the SetLength() operation
            </exception>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Writes a sequence of bytes to the stream and advances the position of
              the file pointer by the number of bytes written.
            </summary>
            <param name="buffer">
              Buffer containing the data that will be written to the stream
            </param>
            <param name="offset">
              Offset in the buffer at which the data to be written starts
            </param>
            <param name="count">Number of bytes that will be written into the stream</param>
            <remarks>
              The behavior of this method is as follows: If one or more chained streams
              do not support seeking, all data is appended to the final stream in the
              chain. Otherwise, writing will begin with the stream the current file pointer
              offset falls into. If the end of that stream is reached, writing continues
              in the next stream. On the last stream, writing more data into the stream
              that it current size allows will enlarge the stream.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.moveFilePointer(System.Int64)">
            <summary>Moves the file pointer</summary>
            <param name="position">New position the file pointer will be moved to</param>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.makeSeekNotSupportedException(System.String)">
            <summary>
              Constructs a NotSupportException for an error caused by the wrapped
              stream having no seek support
            </summary>
            <param name="action">Action that was tried to perform</param>
            <returns>The newly constructed NotSupportedException</returns>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStream.stream">
            <summary>Streams that have been chained together</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStream.start">
            <summary>Start index of the partial stream in the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStream.position">
            <summary>Zero-based position of the partial stream's file pointer</summary>
            <remarks>
              If the stream does not support seeking, the position will simply be counted
              up until it reaches <see cref="F:Nuclex.Support.IO.PartialStream.length"/>.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStream.length">
            <summary>Length of the partial stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.CanRead">
            <summary>Whether data can be read from the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.CanSeek">
            <summary>Whether the stream supports seeking</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.CanWrite">
            <summary>Whether data can be written into the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.Length">
            <summary>Length of the stream in bytes</summary>
            <exception cref="T:System.NotSupportedException">
              The wrapped stream does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.Position">
            <summary>Absolute position of the file pointer within the stream</summary>
            <exception cref="T:System.NotSupportedException">
              The wrapped stream does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.CompleteStream">
            <summary>Stream being wrapped by the partial stream wrapper</summary>
        </member>
        <member name="T:Nuclex.Support.IO.PartialStreamTest">
            <summary>Unit Test for the partial stream</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestConstructor">
            <summary>Tests whether the partial stream constructor is working</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnInvalidStartInConstructor">
            <summary>
              Verifies that the partial stream constructor throws an exception if
              it's invoked with an invalid start offset
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnInvalidLengthInConstructor">
            <summary>
              Verifies that the partial stream constructor throws an exception if
              it's invoked with an invalid start offset
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnUnseekableStreamWithOffsetInConstructor">
            <summary>
              Verifies that the partial stream constructor throws an exception if
              it's invoked with a start offset on an unseekable stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestCanReadProperty">
            <summary>
              Tests whether the CanRead property reports its status correctly
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestCanWriteProperty">
            <summary>
              Tests whether the CanWrite property reports its status correctly
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestCanSeekProperty">
            <summary>
              Tests whether the CanSeek property reports its status correctly
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestCompleteStreamProperty">
            <summary>
              Tests whether the CompleteStream property returns the original stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestFlush">
            <summary>Tests whether the Flush() method can be called</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestGetPosition">
            <summary>
              Tests whether the Position property correctly reports the file pointer position
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestSetPosition">
            <summary>
              Tests whether the Position property is correctly updated
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnGetPositionOnUnseekableStream">
            <summary>
              Tests whether the Position property throws an exception if the stream does
              not support seeking.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnSetPositionOnUnseekableStream">
            <summary>
              Tests whether the Position property throws an exception if the stream does
              not support seeking.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnReadFromUnreadableStream">
            <summary>
              Tests whether the Read() method throws an exception if the stream does
              not support reading
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestSeeking">
            <summary>
              Tests whether the Seek() method of the partial stream is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnInvalidSeekReferencePoint">
            <summary>
              Tests whether the Seek() method throws an exception if an invalid
              reference point is provided
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnLengthChange">
            <summary>
              Verifies that the partial stream throws an exception if the attempt is
              made to change the length of the stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestReadFromInvalidPosition">
            <summary>
              Tests whether the Read() method returns 0 bytes if the attempt is made
              to read data from an invalid position
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestReadFromPartialStream">
            <summary>Verifies that the Read() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestWriteToPartialStream">
            <summary>Verifies that the Write() method is working</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestThrowOnExtendPartialStream">
            <summary>
              Verifies that an exception is thrown if the Write() method of the partial stream
              is attempted to be used to extend the partial stream's length
            </summary>
        </member>
        <member name="T:Nuclex.Support.IO.PartialStreamTest.TestStream">
            <summary>Testing stream that allows specific features to be disabled</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.#ctor(System.IO.Stream,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Initializes a new test stream</summary>
            <param name="wrappedStream">Stream that will be wrapped</param>
            <param name="allowRead">Whether to allow reading from the stream</param>
            <param name="allowWrite">Whether to allow writing to the stream</param>
            <param name="allowSeek">Whether to allow seeking within the stream</param>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.Flush">
            <summary>
              Clears all buffers for this stream and causes any buffered data to be written
              to the underlying device.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Reads a sequence of bytes from the stream and advances the position of
              the file pointer by the number of bytes read.
            </summary>
            <param name="buffer">Buffer that will receive the data read from the stream</param>
            <param name="offset">
              Offset in the buffer at which the stream will place the data read
            </param>
            <param name="count">Maximum number of bytes that will be read</param>
            <returns>
              The number of bytes that were actually read from the stream and written into
              the provided buffer
            </returns>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Changes the position of the file pointer</summary>
            <param name="offset">
              Offset to move the file pointer by, relative to the position indicated by
              the <paramref name="origin" /> parameter.
            </param>
            <param name="origin">
              Reference point relative to which the file pointer is placed
            </param>
            <returns>The new absolute position within the stream</returns>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.SetLength(System.Int64)">
            <summary>Changes the length of the stream</summary>
            <param name="value">New length the stream shall have</param>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Writes a sequence of bytes to the stream and advances the position of
              the file pointer by the number of bytes written.
            </summary>
            <param name="buffer">
              Buffer containing the data that will be written to the stream
            </param>
            <param name="offset">
              Offset in the buffer at which the data to be written starts
            </param>
            <param name="count">Number of bytes that will be written into the stream</param>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.enforceReadAllowed">
            <summary>Throws an exception if reading is not allowed</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.enforceWriteAllowed">
            <summary>Throws an exception if writing is not allowed</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStreamTest.TestStream.enforceSeekAllowed">
            <summary>Throws an exception if seeking is not allowed</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStreamTest.TestStream.stream">
            <summary>Stream being wrapped for testing</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStreamTest.TestStream.readAllowed">
            <summary>whether to allow reading from the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStreamTest.TestStream.writeAllowed">
            <summary>Whether to allow writing to the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStreamTest.TestStream.seekAllowed">
            <summary>Whether to allow seeking within the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStreamTest.TestStream.flushCallCount">
            <summary>Number of times the Flush() method has been called</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStreamTest.TestStream.CanRead">
            <summary>Whether data can be read from the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStreamTest.TestStream.CanSeek">
            <summary>Whether the stream supports seeking</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStreamTest.TestStream.CanWrite">
            <summary>Whether data can be written into the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStreamTest.TestStream.Length">
            <summary>Length of the stream in bytes</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStreamTest.TestStream.Position">
            <summary>Absolute position of the file pointer within the stream</summary>
            <exception cref="T:System.NotSupportedException">
              At least one of the chained streams does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStreamTest.TestStream.FlushCallCount">
            <summary>Number of times the Flush() method has been called</summary>
        </member>
        <member name="T:Nuclex.Support.IO.RingMemoryStream">
            <summary>Specialized memory stream for ring buffers</summary>
            <remarks>
              This ring buffer class is specialized for binary data and tries to achieve
              optimal efficiency when storing and retrieving chunks of several bytes
              at once. Typical use cases include audio and network buffers where one party
              is responsible for refilling the buffer at regular intervals while the other
              constantly streams data out of it.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.#ctor(System.Int32)">
            <summary>Initializes a new ring memory stream</summary>
            <param name="capacity">Maximum capacity of the stream</param>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.Flush">
            <summary>Flushes the buffers and writes down unsaved data</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>Reads data from the beginning of the stream</summary>
            <param name="buffer">Buffer in which to store the data</param>
            <param name="offset">Starting index at which to begin writing the buffer</param>
            <param name="count">Number of bytes to read from the stream</param>
            <returns>Die Number of bytes actually read</returns>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>Appends data to the end of the stream</summary>
            <param name="buffer">Buffer containing the data to append</param>
            <param name="offset">Starting index of the data in the buffer</param>
            <param name="count">Number of bytes to write to the stream</param>
            <exception cref="T:System.OverflowException">When the ring buffer is full</exception>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Jumps to the specified location within the stream</summary>
            <param name="offset">Position to jump to</param>
            <param name="origin">Origin towards which to interpret the offset</param>
            <returns>The new offset within the stream</returns>
            <exception cref="T:System.NotSupportedException">Always</exception>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.SetLength(System.Int64)">
            <summary>Changes the length of the stream</summary>
            <param name="value">New length to resize the stream to</param>
            <exception cref="T:System.NotSupportedException">Always</exception>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.setEmpty">
            <summary>Resets the stream to its empty state</summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStream.ringBuffer">
            <summary>Internal stream containing the ring buffer data</summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStream.startIndex">
            <summary>Start index of the data within the ring buffer</summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStream.endIndex">
            <summary>End index of the data within the ring buffer</summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStream.empty">
            <summary>Whether the ring buffer is empty</summary>
            <remarks>
              This field is required to differentiate between the ring buffer being
              filled to the limit and being totally empty, because in both cases,
              the start index and the end index will be the same. 
            </remarks>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.Capacity">
            <summary>Maximum amount of data that will fit into the ring memory stream</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Thrown if the new capacity is too small for the data already contained
              in the ring buffer.
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.CanRead">
            <summary>Whether it's possible to read from this stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.CanSeek">
            <summary>Whether this stream supports random access</summary>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.CanWrite">
            <summary>Whether it's possible to write into this stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.Length">
            <summary>Current length of the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.Position">
            <summary>Current cursor position within the stream</summary>
            <exception cref="T:System.NotSupportedException">Always</exception>
        </member>
        <member name="T:Nuclex.Support.IO.RingMemoryStreamTest">
            <summary>Unit Test for the ring buffer class</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.Setup">
            <summary>Prepares some test data for the units test methods</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestWriteTooLargeChunk">
            <summary>
              Ensures that the ring buffer blocks write attempts that would exceed its capacity
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestWriteBarelyFittingChunk">
            <summary>
              Ensures that the ring buffer still accepts write attempts that would fill the
              entire buffer in one go.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestWriteSplitBlock">
            <summary>
              Ensures that the ring buffer correctly manages write attempts that have to
              be split at the end of the ring buffer
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestWriteSplitAndLinearBlock">
            <summary>
              Ensures that the ring buffer correctly manages write attempts that write into
              the gap after the ring buffer's data has become split
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestWriteSplitAndLinearTooLargeBlock">
            <summary>
              Ensures that the ring buffer still detects write that would exceed its capacity
              if they write into the gap after the ring buffer's data has become split
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestSplitBlockWrappedRead">
            <summary>Tests whether the ring buffer correctly handles fragmentation</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestSplitBlockLinearRead">
            <summary>Tests whether the ring buffer correctly handles fragmentation</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestEndOfStream">
            <summary>
              Tests whether the ring buffer correctly returns partial data if more
              data is requested than is contained in it.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCapacityIncrease">
            <summary>
              Validates that the ring buffer can extend its capacity without loosing data
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCapacityDecrease">
            <summary>
              Validates that the ring buffer can reduce its capacity without loosing data
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCapacityDecreaseException">
            <summary>
              Checks that an exception is thrown when the ring buffer's capacity is
              reduced so much it would have to give up some of its contained data
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCapacity">
            <summary>Tests whether the Capacity property returns the current capacity</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCanRead">
            <summary>Ensures that the CanRead property returns true</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCanSeek">
            <summary>Ensures that the CanSeek property returns false</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestCanWrite">
            <summary>Ensures that the CanWrite property returns true</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestAutoReset">
            <summary>
              Tests whether the auto reset feature works (resets the buffer pointer to the
              left end of the buffer when it gets empty; mainly a performance feature).
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestThrowOnRetrievePosition">
            <summary>
              Verifies that an exception is thrown when the Position property of the ring
              memory stream is used to retrieve the current file pointer position
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestThrowOnAssignPosition">
            <summary>
              Verifies that an exception is thrown when the Position property of the ring
              memory stream is used to modify the current file pointer position
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestThrowOnSeek">
            <summary>
              Verifies that an exception is thrown when the Seek() method of the ring memory
              stream is attempted to be used
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestThrowOnSetLength">
            <summary>
              Verifies that an exception is thrown when the SetLength() method of the ring
              memory stream is attempted to be used
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestFlush">
            <summary>
              Tests the Flush() method of the ring memory stream, which is either a dummy
              implementation or has no side effects
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestLengthOnLinearBlock">
            <summary>
              Tests whether the length property is updated in accordance to the data written
              into the ring memory stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStreamTest.TestLengthOnSplitBlock">
            <summary>
              Tests whether the length property is updated in accordance to the data written
              into the ring memory stream when the data is split within the stream
            </summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStreamTest.testBytes">
            <summary>Test data for the ring buffer unit tests</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.TransformingReadOnlyCollection`2">
            <summary>Collection that transforms the contents of another collection.</summary>
            <typeparam name="ContainedItemType">
              Type of the items contained in the wrapped collection.
            </typeparam>
            <typeparam name="ExposedItemType">
              Type this collection exposes its items as.
            </typeparam>
            <remarks>
              <para>
                This collection is useful if you want to expose the objects of an arbitrary
                collection under a different type. It can be used, for example, to construct
                wrappers for the items in a collection on-the-fly, eliminating the need to
                manage the wrappers in parallel to the real items and improving performance
                by only constructing a wrapper when an item is actually requested.
              </para>
              <para>
                Another common use would be if you have a private collection of a non-public
                type that's derived from some publicly visible type. By using this collection,
                you can return the items under the publicly visible type while still having
                your private collection under the non-public type, eliminating the need to
                downcast each time you need to access elements of the non-public type.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new transforming collection wrapper</summary>
            <param name="items">
              Internal list of items that are transformed into the exposed type when
              accessed through the TransformingReadOnlyCollection.
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.Contains(`1)">
            <summary>
              Determines whether an element is in the TransformingReadOnlyCollection
            </summary>
            <param name="item">
              The object to locate in the TransformingReadOnlyCollection.
              The value can be null for reference types.
            </param>
            <returns>
              True if value is found in the TransformingReadOnlyCollection; otherwise, false.
            </returns>
            <remarks>
              The default implementation of this method is very unoptimized and will
              enumerate all the items in the collection, transforming one after another
              to check whether the transformed item matches the item the user was
              looking for. It is recommended to provide a custom implementation of
              this method, if possible.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.CopyTo(`1[],System.Int32)">
            <summary>
              Copies the entire TransformingReadOnlyCollection to a compatible one-dimensional
              System.Array, starting at the specified index of the target array.
            </summary>
            <param name="array">
              The one-dimensional System.Array that is the destination of the elements copied
              from the TransformingReadOnlyCollection. The System.Array must have
              zero-based indexing.
            </param>
            <param name="index">
              The zero-based index in array at which copying begins.
            </param>
            <exception cref="T:System.ArgumentException">
              Index is equal to or greater than the length of array or the number of elements
              in the source TransformingReadOnlyCollection is greater than the available space
              from index to the end of the destination array.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is less than zero.
            </exception>
            <exception cref="T:System.ArgumentNullException">
              Array is null.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.GetEnumerator">
            <summary>
              Returns an enumerator that iterates through the TransformingReadOnlyCollection.
            </summary>
            <returns>
              An enumerator or the TransformingReadOnlyCollection.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.IndexOf(`1)">
            <summary>
              Searches for the specified object and returns the zero-based index of the
              first occurrence within the entire TransformingReadOnlyCollection.
            </summary>
            <param name="item">
              The object to locate in the TransformingReadOnlyCollection. The value can
              be null for reference types.
            </param>
            <returns>
              The zero-based index of the first occurrence of item within the entire
              TransformingReadOnlyCollection, if found; otherwise, -1.
            </returns>
            <remarks>
              The default implementation of this method is very unoptimized and will
              enumerate all the items in the collection, transforming one after another
              to check whether the transformed item matches the item the user was
              looking for. It is recommended to provide a custom implementation of
              this method, if possible.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.Transform(`0)">
            <summary>Transforms an item into the exposed type</summary>
            <param name="item">Item to be transformed</param>
            <returns>The transformed item</returns>
            <remarks>
              This method is used to transform an item in the wrapped collection into
              the exposed item type whenever the user accesses an item. Expect it to
              be called frequently, because the TransformingReadOnlyCollection does
              not cache or otherwise store the transformed items.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.items">
            <summary>Items being transformed upon exposure by this collection</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.syncRoot">
            <summary>Synchronization root for threaded accesses to this collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#IList{ExposedItemType}#Insert(System.Int32,`1)">
            <summary>
              Inserts an item to the TransformingReadOnlyCollection at the specified index.
            </summary>
            <param name="index">
              The zero-based index at which item should be inserted.
            </param>
            <param name="item">
              The object to insert into the TransformingReadOnlyCollection
            </param>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#IList{ExposedItemType}#RemoveAt(System.Int32)">
            <summary>
              Removes the TransformingReadOnlyCollection item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#ICollection{ExposedItemType}#Add(`1)">
            <summary>Adds an item to the TransformingReadOnlyCollection.</summary>
            <param name="item">The object to add to the TransformingReadOnlyCollection</param>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#ICollection{ExposedItemType}#Clear">
            <summary>Removes all items from the TransformingReadOnlyCollection</summary>
            <exception cref="T:System.NotSupportedException">
               The TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#ICollection{ExposedItemType}#Remove(`1)">
            <summary>
              Removes the first occurrence of a specific object from the
              TransformingReadOnlyCollection.
            </summary>
            <param name="item">
              The object to remove from the TransformingReadOnlyCollection
            </param>
            <returns>
              True if item was successfully removed from the TransformingReadOnlyCollection;
              otherwise, false. This method also returns false if item is not found in the
              original TransformingReadOnlyCollection.
            </returns>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>
              A System.Collections.IEnumerator object that can be used to iterate through
              the collection.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the TransformingReadOnlyCollection.</summary>
            <param name="value">
              The System.Object to add to the TransformingReadOnlyCollection.
            </param>
            <returns>The position into which the new element was inserted.</returns>
            <exception cref="T:System.NotSupportedException">
              The System.Collections.IList is read-only or the TransformingReadOnlyCollection
              has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Clear">
            <summary>Removes all items from the TransformingReadOnlyCollection.</summary>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Contains(System.Object)">
            <summary>
              Determines whether the TransformingReadOnlyCollection contains a specific value.
            </summary>
            <param name="value">
              The System.Object to locate in the TransformingReadOnlyCollection.
            </param>
            <returns>
              True if the System.Object is found in the TransformingReadOnlyCollection;
              otherwise, false.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#IndexOf(System.Object)">
            <summary>
              Determines the index of a specific item in the TransformingReadOnlyCollection.
            </summary>
            <param name="value">
              The System.Object to locate in the TransformingReadOnlyCollection.
            </param>
            <returns>
              The index of value if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
              Inserts an item to the TransformingReadOnlyCollection at the specified index.
            </summary>
            <param name="index">
              The zero-based index at which value should be inserted.
            </param>
            <param name="value">
              The System.Object to insert into the TransformingReadOnlyCollection.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
            <exception cref="T:System.NotSupportedException">
              The System.Collections.IList is read-only or the TransformingReadOnlyCollection
              has a fixed size.
            </exception>
            <exception cref="T:System.NullReferenceException">
              Value is null reference in the TransformingReadOnlyCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Remove(System.Object)">
            <summary>
              Removes the first occurrence of a specific object from the
              TransformingReadOnlyCollection.
            </summary>
            <param name="value">
              The System.Object to remove from the TransformingReadOnlyCollection.
            </param>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only or the
              TransformingReadOnlyCollection has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>
              Removes the TransformingReadOnlyCollection item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only or the
              TransformingReadOnlyCollection has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
              Copies the elements of the TransformingReadOnlyCollection to an System.Array,
              starting at a particular System.Array index.
            </summary>
            <param name="array">
              The one-dimensional System.Array that is the destination of the elements
              copied from TransformingReadOnlyCollection. The System.Array must have zero-based
              indexing.
            </param>
            <param name="index">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
              Array is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is less than zero.
            </exception>
            <exception cref="T:System.ArgumentException">
              Array is multidimensional or index is equal to or greater than the length
              of array or the number of elements in the source TransformingReadOnlyCollection
              is greater than the available space from index to the end of the destination
              array.
            </exception>
            <exception cref="T:System.InvalidCastException">
              The type of the source TransformingReadOnlyCollection cannot be cast
              automatically to the type of the destination array.
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.Count">
            <summary>
              The number of elements contained in the TransformingReadOnlyCollection instance
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.Item(System.Int32)">
            <summary>Gets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
               Index is less than zero or index is equal to or greater than
               TransformingReadOnlyCollection.Count.
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.IsReadOnly">
            <summary>Whether the List is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#IList{ExposedItemType}#Item(System.Int32)">
            <summary>Gets or sets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
            <exception cref="T:System.NotSupportedException">
              The property is set and the TransformingReadOnlyCollection is read-only
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#IsFixedSize">
            <summary>
              A value indicating whether the TransformingReadOnlyCollection has a fixed
              size.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Item(System.Int32)">
            <summary>Gets or sets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection
            </exception>
            <exception cref="T:System.NotSupportedException">
              The property is set and the TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#ICollection#Count">
            <summary>
              The number of elements contained in the TransformingReadOnlyCollection.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#ICollection#IsSynchronized">
            <summary>
              A value indicating whether access to the TransformingReadOnlyCollection
              is synchronized (thread safe).
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#ICollection#SyncRoot">
            <summary>
              An object that can be used to synchronize access to the
              TransformingReadOnlyCollection.
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator">
            <summary>
              An enumerator that transforms the items returned by an enumerator of the
              wrapped collection into the exposed type on-the-fly.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.#ctor(Nuclex.Support.Collections.TransformingReadOnlyCollection{`0,`1},System.Collections.Generic.IEnumerator{`0})">
            <summary>Initializes a new transforming enumerator</summary>
            <param name="transformer">Owner; used to invoke the Transform() method</param>
            <param name="containedTypeEnumerator">Enumerator of the wrapped collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.Dispose">
            <summary>Immediately releases all resources used by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.MoveNext">
            <summary>Gets the current element in the collection.</summary>
            <returns>The current element in the collection.</returns>
            <exception cref="T:System.InvalidOperationException">
              The enumerator is positioned before the first element of the collection
              or after the last element.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.Reset">
            <summary>
              Sets the enumerator to its initial position, which is before the first element
              in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
              The collection was modified after the enumerator was created.
            </exception>
        </member>
        <member name="F:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.transformer">
            <summary>
              Collection that owns this enumerator; required to invoke the item
              transformation method.
            </summary>
        </member>
        <member name="F:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.containedTypeEnumerator">
            <summary>An enumerator from the wrapped collection</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.Current">
            <summary>
              The element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.System#Collections#IEnumerator#Current">
            <summary>The current element in the collection.</summary>
            <exception cref="T:System.InvalidOperationException">
              The enumerator is positioned before the first element of the collection
              or after the last element.
            </exception>
        </member>
        <member name="T:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest">
            <summary>Unit Test for the transforming read only collection wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestCopyConstructor">
            <summary>
              Verifies that the copy constructor of the transforming read only collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestIsReadOnly">
            <summary>Verifies that the IsReadOnly property returns true</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestCopyToArray">
            <summary>
              Verifies that the CopyTo() method of the transforming read only collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnCopyToTooSmallArray">
            <summary>
              Verifies that the CopyTo() method of the transforming read only collection throws
              an exception if the target array is too small to hold the collection's contents
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestContains">
            <summary>
              Checks whether the Contains() method of the transforming read only collection
              is able to determine if the collection contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestIndexOf">
            <summary>
              Checks whether the IndexOf() method of the transforming read only collection
              is able to determine if the index of an item in the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestIndexOfWithNullItemNotContained">
            <summary>
              Checks whether the IndexOf() method of the transforming read only collection
              can cope with queries for 'null' when no 'null' item is contained on it
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestIndexOfWithNullItemContained">
            <summary>
              Checks whether the IndexOf() method of the transforming read only collection
              can cope with queries for 'null' when a 'null' item is contained on it
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestEnumeratorReset">
            <summary>
              Verifies that the Enumerator of the transforming read only collection correctly
              implements the Reset() method
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestRetrieveByIndexer">
            <summary>
              Checks whether the indexer method of the transforming read only collection
              is able to retrieve items from the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnInsertViaGenericIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Insert() method is called via the generic IList&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnRemoveViaGenericIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its RemoveAt() method is called via the generic IList&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestRetrieveByIndexerViaGenericIList">
            <summary>
              Checks whether the indexer method of the transforming read only collection will
              throw an exception if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnReplaceByIndexerViaGenericIList">
            <summary>
              Checks whether the indexer method of the transforming read only collection
              will throw an exception if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnAddViaGenericICollection">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Add() method is called via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnClearViaGenericICollection">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Clear() method is called via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnRemoveViaGenericICollection">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Remove() method is called via the generic ICollection&lt;&gt; interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestTypesafeEnumerator">
            <summary>
              Tests whether the typesafe enumerator of the read only collection is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnClearViaIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Clear() method is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnAddViaIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Add() method is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestContainsViaIList">
            <summary>
              Checks whether the Contains() method of the transforming read only collection
              is able to determine if the collection contains an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestIndexOfViaIList">
            <summary>
              Checks whether the IndexOf() method of the transforming read only collection
              is able to determine if the index of an item in the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnInsertViaIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Insert() method is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestIsFixedSizeViaIList">
            <summary>
              Checks whether the IsFixedSize property of the transforming read only collection
              returns the expected result for a transforming read only collection based on
              a fixed array
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnRemoveViaIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Remove() method is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnRemoveAtViaIList">
            <summary>
              Checks whether the transforming read only collection will throw an exception
              if its Remove() method is called via the IList interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestRetrieveByIndexerViaIList">
            <summary>
              Checks whether the indexer method of the transforming read only collection
              will throw an exception if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestThrowOnReplaceByIndexerViaIList">
            <summary>
              Checks whether the indexer method of the transforming read only collection
              will throw an exception if it is attempted to be used for replacing an item
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestCopyToArrayViaICollection">
            <summary>
              Verifies that the CopyTo() method of the transforming read only collection
              works if invoked via the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.TestSynchronizationOfIListWithoutICollection">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
              on transforming read only collections based on IList&lt;&gt;s that do not
              implement the ICollection interface
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.StringTransformer">
            <summary>Test implementation of a transforming collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.StringTransformer.#ctor(System.Collections.Generic.IList{System.Int32})">
            <summary>Initializes a new int-to-string transforming collection</summary>
            <param name="items">Items the transforming collection will contain</param>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollectionTest.StringTransformer.Transform(System.Int32)">
            <summary>Transforms an item into the exposed type</summary>
            <param name="item">Item to be transformed</param>
            <returns>The transformed item</returns>
            <remarks>
              This method is used to transform an item in the wrapped collection into
              the exposed item type whenever the user accesses an item. Expect it to
              be called frequently, because the TransformingReadOnlyCollection does
              not cache or otherwise store the transformed items.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Collections.WeakCollection`1">
            <summary>Collection of weakly referenced objects</summary>
            <remarks>
              This collection tries to expose the interface of a normal collection, but stores
              objects as weak references. When an object is accessed, it can return null.
              when the collection detects that one of its items was garbage collected, it
              will silently remove that item.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.#ctor(System.Collections.Generic.IList{Nuclex.Support.WeakReference{`0}})">
            <summary>Initializes a new weak reference collection</summary>
            <param name="items">
              Internal list of weak references that are unpacking when accessed through
              the WeakCollection's interface.
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.#ctor(System.Collections.Generic.IList{Nuclex.Support.WeakReference{`0}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new weak reference collection</summary>
            <param name="items">
              Internal list of weak references that are unpacking when accessed through
              the WeakCollection's interface.
            </param>
            <param name="comparer">
              Comparer used to identify and compare items to each other
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Contains(`0)">
            <summary>
              Determines whether an element is in the WeakCollection
            </summary>
            <param name="item">
              The object to locate in the WeakCollection. The value can be null.
            </param>
            <returns>
              True if value is found in the WeakCollection; otherwise, false.
            </returns>
            <remarks>
              The default implementation of this method is very unoptimized and will
              enumerate all the items in the collection, transforming one after another
              to check whether the transformed item matches the item the user was
              looking for. It is recommended to provide a custom implementation of
              this method, if possible.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
              Copies the entire WeakCollection to a compatible one-dimensional
              System.Array, starting at the specified index of the target array.
            </summary>
            <param name="array">
              The one-dimensional System.Array that is the destination of the elements copied
              from the WeakCollection. The System.Array must have zero-based indexing.
            </param>
            <param name="index">
              The zero-based index in array at which copying begins.
            </param>
            <exception cref="T:System.ArgumentException">
              Index is equal to or greater than the length of array or the number of elements
              in the source WeakCollection is greater than the available space from index to
              the end of the destination array.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is less than zero.
            </exception>
            <exception cref="T:System.ArgumentNullException">
              Array is null.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Clear">
            <summary>Removes all items from the WeakCollection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.GetEnumerator">
            <summary>
              Returns an enumerator that iterates through the WeakCollection.
            </summary>
            <returns>An enumerator or the WeakCollection.</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.IndexOf(`0)">
            <summary>
              Searches for the specified object and returns the zero-based index of the
              first occurrence within the entire WeakCollection.
            </summary>
            <param name="item">
              The object to locate in the WeakCollection. The value can
              be null for reference types.
            </param>
            <returns>
              The zero-based index of the first occurrence of item within the entire
              WeakCollection, if found; otherwise, -1.
            </returns>
            <remarks>
              The default implementation of this method is very unoptimized and will
              enumerate all the items in the collection, transforming one after another
              to check whether the transformed item matches the item the user was
              looking for. It is recommended to provide a custom implementation of
              this method, if possible.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Remove(`0)">
            <summary>
              Removes the first occurrence of a specific object from the WeakCollection.
            </summary>
            <param name="item">The object to remove from the WeakCollection</param>
            <returns>
              True if item was successfully removed from the WeakCollection; otherwise, false.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Add(`0)">
            <summary>Adds an item to the WeakCollection.</summary>
            <param name="item">The object to add to the WeakCollection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Insert(System.Int32,`0)">
            <summary>Inserts an item to the WeakCollection at the specified index.</summary>
            <param name="index">
              The zero-based index at which item should be inserted.
            </param>
            <param name="item">The object to insert into the WeakCollection</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              index is not a valid index in the WeakCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.RemoveAt(System.Int32)">
            <summary>
              Removes the WeakCollection item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the WeakCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.RemoveDeadItems">
            <summary>
              Removes the items that have been garbage collected from the collection
            </summary>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollection`1.items">
            <summary>Weak references to the items contained in the collection</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollection`1.comparer">
            <summary>Used to identify and compare items in the collection</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollection`1.syncRoot">
            <summary>Synchronization root for threaded accesses to this collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>
              A System.Collections.IEnumerator object that can be used to iterate through
              the collection.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the WeakCollection.</summary>
            <param name="value">The System.Object to add to the WeakCollection.</param>
            <returns>The position into which the new element was inserted.</returns>
            <exception cref="T:System.NotSupportedException">
              The System.Collections.IList is read-only or the WeakCollection has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Contains(System.Object)">
            <summary>
              Determines whether the WeakCollection contains a specific value.
            </summary>
            <param name="value">The System.Object to locate in the WeakCollection.</param>
            <returns>
              True if the System.Object is found in the WeakCollection; otherwise, false.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>Determines the index of a specific item in the WeakCollection.</summary>
            <param name="value">The System.Object to locate in the WeakCollection.</param>
            <returns>
              The index of value if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
              Inserts an item to the WeakCollection at the specified index.
            </summary>
            <param name="index">
              The zero-based index at which value should be inserted.
            </param>
            <param name="value">The System.Object to insert into the WeakCollection.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
            <exception cref="T:System.NotSupportedException">
              The System.Collections.IList is read-only or the WeakCollection has a fixed size.
            </exception>
            <exception cref="T:System.NullReferenceException">
              Value is null reference in the WeakCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Remove(System.Object)">
            <summary>
              Removes the first occurrence of a specific object from the WeakCollection.
            </summary>
            <param name="value">The System.Object to remove from the WeakCollection.</param>
            <exception cref="T:System.NotSupportedException">
              The WeakCollection is read-only or the WeakCollection has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
              Copies the elements of the WeakCollection to an System.Array, starting at
              a particular System.Array index.
            </summary>
            <param name="array">
              The one-dimensional System.Array that is the destination of the elements
              copied from WeakCollection. The System.Array must have zero-based indexing.
            </param>
            <param name="index">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
              Array is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is less than zero.
            </exception>
            <exception cref="T:System.ArgumentException">
              Array is multidimensional or index is equal to or greater than the length
              of array or the number of elements in the source WeakCollection is greater than
              the available space from index to the end of the destination array.
            </exception>
            <exception cref="T:System.InvalidCastException">
              The type of the source WeakCollection cannot be cast automatically to the type of
              the destination array.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.downcastToItemType(System.Object)">
            <summary>
              Downcasts an object reference to a reference to the collection's item type
            </summary>
            <param name="value">Object reference that will be downcast</param>
            <returns>
              The specified object referecne as a reference to the collection's item type
            </returns>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.Count">
            <summary>
              The number of elements contained in the WeakCollection instance
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.Item(System.Int32)">
            <summary>Gets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
               Index is less than zero or index is equal to or greater than
               WeakCollection.Count.
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.IsReadOnly">
            <summary>Whether the List is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#IsFixedSize">
            <summary>
              A value indicating whether the WeakCollection has a fixed size.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Item(System.Int32)">
            <summary>Gets or sets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the WeakCollection
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>
              A value indicating whether access to the WeakCollection is
              synchronized (thread safe).
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>
              An object that can be used to synchronize access to the WeakCollection.
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator">
            <summary>
              An enumerator that unpacks the items returned by an enumerator of the
              weak reference collection into the actual item type on-the-fly.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.#ctor(System.Collections.Generic.IEnumerator{Nuclex.Support.WeakReference{`0}})">
            <summary>Initializes a new unpacking enumerator</summary>
            <param name="containedTypeEnumerator">
              Enumerator of the weak reference collection
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.Dispose">
            <summary>Immediately releases all resources used by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.MoveNext">
            <summary>Gets the current element in the collection.</summary>
            <returns>The current element in the collection.</returns>
            <exception cref="T:System.InvalidOperationException">
              The enumerator is positioned before the first element of the collection
              or after the last element.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.Reset">
            <summary>
              Sets the enumerator to its initial position, which is before the first element
              in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
              The collection was modified after the enumerator was created.
            </exception>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.containedTypeEnumerator">
            <summary>An enumerator from the wrapped collection</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.Current">
            <summary>
              The element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.System#Collections#IEnumerator#Current">
            <summary>The current element in the collection.</summary>
            <exception cref="T:System.InvalidOperationException">
              The enumerator is positioned before the first element of the collection
              or after the last element.
            </exception>
        </member>
        <member name="T:Nuclex.Support.Collections.WeakCollectionTest">
            <summary>Unit Test for the weak collection wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestConstructor">
            <summary>Verifies that the constructor of the weak collection is working</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestAddAsObject">
            <summary>
              Test whether the non-typesafe Add() method of the weak collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestThrowOnAddIncompatibleObject">
            <summary>
              Test whether the non-typesafe Add() method throws an exception if an object is
              added that is not compatible to the collection's item type
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestAdd">
            <summary>
              Test whether the generic Add() method of the weak collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestClear">
            <summary>Tests whether the Clear() method works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestContains">
            <summary>Tests whether the Contains() method works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestContainsWithObject">
            <summary>Tests whether the non-typesafe Contains() method works</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestEnumeratorReset">
            <summary>
              Verifies that the Enumerator of the dummy collection correctly
              implements the Reset() method
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIndexOf">
            <summary>Verifies that the IndexOf() method is working as intended</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIndexOfWithObject">
            <summary>
              Verifies that the non-typesafe IndexOf() method is working as intended
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestThrowOnIndexOfWithIncompatibleObject">
            <summary>
              Verifies that an exception is thrown if an incompatible object is passed to
              the non-typesafe variant of the IndexOf() method
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIndexOfNull">
            <summary>Test whether the IndexOf() method can cope with null references</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestCopyToArray">
            <summary>
              Verifies that the CopyTo() method of the weak collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestThrowOnCopyToTooSmallArray">
            <summary>
              Verifies that the CopyTo() method of the weak collection throws an exception
              if the target array is too small to hold the collection's contents
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestCopyToArrayViaICollection">
            <summary>
              Verifies that the CopyTo() method of the transforming read only collection
              works if invoked via the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestInsert">
            <summary>
              Verifies that the Insert() method correctly shifts items in the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestInsertObject">
            <summary>
              Verifies that the non-typesafe Insert() method correctly shifts items in
              the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestThrowOnInsertIncompatibleObject">
            <summary>
              Verifies that the non-typesafe Insert() method correctly shifts items in
              the collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIsFixedSizeViaIList">
            <summary>
              Checks whether the IsFixedSize property of the weak collection returns
              the expected result for a weak collection based on a fixed array
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIsReadOnly">
            <summary>
              Tests whether the IsReadOnly property of the weak collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIsSynchronized">
            <summary>
              Tests whether the IsSynchronized property of the weak collection works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIndexer">
            <summary>Tests the indexer of the weak collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestIndexerWithObject">
            <summary>Tests the non-typesafe indexer of the weak collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestThrowOnIndexerWithIncompatibleObject">
            <summary>
              Tests whether the non-typesafe indexer of the weak collection throws
              the correct exception if an incompatible object is assigned
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestRemove">
            <summary>Tests the Remove() method of the weak collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestRemoveObject">
            <summary>Tests the non-typesafe Remove() method of the weak collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestRemoveNull">
            <summary>
              Tests whether a null object can be managed by and removed from the weak collection
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestThrowOnRemoveIncompatibleObject">
            <summary>
              Tests whether the non-typesafe Remove() method of the weak collection throws
              an exception if an object is tried to be removed that is incompatible with
              the collection's item type
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestRemoveAt">
            <summary>Tests the RemoveAt() method of the weak collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestSynchronization">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestSynchronizationOfIListWithoutICollection">
            <summary>
              Verifies that the IsSynchronized property and the SyncRoot property are working
              on transforming read only collections based on IList&lt;&gt;s that do not
              implement the ICollection interface
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.TestRemoveDeadItems">
            <summary>Tests the RemoveDeadItems() method</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.WeakCollectionTest.Dummy">
            <summary>Dummy class used to test the weakly referencing collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.Dummy.#ctor(System.Int32)">
            <summary>Initializes a new dummy</summary>
            <param name="value">Value that will be stored by the dummy</param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.Dummy.Equals(System.Object)">
            <summary>
              Determines whether the specified System.Object is equal to
              the current Dummy object.
            </summary>
            <param name="otherAsObject">
              The System.Object to compare with the current Dummy object
            </param>
            <returns>
              True if the specified System.Object is equal to the current Dummy object;
              otherwise, false.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollectionTest.Dummy.GetHashCode">
            <summary>Serves as a hash function for a particular type.</summary>
            <returns>A hash code for the current System.Object.</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollectionTest.Dummy.Value">
            <summary>Some value that can be used for testing</summary>
        </member>
        <member name="T:Nuclex.Support.FloatHelper">
            <summary>Helper routines for working with floating point numbers</summary>
            <remarks>
              <para>
                The floating point comparison code is based on this excellent article:
                http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
              </para>
              <para>
                "ULP" means Unit in the Last Place and in the context of this library refers to
                the distance between two adjacent floating point numbers. IEEE floating point
                numbers can only represent a finite subset of natural numbers, with greater
                accuracy for smaller numbers and lower accuracy for very large numbers.
              </para>
              <para>
                If a comparison is allowed "2 ulps" of deviation, that means the values are
                allowed to deviate by up to 2 adjacent floating point values, which might be
                as low as 0.0000001 for small numbers or as high as 10.0 for large numbers.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.AreAlmostEqual(System.Single,System.Single,System.Int32)">
            <summary>Compares two floating point values for equality</summary>
            <param name="left">First floating point value to be compared</param>
            <param name="right">Second floating point value t be compared</param>
            <param name="maxUlps">
              Maximum number of representable floating point values that are allowed to
              be between the left and the right floating point values
            </param>
            <returns>True if both numbers are equal or close to being equal</returns>
            <remarks>
              <para>
                Floating point values can only represent a finite subset of natural numbers.
                For example, the values 2.00000000 and 2.00000024 can be stored in a float,
                but nothing inbetween them.
              </para>
              <para>
                This comparison will count how many possible floating point values are between
                the left and the right number. If the number of possible values between both
                numbers is less than or equal to maxUlps, then the numbers are considered as
                being equal.
              </para>
              <para>
                Implementation partially follows the code outlined here (link now defunct):
                http://www.anttirt.net/2007/08/19/proper-floating-point-comparisons/
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.AreAlmostEqual(System.Double,System.Double,System.Int64)">
            <summary>Compares two double precision floating point values for equality</summary>
            <param name="left">First double precision floating point value to be compared</param>
            <param name="right">Second double precision floating point value t be compared</param>
            <param name="maxUlps">
              Maximum number of representable double precision floating point values that are
              allowed to be between the left and the right double precision floating point values
            </param>
            <returns>True if both numbers are equal or close to being equal</returns>
            <remarks>
              <para>
                Double precision floating point values can only represent a limited series of
                natural numbers. For example, the values 2.0000000000000000 and 2.0000000000000004
                can be stored in a double, but nothing inbetween them.
              </para>
              <para>
                This comparison will count how many possible double precision floating point
                values are between the left and the right number. If the number of possible
                values between both numbers is less than or equal to maxUlps, then the numbers
                are considered as being equal.
              </para>
              <para>
                Implementation partially follows the code outlined here:
                http://www.anttirt.net/2007/08/19/proper-floating-point-comparisons/
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.ReinterpretAsInt(System.Single)">
            <summary>
              Reinterprets the memory contents of a floating point value as an integer value
            </summary>
            <param name="value">
              Floating point value whose memory contents to reinterpret
            </param>
            <returns>
              The memory contents of the floating point value interpreted as an integer
            </returns>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.ReinterpretAsLong(System.Double)">
            <summary>
              Reinterprets the memory contents of a double precision floating point
              value as an integer value
            </summary>
            <param name="value">
              Double precision floating point value whose memory contents to reinterpret
            </param>
            <returns>
              The memory contents of the double precision floating point value
              interpreted as an integer
            </returns>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.ReinterpretAsFloat(System.Int32)">
            <summary>
              Reinterprets the memory contents of an integer as a floating point value
            </summary>
            <param name="value">Integer value whose memory contents to reinterpret</param>
            <returns>
              The memory contents of the integer value interpreted as a floating point value
            </returns>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.ReinterpretAsDouble(System.Int64)">
            <summary>
              Reinterprets the memory contents of an integer value as a double precision
              floating point value
            </summary>
            <param name="value">Integer whose memory contents to reinterpret</param>
            <returns>
              The memory contents of the integer interpreted as a double precision
              floating point value
            </returns>
        </member>
        <member name="T:Nuclex.Support.FloatHelper.FloatIntUnion">
            <summary>Union of a floating point variable and an integer</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.FloatIntUnion.Float">
            <summary>The union's value as a floating point variable</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.FloatIntUnion.Int">
            <summary>The union's value as an integer</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.FloatIntUnion.UInt">
            <summary>The union's value as an unsigned integer</summary>
        </member>
        <member name="T:Nuclex.Support.FloatHelper.DoubleLongUnion">
            <summary>Union of a double precision floating point variable and a long</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.DoubleLongUnion.Double">
            <summary>The union's value as a double precision floating point variable</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.DoubleLongUnion.Long">
            <summary>The union's value as a long</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.DoubleLongUnion.ULong">
            <summary>The union's value as an unsigned long</summary>
        </member>
        <member name="T:Nuclex.Support.FloatHelperTest">
            <summary>Unit Test for the FloatHelper class</summary>
        </member>
        <member name="M:Nuclex.Support.FloatHelperTest.TestFloatComparison">
            <summary>Tests the floating point value comparison helper</summary>
        </member>
        <member name="M:Nuclex.Support.FloatHelperTest.TestDoubleComparison">
            <summary>Tests the double precision floating point value comparison helper</summary>
        </member>
        <member name="M:Nuclex.Support.FloatHelperTest.TestIntegerReinterpretation">
            <summary>Tests the integer reinterpretation functions</summary>
        </member>
        <member name="M:Nuclex.Support.FloatHelperTest.TestLongReinterpretation">
            <summary>Tests the long reinterpretation functions</summary>
        </member>
        <member name="M:Nuclex.Support.FloatHelperTest.TestFloatReinterpretation">
            <summary>Tests the floating point reinterpretation functions</summary>
        </member>
        <member name="M:Nuclex.Support.FloatHelperTest.TestDoubleReinterpretation">
            <summary>
              Tests the double prevision floating point reinterpretation functions
            </summary>
        </member>
        <member name="T:Nuclex.Support.IntegerHelper">
            <summary>Helper methods for working with integer types</summary>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.NextPowerOf2(System.Int64)">
            <summary>Returns the next highest power of 2 from the specified value</summary>
            <param name="value">Value of which to return the next highest power of 2</param>
            <returns>The next highest power of 2 to the value</returns>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.NextPowerOf2(System.UInt64)">
            <summary>Returns the next highest power of 2 from the specified value</summary>
            <param name="value">Value of which to return the next highest power of 2</param>
            <returns>The next highest power of 2 to the value</returns>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.NextPowerOf2(System.Int32)">
            <summary>Returns the next highest power of 2 from the specified value</summary>
            <param name="value">Value of which to return the next highest power of 2</param>
            <returns>The next highest power of 2 to the value</returns>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.NextPowerOf2(System.UInt32)">
            <summary>Returns the next highest power of 2 from the specified value</summary>
            <param name="value">Value of which to return the next highest power of 2</param>
            <returns>The next highest power of 2 to the value</returns>
        </member>
        <member name="T:Nuclex.Support.IntegerHelperTest">
            <summary>Contains unit tests for the integer helper class</summary>
        </member>
        <member name="M:Nuclex.Support.IntegerHelperTest.TestNextPowerOf2ULong">
            <summary>
              Verifies that the next power of 2 calculation works for long integers
            </summary>
        </member>
        <member name="M:Nuclex.Support.IntegerHelperTest.TestNextPowerOf2Long">
            <summary>
              Verifies that the next power of 2 calculation works for long integers
            </summary>
        </member>
        <member name="M:Nuclex.Support.IntegerHelperTest.TestNextPowerOf2UInt">
            <summary>
              Verifies that the next power of 2 calculation works for integers
            </summary>
        </member>
        <member name="M:Nuclex.Support.IntegerHelperTest.TestNextPowerOf2Int">
            <summary>
              Verifies that the next power of 2 calculation works for integers
            </summary>
        </member>
        <member name="T:Nuclex.Support.Licensing.LicenseKey">
            <summary>Typical license key with 5x5 alphanumerical characters</summary>
            <remarks>
              <para>
                This class manages a license key like it is used in Microsoft products.
                Althought it is probably not the exact same technique used by Microsoft,
                the textual representation of the license keys looks identical,
                eg. <code>O809J-RN5TD-IM3CU-4IG1O-O90X9</code>.
              </para>
              <para>
                Available storage space is used efficiently and allows for up to four
                32 bit integers to be stored within the key, that's enough for a full GUID.
                The four integers can be modified directly, for example to store feature
                lists, checksums or other data within the key.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.Parse(System.String)">
            <summary>Parses the license key contained in a string</summary>
            <param name="key">String containing a license key that is to be parsed</param>
            <returns>The license key parsed from provided string</returns>
            <exception cref="T:System.ArgumentException">
              When the provided string is not a license key
            </exception>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.#ctor">
            <summary>Initializes a new, empty license key</summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.#ctor(System.Guid)">
            <summary>Initializes the license key from a GUID</summary>
            <param name="source">GUID that is used to create the license key</param>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.ToGuid">
            <summary>Converts the license key into a GUID</summary>
            <returns>The GUID created from the license key</returns>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.ToByteArray">
            <summary>Converts the license key into a byte array</summary>
            <returns>A byte array containing the converted license key</returns>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.ToString">
            <summary>Converts the license key to a string</summary>
            <returns>A string containing the converted license key</returns>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.mangle(System.Collections.BitArray)">
            <summary>Mangles a bit array</summary>
            <param name="bits">Bit array that will be mangled</param>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.unmangle(System.Collections.BitArray)">
            <summary>Unmangles a bit array</summary>
            <param name="bits">Bit array that will be unmangled</param>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.keyDelimiter">
            <summary>Character used to delimit each 5 digit group in a license key</summary>
            <remarks>
              Required to be a char array because the .NET Compact Framework only provides
              an overload for char[] in the StringBuilder.Insert() method.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.codeTable">
            <summary>Table with the individual characters in a key</summary>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.powersOfTwo">
            <summary>Helper array containing the precalculated powers of two</summary>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.shuffle">
            <summary>Index list for rotating the bit arrays</summary>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.guid">
            <summary>GUID in which the key is stored</summary>
        </member>
        <member name="P:Nuclex.Support.Licensing.LicenseKey.Item(System.Int32)">
            <summary>Accesses the four integer values within a license key</summary>
            <exception cref="T:System.IndexOutOfRangeException">
              When the index lies outside of the key's fields
            </exception>
        </member>
        <member name="T:Nuclex.Support.Licensing.LicenseKeyTest">
            <summary>Unit test for the license key class</summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.TestDefaultConstructor">
            <summary>Tests the default constructor of the license key class</summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.TestGuidKeyConversion">
            <summary>Validates the correct translation of keys to GUIDs and back</summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.TestKeyModification">
            <summary>Tests whether license keys can be modified without destroying them</summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.TestParseInvalidLicenseKey">
            <summary>Tests whether license keys can be modified without destroying them</summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.TestGetByIndexerWithInvalidIndex">
            <summary>
              Tests whether an exception is thrown if the indexer of a license key is used
              with an invalid index to retrieve a component of the key
            </summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.TestSetByIndexerWithInvalidIndex">
            <summary>
              Tests whether an exception is thrown if the indexer of a license key is used
              with an invalid index to set a component of the key
            </summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKeyTest.TestToByteArray">
            <summary>
              Verifies that a license key can be converted into a byte array
            </summary>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLine">
            <summary>Parses and stores an application's command line parameters</summary>
            <remarks>
              <para>
                At the time of the creation of this component, there are already several command
                line parsing libraries out there. Most of them, however, do way too much at once
                or at the very least rely on huge, untested clutters of classes and methods to
                arrive at their results.
              </para>
              <para>
                This command line parser does nothing more than represent the command line to
                the application through a convenient interface. It parses a command line and
                extracts the arguments, but doesn't interpret them and or check them for validity.
              </para>
              <para>
                This design promotes simplicity and makes is an ideal building block to create
                actual command line interpreters that connect the parameters to program
                instructions and or fill structures in code.
              </para>
              <para>
                Terminology
                <list type="table">
                  <item>
                    <term>Command line</term>
                    <description>
                      The entire command line either as a string or as
                      an already parsed data structure
                    </description>
                  </item>
                  <item>
                    <term>Argument</term>
                    <description>
                      Either an option or a loose value (see below) being specified on
                      the command line
                    </description>
                  </item>
                  <item>
                    <term>Option</term>
                    <description>
                      Can be specified on the command line and typically alters the behavior
                      of the application or changes a setting. For example, '--normalize' or
                      '/safemode'.
                    </description>
                  </item>
                  <item>
                    <term>Value</term>
                    <description>
                      Can either sit loosely in the command line (eg. 'update' or 'textfile.txt')
                      or as assignment to an option (eg. '--width=1280' or '/overwrite:always')
                    </description>
                  </item>
                </list>
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.WindowsModeDefault">
            <summary>
              Whether the command line should use Windows mode by default
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.#ctor">
            <summary>Initializes a new command line</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.#ctor(System.Boolean)">
            <summary>Initializes a new command line</summary>
            <param name="windowsMode">Whether the / character initiates an argument</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.#ctor(System.Collections.Generic.List{Nuclex.Support.Parsing.CommandLine.Argument})">
            <summary>Initializes a new command line</summary>
            <param name="argumentList">List containing the parsed arguments</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.#ctor(System.Collections.Generic.List{Nuclex.Support.Parsing.CommandLine.Argument},System.Boolean)">
            <summary>Initializes a new command line</summary>
            <param name="argumentList">List containing the parsed arguments</param>
            <param name="windowsMode">Whether the / character initiates an argument</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parse(System.String)">
            <summary>Parses the command line arguments from the provided string</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <returns>The parsed command line</returns>
            <remarks>
              You should always pass Environment.CommandLine to this method to avoid
              some problems with the built-in command line tokenizer in .NET
              (which splits '--test"hello world"/v' into '--testhello world/v')
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parse(System.String,System.Boolean)">
            <summary>Parses the command line arguments from the provided string</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <param name="windowsMode">Whether the / character initiates an argument</param>
            <returns>The parsed command line</returns>
            <remarks>
              You should always pass Environment.CommandLine to this methods to avoid
              some problems with the built-in command line tokenizer in .NET
              (which splits '--test"hello world"/v' into '--testhello world/v')
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.HasArgument(System.String)">
            <summary>Returns whether an argument with the specified name exists</summary>
            <param name="name">Name of the argument whose existence will be checked</param>
            <returns>True if an argument with the specified name exists</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddValue(System.String)">
            <summary>Adds a value to the command line</summary>
            <param name="value">Value that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddOption(System.String)">
            <summary>Adds an option to the command line</summary>
            <param name="name">Name of the option that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddOption(System.String,System.String)">
            <summary>Adds an option to the command line</summary>
            <param name="initiator">Initiator that will be used to start the option</param>
            <param name="name">Name of the option that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddAssignment(System.String,System.String)">
            <summary>Adds an option with an assignment to the command line</summary>
            <param name="name">Name of the option that will be added</param>
            <param name="value">Value that will be assigned to the option</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddAssignment(System.String,System.String,System.String)">
            <summary>Adds an option with an assignment to the command line</summary>
            <param name="initiator">Initiator that will be used to start the option</param>
            <param name="name">Name of the option that will be added</param>
            <param name="value">Value that will be assigned to the option</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.ToString">
            <summary>Returns a string that contains the entire command line</summary>
            <returns>The entire command line as a single string</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.indexOfArgument(System.String)">
            <summary>Retrieves the index of the argument with the specified name</summary>
            <param name="name">Name of the argument whose index will be returned</param>
            <returns>
              The index of the indicated argument of -1 if no argument with that name exists
            </returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.requiresQuotes(System.String)">
            <summary>
              Determines whether the string requires quotes to survive the command line
            </summary>
            <param name="value">Value that will be checked for requiring quotes</param>
            <returns>True if the value requires quotes to survive the command line</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.containsWhitespace(System.String)">
            <summary>
              Determines whether the string contains any whitespace characters
            </summary>
            <param name="value">String that will be scanned for whitespace characters</param>
            <returns>True if the provided string contains whitespace characters</returns>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.arguments">
            <summary>Options that were specified on the command line</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.windowsMode">
            <summary>Whether the / character initiates an argument</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Arguments">
            <summary>Options that were specified on the command line</summary>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLine.Argument">
            <summary>Argument being specified on an application's command line</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Argument.OptionOnly(Nuclex.Support.StringSegment,System.Int32,System.Int32)">
            <summary>Initializes a new option with only a name</summary>
            <param name="raw">
              String segment with the entire argument as it was given on the command line
            </param>
            <param name="nameStart">Absolute index the argument name starts at</param>
            <param name="nameLength">Number of characters in the option name</param>
            <returns>The newly created option</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Argument.ValueOnly(Nuclex.Support.StringSegment,System.Int32,System.Int32)">
            <summary>Initializes a new argument with only a value</summary>
            <param name="raw">
              String segment with the entire argument as it was given on the command line
            </param>
            <param name="valueStart">Absolute index the value starts at</param>
            <param name="valueLength">Number of characters in the value</param>
            <returns>The newly created option</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Argument.#ctor(Nuclex.Support.StringSegment,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Creates a new option with a name and an assigned value</summary>
            <param name="raw">
              String segment containing the entire option as it was given on the command line
            </param>
            <param name="nameStart">Absolute index the option name starts at</param>
            <param name="nameLength">Number of characters in the option name</param>
            <param name="valueStart">Absolute index the value starts at</param>
            <param name="valueLength">Number of characters in the value</param>
            <returns>The newly created option</returns>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.raw">
            <summary>
              Contains the entire option as it was specified on the command line
            </summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.nameStart">
            <summary>Absolute index in the raw string the option name starts at</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.nameLength">
            <summary>Number of characters in the option name</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.valueStart">
            <summary>Absolute index in the raw string the value starts at</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.valueLength">
            <summary>Number of characters in the value</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Raw">
            <summary>Contains the raw string the command line argument was parsed from</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Initiator">
            <summary>Characters used to initiate this option</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Name">
            <summary>Name of the command line option</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Associator">
            <summary>Characters used to associate a value to this option</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Value">
            <summary>Name of the command line option</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.RawLength">
            <summary>The raw length of the command line argument</summary>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLine.Formatter">
            <summary>Formats a command line instance into a string</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Formatter.FormatCommandLine(Nuclex.Support.Parsing.CommandLine)">
            <summary>
              Formats all arguments in the provided command line instance into a string
            </summary>
            <param name="commandLine">Command line instance that will be formatted</param>
            <returns>All arguments in the command line instance as a string</returns>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLine.Parser">
            <summary>Parses command line strings</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.#ctor(System.Boolean)">
            <summary>Initializes a new command line parser</summary>
            <param name="windowsMode">Whether the / character initiates an argument</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.Parse(System.String,System.Boolean)">
            <summary>Parses a string containing command line arguments</summary>
            <param name="commandLineString">String that will be parsed</param>
            <param name="windowsMode">Whether the / character initiates an argument</param>
            <returns>The parsed command line arguments from the string</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseFullCommandLine(System.String)">
            <summary>
              Parses the provided string and adds the parameters found to
              the command line representation
            </summary>
            <param name="commandLineString">
              String containing the command line arguments that will be parsed
            </param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseChunk(System.String,System.Int32@)">
            <summary>
              Parses a chunk of characters and adds it as an option or a loose value to
              the command line representation we're building
            </summary>
            <param name="commandLineString">
              String containing the chunk of characters that will be parsed
            </param>
            <param name="index">Index in the string at which to begin parsing</param>
            <returns>The number of characters that were consumed</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parsePotentialOption(System.String,System.Int32,System.Int32@)">
            <summary>Parses a potential command line option</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <param name="initiatorStartIndex">
              Index of the option's initiator ('-' or '--' or '/')
            </param>
            <param name="index">
              Index at which the option name is supposed start (if it's an actual option)
            </param>
            <returns>The number of characters consumed</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parsePotentialOptionAssignment(System.String,System.Int32,System.Int32,System.Int32@)">
            <summary>Parses the value assignment in a command line option</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <param name="initiatorStartIndex">
              Position of the character that started the option
            </param>
            <param name="nameStartIndex">
              Position of the first character in the option's name
            </param>
            <param name="index">Index at which the option name ended</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseOptionValue(System.String,System.Int32,System.Int32,System.Int32@)">
            <summary>Parses the value assignment in a command line option</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <param name="initiatorStartIndex">
              Position of the character that started the option
            </param>
            <param name="nameStartIndex">
              Position of the first character in the option's name
            </param>
            <param name="index">Index at which the option name ended</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseQuotedValue(System.String,System.Int32@)">
            <summary>Parses a quoted value from the input string</summary>
            <param name="commandLineString">String the quoted value is parsed from</param>
            <param name="index">Index at which the quoted value begins</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseNakedValue(System.String,System.Int32@)">
            <summary>Parses a plain, unquoted value from the input string</summary>
            <param name="commandLineString">String containing the value to be parsed</param>
            <param name="index">Index at which the value begins</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.addValue(Nuclex.Support.StringSegment)">
            <summary>Adds a loose value to the command line</summary>
            <param name="value">Value taht will be added</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.isAssignmentCharacter(System.Char)">
            <summary>
              Determines whether the specified character indicates an assignment
            </summary>
            <param name="character">
              Character that will be checked for being an assignemnt
            </param>
            <returns>
              True if the specified character indicated an assignment, otherwise false
            </returns>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Parser.NameEndingCharacters">
            <summary>Characters which end an option name when they are encountered</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Parser.WhitespaceCharacters">
            <summary>Characters the parser considers to be whitespace</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Parser.arguments">
            <summary>Argument list being filled by the parser</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Parser.windowsMode">
            <summary>Whether the '/' character initiates an argument</summary>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLineTest">
            <summary>Ensures that the command line parser is working properly</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestDefaultConstructor">
            <summary>Verifies that the default constructor is working</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseAmbiguousNameResolution">
            <summary>
              Validates that the parser can handle an argument initiator with an
              assignment that is missing a name
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseShortArgumentInitiatorOnly">
            <summary>
              Verifies that a lone short argument initiator without anything behind
              can be parsed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseLongArgumentInitiatorOnly">
            <summary>
              Verifies that a lone long argument initiator without anything behind
              can be parsed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseArgumentInitiatorAtEnd">
            <summary>
              Validates that the parser can handle multiple lone argument initators without
              a following argument
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseQuotedValue">
            <summary>Validates that quoted arguments can be parsed</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseNull">
            <summary>Validates that null can be parsed</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseSingleNakedValue">
            <summary>Validates that a single argument without quotes can be parsed</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseQuotedArgumentWithoutClosingQuote">
            <summary>
              Validates that the parser can handle a quoted argument that's missing
              the closing quote
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseQuotedValueWithoutClosingQuote">
            <summary>
              Validates that the parser correctly handles a quoted value assignment that's
              missing the closing quote
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseSpacesOnly">
            <summary>
              Validates that the parser can handle an command line consisting of only spaces
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseQuotedOption">
            <summary>
              Validates that the parser can handle a quoted option
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseMultipleLoneArgumentInitiators">
            <summary>
              Validates that the parser can handle multiple lone argument initators without
              a following argument
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseOptionWithEmbeddedInitiator">
            <summary>
              Verifies that the parser correctly handles options with embedded option initiators
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseOptionAndValueWithoutSpaces">
            <summary>
              Validates that arguments and values without spaces inbetween can be parsed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseOptionWithModifierAtEnd">
            <summary>
              Validates that options with modifiers at the end of the command line
              are parsed successfully
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseOptionWithAssignment">
            <summary>
              Validates that options with values assigned to them are parsed successfully
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestParseOptionAtEndOfString">
            <summary>
              Validates that options with an empty value at the end of the command line
              string are parsed successfully
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestWindowsOptionInitiator">
            <summary>
              Verifies that the parser can recognize windows command line options if
              configured to windows mode
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestNonWindowsOptionValues">
            <summary>
              Verifies that the parser ignores windows command line options if
              configured to non-windows mode
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestHasArgument">
            <summary>
              Tests whether the existence of named arguments can be checked
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestCommandLineFormatting">
            <summary>
              Tests whether a command line can be built with the command line class
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.TestNullArgumentFormatting">
            <summary>
              Tests whether a command line can be built that contains empty arguments
            </summary>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest">
            <summary>Unit test for the command line option class</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestNameExtraction">
            <summary>
              Verifies that the name of a command line argument without a value can
              be extracted
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestNameExtractionFromSubstring">
            <summary>
              Verifies that the name of a command line argument without a value can be
              extracted when the argument is contained in a substring of a larger string
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestValueExtraction">
            <summary>
              Varifies that the name and value of a command line argument can be extracted
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestValueExtractionFromSubstring">
            <summary>
              Varifies that the name and value of a command line argument can be extracted
              when the argument is contained in a substring of a larger string
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestQuotedValueExtraction">
            <summary>
              Varifies that the name and value of a command line argument can be extracted
              when the option is assigned a quoted value
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestValuelessAssociatorRetrieval">
            <summary>
              Varifies that the associator of a command line argument with an open ended
              value assignment can be retrieved
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestValuelessAssociatorRetrievalFromSubstring">
            <summary>
              Varifies that the associator of a command line option with an open ended value
              assignment can be retrieved when the option is contained in a substring of
              a larger string
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestNamelessValueRetrieval">
            <summary>
              Varifies that a command line argument without an option name can be retrieved
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLineTest.ArgumentTest.TestNamelessValueRetrievalFromSubstring">
            <summary>
              Varifies that a command line argument without an option name can be retrieved
              that is contained in a substring of larger string
            </summary>
        </member>
        <member name="T:Nuclex.Support.PathHelper">
            <summary>Utility class for path operations</summary>
        </member>
        <member name="M:Nuclex.Support.PathHelper.MakeRelative(System.String,System.String)">
            <summary>Converts an absolute path into a relative one</summary>
            <param name="basePath">Base directory the new path should be relative to</param>
            <param name="absolutePath">Absolute path that will be made relative</param>
            <returns>
              A path relative to the indicated base directory that matches the
              absolute path given.
            </returns>
        </member>
        <member name="T:Nuclex.Support.PathHelperTest">
            <summary>Unit Test for the path helper class</summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeWindowsPathOfNonRelativePath">
            <summary>
              Tests whether the relative path creator keeps the absolute path if
              the location being passed is not relative to the base path.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeWindowsPathToParentFolder">
            <summary>
              Tests whether the relative path creator correctly builds the relative
              path to the parent folder of the base path for windows paths.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeWindowsPathToParentFolderTwoLevels">
            <summary>
              Tests whether the relative path creator correctly builds the relative path to
              the parent folder of the base path for windows paths with more than one level.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeUnixPathToParentFolder">
            <summary>
              Tests whether the relative path creator correctly builds the relative
              path to the parent folder of the base path for unix paths.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeUnixPathToParentFolderTwoLevels">
            <summary>
              Tests whether the relative path creator correctly builds the relative path to
              the parent folder of the base path for unix paths with more than one level.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeWindowsPathToNestedFolder">
            <summary>
              Tests whether the relative path creator correctly builds the relative
              path to a nested folder in the base path for windows paths.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeUnixPathToNestedFolder">
            <summary>
              Tests whether the relative path creator correctly builds the relative
              path to a nested folder in the base path for unix paths.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeWindowsPathToSiblingFolder">
            <summary>
              Tests whether the relative path creator correctly builds the relative
              path to another folder on the same level as base path for windows paths.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.TestRelativeUnixPathToSiblingFolder">
            <summary>
              Tests whether the relative path creator correctly builds the relative
              path to another folder on the same level as base path for unix paths.
            </summary>
        </member>
        <member name="M:Nuclex.Support.PathHelperTest.platformify(System.String)">
            <summary>
              Converts unix-style directory separators into the format used by the current platform
            </summary>
            <param name="path">Path to converts into the platform-dependent format</param>
            <returns>Platform-specific version of the provided unix-style path</returns>
        </member>
        <member name="T:Nuclex.Support.Plugins.EmployerTest">
            <summary>Unit Test for the employer class</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.EmployerTest.TestEmployerDefaultConstructorDetection">
            <summary>Tests whether the employer can detect a default constructor</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.EmployerTest.TestEmployer">
            <summary>Dummy implementation for testing the employer class</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.Employer">
            <summary>Plugin type employer</summary>
            <remarks>
              This class is used by the plugin host to assess whether a concrete type found
              in a plugin assembly is suited to be processed the plugin user. If so,
              the employer can employ the type. Employing can typically mean to create an
              instance of the type in the plugin assembly or to build a runtime-factory
              that can create instances of the type when it is needed.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.Employer.CanEmploy(System.Type)">
            <summary>Determines whether the type suites the employer's requirements</summary>
            <param name="type">Type which will be assessed</param>
            <returns>True if the type can be employed, otherwise false</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.Employer.Employ(System.Type)">
            <summary>Employs the specified plugin type</summary>
            <param name="type">Type to be employed</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.EmployerTest.TestEmployer.Employ(System.Type)">
            <summary>Employs the specified plugin type</summary>
            <param name="type">Type to be employed</param>
        </member>
        <member name="T:Nuclex.Support.Plugins.EmployerTest.NoDefaultConstructor">
            <summary>Test class that doesn't have a default constructor</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.EmployerTest.NoDefaultConstructor.#ctor(System.Int32)">
            <summary>Initializes a new instance of the test class</summary>
            <param name="dummy">Dummy argument so this is no default constructor</param>
        </member>
        <member name="T:Nuclex.Support.Plugins.EmployerTest.NonPublicDefaultConstructor">
            <summary>Test class that has a non-public default constructor</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.EmployerTest.NonPublicDefaultConstructor.#ctor">
            <summary>Initializes a new instance of the test class</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.EmployerTest.PublicDefaultConstructor">
            <summary>Test class that has a public default constructor</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.EmployerTest.PublicDefaultConstructor.#ctor">
            <summary>Initializes a new instance of the test class</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.FactoryEmployerTest">
            <summary>Unit Test for the factory employer class</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployerTest.TestCanEmploy">
            <summary>
              Tests whether the factory employer can detect employable types
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployerTest.TestNonGenericCreateInstance">
            <summary>
              Tests whether the factory employer can use the non-generic IAbstractFactory
              interface instead of its generic variant
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployerTest.TestThrowOnEmployAbstractClass">
            <summary>
              Tests whether the factory employer throws an exception when it is asked to
              employ an abstract class
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployerTest.TestThrowOnEmployUnrelatedClass">
            <summary>
              Tests whether the factory employer throws an exception when it is asked to
              employ a class that is not the product type or a derivative thereof
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployerTest.TestThrowOnEmployGenericClass">
            <summary>
              Tests whether the factory employer throws an exception when it is asked to
              employ a class that requires generic parameters for instantiation
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployerTest.TestEmployClassDerivedFromProduct">
            <summary>
              Tests whether the factory employer can employ a class derived from the product
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployerTest.TestEmployProduct">
            <summary>
              Tests whether the factory employer can employ the product class itself if it
              isn't abstract
            </summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.FactoryEmployerTest.Base">
            <summary>
              Abstract base class to serve as abstract product for testing the factory employer
            </summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.FactoryEmployerTest.Derived">
            <summary>
              Class derived from the abstract base to serve as concrete product for
              testing the factory employer
            </summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.FactoryEmployerTest.GenericDerived`1">
            <summary>
              Generic class derived from the abstract base to serve as concrete product
              for testing the factory employer
            </summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.FactoryEmployerTest.Unrelated">
            <summary>Unrelated class used to test the factory employer</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.IAssemblyLoader">
            <summary>Interface for an assembly loading helper</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.IAssemblyLoader.TryLoadFile(System.String,System.Reflection.Assembly@)">
            <summary>Tries to loads an assembly from a file</summary>
            <param name="path">Path to the file that is loaded as an assembly</param>
            <param name="loadedAssembly">
              Output parameter that receives the loaded assembly or null
            </param>
            <returns>True if the assembly was loaded successfully, otherwise false</returns>
        </member>
        <member name="T:Nuclex.Support.Plugins.InstanceEmployerTest">
            <summary>Unit Test for the instance employer class</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.InstanceEmployerTest.TestCanEmploy">
            <summary>
              Tests whether the instance employer can detect employable types
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.InstanceEmployerTest.TestThrowOnEmployAbstractClass">
            <summary>
              Tests whether the instance employer throws an exception when it is asked to
              employ an abstract class
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.InstanceEmployerTest.TestThrowOnEmployUnrelatedClass">
            <summary>
              Tests whether the instance employer throws an exception when it is asked to
              employ a class that is not the product type or a derivative thereof
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.InstanceEmployerTest.TestThrowOnEmployGenericClass">
            <summary>
              Tests whether the instance employer throws an exception when it is asked to
              employ a class that requires generic parameters for instantiation
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.InstanceEmployerTest.TestEmployClassDerivedFromProduct">
            <summary>
              Tests whether the instance employer can employ a class derived from the product
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.InstanceEmployerTest.TestEmployProduct">
            <summary>
              Tests whether the instance employer can employ the product class itself if it
              isn't abstract
            </summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.InstanceEmployerTest.Base">
            <summary>
              Abstract base class to serve as abstract product for testing the instance employer
            </summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.InstanceEmployerTest.Derived">
            <summary>
              Class derived from the abstract base to serve as concrete product for
              testing the instance employer
            </summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.InstanceEmployerTest.GenericDerived`1">
            <summary>
              Generic class derived from the abstract base to serve as concrete product
              for testing the instance employer
            </summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.InstanceEmployerTest.Unrelated">
            <summary>Unrelated class used to test the instance employer</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.NoPluginAttribute">
            <summary>Attribute that prevents a class from being seen by the PluginHost</summary>
            <remarks>
              When this attribute is attached to a class it will be invisible to the
              PluginHost and not become accessable as a plugin.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.NoPluginAttribute.#ctor">
            <summary>Initializes an instance of the NoPluginAttributes</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.FactoryEmployer`1">
            <summary>Employer to create factories of suiting types found in plugins</summary>
            <typeparam name="ProductType">
              Interface or base class that the types need to implement
            </typeparam>
            <remarks>
              <para>
                This employer will not directly instanciate any compatible types found in
                plugin assemblies, but generated runtime-factories of these types, enabling the
                user to decide when and how many instances of a type will be created.
              </para>
              <para>
                This approach has the advantage that it enables even assemblies that were not
                intended to be plugins can be loaded as plugins, without risking an instanciation
                or complex and possibly heavy-weight types. The disadvantage is that the
                runtime-factory can not provide decent informationa about the plugin type like
                a human-readable name, capabilities or an icon.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployer`1.#ctor">
            <summary>Initializes a new FactoryEmployer</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployer`1.CanEmploy(System.Type)">
            <summary>Determines whether the type suites the employer's requirements</summary>
            <param name="type">Type which will be assessed</param>
            <returns>True if the type can be employed</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployer`1.Employ(System.Type)">
            <summary>Employs the specified plugin type</summary>
            <param name="type">Type to be employed</param>
        </member>
        <member name="F:Nuclex.Support.Plugins.FactoryEmployer`1.employedFactories">
            <summary>All factories that the instance employer has created</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.FactoryEmployer`1.Factories">
            <summary>List of all factories that the instance employer has created</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.FactoryEmployer`1.ConcreteFactory">
            <summary>Concrete factory for the types in a plugin assembly</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployer`1.ConcreteFactory.#ctor(System.Type)">
            <summary>
              Initializes a factory and configures it for the specified product
            </summary>
            <param name="type">Type of which the factory creates instances</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployer`1.ConcreteFactory.CreateInstance">
            <summary>Create a new instance of the type the factory is configured to</summary>
            <returns>The newly created instance</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployer`1.ConcreteFactory.Nuclex#Support#Plugins#IAbstractFactory#CreateInstance">
            <summary>Create a new instance of the type the factory is configured to</summary>
            <returns>The newly created instance</returns>
        </member>
        <member name="F:Nuclex.Support.Plugins.FactoryEmployer`1.ConcreteFactory.concreteType">
            <summary>Concrete product which the factory instance creates</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.InstanceEmployer`1">
            <summary>Employer that directly creates instances of the types in a plugin</summary>
            <typeparam name="T">Interface or base class required for the employed types</typeparam>
            <remarks>
              <para>
                This employer directly creates an instance of any type in a plugin assembly that
                implements or is derived from the type the generic InstanceEmployer is instanced
                to. This is useful when the plugin user already has a special plugin interface
                through which additional informations about a plugin type can be queried or
                when actually exactly one instance per plugin type is wanted (think of the
                prototype pattern for example)
              </para>
              <para>
                Because this employer blindly creates an instance of any compatible type found
                in a plugin assembly it should be used with care. If big types with high
                construction time or huge memory requirements are loaded this can become
                a real resource hog. The intention of this employer was to let the plugin user
                define his own factory interface which possibly provides further details about
                the type the factory is reponsible for (like a description field). This
                factory would then be implemented on the plugin side.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.InstanceEmployer`1.#ctor">
            <summary>Initializes a new instance employer</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.InstanceEmployer`1.CanEmploy(System.Type)">
            <summary>Determines whether the type suites the employer's requirements</summary>
            <param name="type">Type that is checked for employability</param>
            <returns>True if the type can be employed</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.InstanceEmployer`1.Employ(System.Type)">
            <summary>Employs the specified plugin type</summary>
            <param name="type">Type to be employed</param>
        </member>
        <member name="F:Nuclex.Support.Plugins.InstanceEmployer`1.employedInstances">
            <summary>All instances employed by the instance employer</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.InstanceEmployer`1.Instances">
            <summary>All instances that have been employed</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.NoPluginAttributeTest">
            <summary>Unit Test for the no plugin attribute class</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.NoPluginAttributeTest.TestDefaultConstructor">
            <summary>
              Tests whether the default consturctor of the no plugin attribute works
            </summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginHelper">
            <summary>Supporting functions for the plugin classes</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHelper.HasDefaultConstructor(System.Type)">
            <summary>Determines whether the given type has a default constructor</summary>
            <param name="type">Type which is to be checked</param>
            <returns>True if the type has a default constructor</returns>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginHelperTest">
            <summary>Unit Test for the plugin helper class</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHelperTest.TestDefaultConstructorDetection">
            <summary>Tests whether the default constructor detection works as expected</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginHelperTest.NoDefaultConstructor">
            <summary>Test class that doesn't have a default constructor</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHelperTest.NoDefaultConstructor.#ctor(System.Int32)">
            <summary>Initializes a new instance of the test class</summary>
            <param name="dummy">Dummy argument so this is no default constructor</param>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginHelperTest.NonPublicDefaultConstructor">
            <summary>Test class that has a non-public default constructor</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHelperTest.NonPublicDefaultConstructor.#ctor">
            <summary>Initializes a new instance of the test class</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginHelperTest.PublicDefaultConstructor">
            <summary>Test class that has a public default constructor</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHelperTest.PublicDefaultConstructor.#ctor">
            <summary>Initializes a new instance of the test class</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginHost">
            <summary>Integration host for plugins</summary>
            <remarks>
              This class is created by the party that is interested in loading plugins,
              herein referred to as the "plugin user". The plugin host will monitor a
              repository and react to any assembly being loaded into that repository by
              iterating over all types (as in classes and structures) found in the
              assembly and using the employer to do whatever the plugin user intends 
              to do with the types found in that assembly
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHost.#ctor(Nuclex.Support.Plugins.Employer)">
            <summary>Initializes a plugin host using a new repository</summary>
            <param name="employer">Employer used assess and employ the plugin types</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHost.#ctor(Nuclex.Support.Plugins.Employer,Nuclex.Support.Plugins.PluginRepository)">
            <summary>Initializes the plugin using an existing repository</summary>
            <param name="employer">Employer used assess and employ the plugin types</param>
            <param name="repository">Repository in which plugins will be stored</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHost.assemblyLoadHandler(System.Object,System.AssemblyLoadEventArgs)">
            <summary>Responds to a new plugin being loaded into the repository</summary>
            <param name="sender">Repository into which the assembly was loaded</param>
            <param name="arguments">Event arguments; contains the loaded assembly</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHost.employAssemblyTypes(System.Reflection.Assembly)">
            <summary>Employs all employable types in an assembly</summary>
            <param name="assembly">Assembly whose types to assess and to employ</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHost.containsNoPluginAttribute(System.Object[])">
            <summary>
              Determines whether the specifies list of attributes contains a NoPluginAttribute
            </summary>
            <param name="attributes">List of attributes to check</param>
            <returns>True if the list contained a NoPluginAttribute, false otherwise</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHost.reportError(System.String)">
            <summary>Reports an error to the debugging console</summary>
            <param name="error">Error message that will be reported</param>
        </member>
        <member name="F:Nuclex.Support.Plugins.PluginHost.employer">
            <summary>Employs and manages types in the loaded plugin assemblies</summary>
        </member>
        <member name="F:Nuclex.Support.Plugins.PluginHost.repository">
            <summary>Repository containing all plugins loaded, shared with other hosts</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.PluginHost.Repository">
            <summary>The repository containing all loaded plugins</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.PluginHost.Employer">
            <summary>The employer that is used by this plugin integration host</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginHostTest">
            <summary>Unit Test for the plugin host class</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHostTest.TestSimpleConstructor">
            <summary>Tests whether the simple constructor is working</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHostTest.TestFullConstructor">
            <summary>Tests whether the full constructor is working</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHostTest.TestFullConstructorWithPreloadedAssembly">
            <summary>
              Tests whether the AddAssembly() method works by adding the test assembly
              itself to the repository
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHostTest.TestRepositoryStorage">
            <summary>
              Verifies that the plugin host correctly stores the provided repository
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHostTest.TestEmployerStorage">
            <summary>
              Verifies that the plugin host correctly stores the provided employer
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHostTest.TestAssemblyLoading">
            <summary>
              Tests whether the plugin host noticed when new assemblies are loaded into
              the repository
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHostTest.TestAssemblyLoadingWithEmployFailure">
            <summary>
              Tests whether the plugin host isolates the caller from an exception when the
              employer fails to employ a type in the assembly
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHostTest.TestAssemblyLoadingWithNoPluginAttribute">
            <summary>
              Verifies that the plugin host ignores types which have the NoPluginAttribute
              assigned to them
            </summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginHostTest.FailingEmployer">
            <summary>Employer that unexpectedly fails to employ a given type</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHostTest.FailingEmployer.Employ(System.Type)">
            <summary>Employs the specified plugin type</summary>
            <param name="type">Type to be employed</param>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginRepository">
            <summary>Stores loaded plugins</summary>
            <remarks>
              This class manages a set of assemblies that have been dynamically loaded 
              as plugins. It usually is shared by multiple PluginHosts that handle
              different interfaces of one plugin type.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.#ctor">
            <summary>Initializes a new instance of the plugin repository</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.#ctor(Nuclex.Support.Plugins.IAssemblyLoader)">
            <summary>Initializes a new instance of the plugin repository</summary>
            <param name="loader">
              Loader to use for loading assemblies into this repository
            </param>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.AddFiles(System.String)">
            <summary>Loads all plugins matching a wildcard specification</summary>
            <param name="wildcard">Path of one or more plugins via wildcard</param>
            <remarks>
              This function always assumes that a plugin is optional. This means that
              even when you specify a unique file name and a matching file is not found,
              no exception will be raised and the error is silently ignored.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.AddAssembly(System.Reflection.Assembly)">
            <summary>Adds the specified assembly to the repository</summary>
            <remarks>
              Also used internally, so any assembly that is to be put into the repository,
              not matter how, wanders through this method
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.reportError(System.String)">
            <summary>Reports an error to the debugging console</summary>
            <param name="error">Error message that will be reported</param>
        </member>
        <member name="F:Nuclex.Support.Plugins.PluginRepository.assemblies">
            <summary>Loaded plugin assemblies</summary>
        </member>
        <member name="F:Nuclex.Support.Plugins.PluginRepository.assemblyLoader">
            <summary>Takes care of loading assemblies for the repositories</summary>
        </member>
        <member name="E:Nuclex.Support.Plugins.PluginRepository.AssemblyLoaded">
            <summary>Triggered whenever a new assembly is loaded into this repository</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.PluginRepository.LoadedAssemblies">
            <summary>List of all loaded plugin assemblies in the repository</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginRepository.DefaultAssemblyLoader">
            <summary>Default assembly loader used to read assemblies from files</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.DefaultAssemblyLoader.#ctor">
            <summary>Initializes a new default assembly loader</summary>
            <remarks>
              Made protected to provide users with a small incentive for using
              the Instance property instead of creating new instances all around.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.DefaultAssemblyLoader.LoadAssemblyFromFile(System.String)">
            <summary>Loads an assembly from a file system path</summary>
            <param name="path">Path the assembly will be loaded from</param>
            <returns>The loaded assembly</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.DefaultAssemblyLoader.TryLoadFile(System.String,System.Reflection.Assembly@)">
            <summary>Tries to loads an assembly from a file</summary>
            <param name="path">Path to the file that is loaded as an assembly</param>
            <param name="loadedAssembly">
              Output parameter that receives the loaded assembly or null
            </param>
            <returns>True if the assembly was loaded successfully, otherwise false</returns>
        </member>
        <member name="F:Nuclex.Support.Plugins.PluginRepository.DefaultAssemblyLoader.Instance">
            <summary>The only instance of the DefaultAssemblyLoader</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginRepositoryTest">
            <summary>Unit Test for the plugin repository class</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepositoryTest.TestDefaultConstructor">
            <summary>
              Tests whether the default constructor of the plugin repository class works
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepositoryTest.TestAddFilesWithZeroMatches">
            <summary>
              Tests whether the AddFiles() method accepts a file mask to which there are
              no matching files
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepositoryTest.TestAddFilesWithOwnAssembly">
            <summary>
              Tests whether the AddFiles() method accepts a file mask to which there is
              exactly one matching file
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepositoryTest.TestAddAssembly">
            <summary>
              Tests whether the AddAssembly() method works by adding the test assembly
              itself to the repository
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepositoryTest.TestAssemblyLoadedEvent">
            <summary>
              Tests whether the AddAssembly() method works by adding the test assembly
              itself to the repository
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepositoryTest.TestDllNotFoundExceptionDuringAssemblyLoad">
            <summary>
              Verifies that no exceptions come through when a DllNotFoundException is thrown
              during assembly loading
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepositoryTest.TestUnauthorizedAccessExceptionDuringAssemblyLoad">
            <summary>
              Verifies that no exceptions come through when a UnauthorizedAccessException is
              thrown during assembly loading
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepositoryTest.TestBadImageFormatExceptionDuringAssemblyLoad">
            <summary>
              Verifies that no exceptions come through when a BadImageFormatException is
              thrown during assembly loading
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepositoryTest.TestIOExceptionDuringAssemblyLoad">
            <summary>
              Verifies that no exceptions come through when an IOException is
              thrown during assembly loading
            </summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepositoryTest.mockSubscriber(NMock2.Mockery,Nuclex.Support.Plugins.PluginRepository)">
            <summary>Mocks a subscriber for the events of a plugin repository</summary>
            <param name="mockery">Mockery to create an event subscriber in</param>
            <param name="repository">Repository to subscribe the mocked subscriber to</param>
            <returns>The mocked event subscriber</returns>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginRepositoryTest.IAssemblyLoadedSubscriber">
            <summary>Interface used to test the progress tracker</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepositoryTest.IAssemblyLoadedSubscriber.AssemblyLoaded(System.Object,System.AssemblyLoadEventArgs)">
            <summary>
              Represents the method that handles the System.AppDomain.AssemblyLoad event
              of an System.AppDomain
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="arguments">
              An System.AssemblyLoadEventArgs that contains the event data
            </param>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginRepositoryTest.TestAssemblyLoader">
            <summary>Special assembly loader for the unit test</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepositoryTest.TestAssemblyLoader.LoadAssemblyFromFile(System.String)">
            <summary>Loads an assembly from a file system path</summary>
            <param name="path">Path the assembly will be loaded from</param>
            <returns>The loaded assembly</returns>
        </member>
        <member name="T:Nuclex.Support.Scheduling.AbortedException">
            <summary>Indicates that an operation has been forcefully aborted</summary>
            <remarks>
              This exception is the typical result of using AsyncAbort() on a running
              background process. 
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.AbortedException.#ctor">
            <summary>Initializes the exception</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.AbortedException.#ctor(System.String)">
            <summary>Initializes the exception with an error message</summary>
            <param name="message">Error message describing the cause of the exception</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.AbortedException.#ctor(System.String,System.Exception)">
            <summary>Initializes the exception as a followup exception</summary>
            <param name="message">Error message describing the cause of the exception</param>
            <param name="inner">Preceding exception that has caused this exception</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.AbortedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Initializes the exception from its serialized state</summary>
            <param name="info">Contains the serialized fields of the exception</param>
            <param name="context">Additional environmental informations</param>
        </member>
        <member name="T:Nuclex.Support.Scheduling.AbortedExceptionTest">
            <summary>Unit Test for the AbortedException class</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.AbortedExceptionTest.TestDefaultConstructor">
            <summary>
              Verifies that the exception's default constructor is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.AbortedExceptionTest.TestInnerException">
            <summary>
              Checks whether the exception correctly stores its inner exception
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.AbortedExceptionTest.TestSerialization">
            <summary>
              Test whether the exception can be serialized
            </summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.IAbortable">
            <summary>Interface for abortable processes</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.IAbortable.AsyncAbort">
            <summary>Aborts the running process. Can be called from any thread.</summary>
            <remarks>
              The receive should honor the abort request and stop whatever it is
              doing as soon as possible. The method does not impose any requirement
              on the timeliness of the reaction of the running process, but implementers
              are advised to not ignore the abort request and urged to try and design
              their code in such a way that it can be stopped in a reasonable time
              (eg. within 1 second of the abort request).
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Scheduling.Operation">
            <summary>Base class for observable operations running in the background</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.Request">
            <summary>Asynchronous request running in the background</summary>
            <remarks>
              <para>
                If the background process fails, the exception that caused it to fail is
                communicated to all parties waiting on the Request through the Join()
                method. Implementers should store any errors occuring in the asynchronous
                parts of their code in a try..catch block (or avoid throwing and just
                store a new exception) and re-throw them when in ReraiseExceptions()
              </para>
              <para>
                Like in the transaction class, the contract requires you to always call
                OnAsyncEnded(), no matter what the outcome of your operation is.
              </para>
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Tracking.Transaction">
            <summary>Base class for background processes the user can wait on</summary>
            <remarks>
              <para>
                By encapsulating long-running operations which will ideally be running in
                a background thread in a class that's derived from <see cref="T:Nuclex.Support.Tracking.Transaction"/>
                you can wait for the completion of the operation and optionally even receive
                feedback on the achieved progress. This is useful for displaying a progress
                bar, loading screen or some other means of entertaining the user while he
                waits for the task to complete.
              </para>
              <para>
                You can register callbacks which will be fired once the <see cref="T:Nuclex.Support.Tracking.Transaction"/>
                task has completed. This class deliberately does not provide an Execute()
                method or anything similar to clearly seperate the initiation of an operation
                from just monitoring it. By omitting an Execute() method, it also becomes
                possible to construct a transaction just-in-time when it is explicitely being
                asked for.
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Tracking.Transaction.EndedDummy">
            <summary>A dummy transaction that's always in the 'ended' state</summary>
            <remarks>
              Useful if an operation is already complete when it's being asked for or
              when a transaction that's lazily created is accessed after the original
              operation has ended already.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.Transaction.Wait">
            <summary>Waits until the background process finishes</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Transaction.Wait(System.TimeSpan)">
            <summary>Waits until the background process finishes or a timeout occurs</summary>
            <param name="timeout">
              Time span after which to stop waiting and return immediately
            </param>
            <returns>
              True if the background process completed, false if the timeout was reached
            </returns>
        </member>
        <member name="M:Nuclex.Support.Tracking.Transaction.Wait(System.Int32)">
            <summary>Waits until the background process finishes or a timeout occurs</summary>
            <param name="timeoutMilliseconds">
              Number of milliseconds after which to stop waiting and return immediately
            </param>
            <returns>
              True if the background process completed, false if the timeout was reached
            </returns>
        </member>
        <member name="M:Nuclex.Support.Tracking.Transaction.OnAsyncEnded">
            <summary>Fires the AsyncEnded event</summary>
            <remarks>
              <para>
                This event should be fired by the implementing class when its work is completed.
                It's of no interest to this class whether the outcome of the process was
                successfull or not, the outcome and results of the process taking place both
                need to be communicated seperately.
              </para>
              <para>
                Calling this method is mandatory. Implementers need to take care that
                the OnAsyncEnded() method is called on any instance of transaction that's
                being created. This method also must not be called more than once.
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Tracking.Transaction.endedEventSubscribers">
            <summary>Event handlers which have subscribed to the ended event</summary>
            <remarks>
              Does not need to be volatile since it's only accessed inside 
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Tracking.Transaction.ended">
            <summary>Whether the operation has completed yet</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.Transaction.doneEvent">
            <summary>Event that will be set when the transaction is completed</summary>
            <remarks>
              This event is will only be created when it is specifically asked for using
              the WaitHandle property.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Tracking.Transaction.AsyncEnded">
            <summary>Will be triggered when the transaction has ended</summary>
            <remarks>
              If the process is already finished when a client registers to this event,
              the registered callback will be invoked synchronously right when the
              registration takes place.
            </remarks>
        </member>
        <member name="P:Nuclex.Support.Tracking.Transaction.Ended">
            <summary>Whether the transaction has ended already</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.Transaction.WaitHandle">
            <summary>WaitHandle that can be used to wait for the transaction to end</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.Transaction.EndedDummyTransaction">
            <summary>Dummy transaction which always is in the 'ended' state</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Transaction.EndedDummyTransaction.#ctor">
            <summary>Initializes a new ended dummy transaction</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.Request.SucceededDummy">
            <summary>Succeeded dummy request</summary>
            <remarks>
              Use to indicate success if the request has already been completed at
              the time you are asked to perform it.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request.CreateFailedDummy(System.Exception)">
            <summary>Creates a new failed dummy request</summary>
            <param name="exception">Exception that supposedly caused the request to fail</param>
            <returns>
              A failed request that reports the provided exception as cause for its failure
            </returns>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request.Join">
            <summary>Waits for the background operation to end</summary>
            <remarks>
              Any exceptions raised in the background operation will be thrown
              in this method. If you decide to override this method, you should
              call Wait() first (and let any possible exception through to your
              caller).
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request.ReraiseExceptions">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.Request.EndedDummyRequest">
            <summary>Dummy request that is always in the ended state</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request.EndedDummyRequest.#ctor">
            <summary>Creates a new successfully completed dummy request</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request.EndedDummyRequest.#ctor(System.Exception)">
            <summary>Creates a new failed dummy request</summary>
            <param name="exception">Exception that caused the dummy to fail</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request.EndedDummyRequest.ReraiseExceptions">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.Request.EndedDummyRequest.exception">
            <summary>Exception that supposedly caused the request to fail</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Operation.Start">
            <summary>Launches the background operation</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.OperationTest">
            <summary>Unit Test for the operation class</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationTest.TestOperationStarting">
            <summary>Tests whether operations can be started</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.OperationTest.TestOperation">
            <summary>Dummy operation used to run the unit tests</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationTest.TestOperation.Start">
            <summary>Launches the background operation</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.OperationQueue`1">
            <summary>Operation that sequentially executes a series of operations</summary>
            <typeparam name="OperationType">
              Type of the child operations the QueueOperation will contain
            </typeparam>
        </member>
        <member name="T:Nuclex.Support.Tracking.IProgressReporter">
            <summary>Interface for processes that report their progress</summary>
        </member>
        <member name="E:Nuclex.Support.Tracking.IProgressReporter.AsyncProgressChanged">
            <summary>Triggered when the status of the process changes</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Initializes a new queue operation with default weights</summary>
            <param name="childs">Child operations to execute in this operation</param>
            <remarks>
              All child operations will have a default weight of 1.0
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.#ctor(System.Collections.Generic.IEnumerable{Nuclex.Support.Tracking.WeightedTransaction{`0}})">
            <summary>Initializes a new queue operation with custom weights</summary>
            <param name="childs">Child operations to execute in this operation</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.#ctor">
            <summary>Initializes a new queue operation</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.Start">
            <summary>Launches the background operation</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.ReraiseExceptions">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.OnAsyncProgressChanged(System.Single)">
            <summary>Fires the progress update event</summary>
            <param name="progress">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this transaction about the achieved progress.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.OnAsyncProgressChanged(Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Fires the progress update event</summary>
            <param name="eventArguments">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this transaction about the achieved progress.
              Allows for classes derived from the transaction class to easily provide
              a custom event arguments class that has been derived from the
              transaction's ProgressUpdateEventArgs class.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.startCurrentOperation">
            <summary>Prepares the current operation and calls its Start() method</summary>
            <remarks>
              This subscribes the queue to the events of to the current operation
              and launches the operation by calling its Start() method.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.endCurrentOperation">
            <summary>Disconnects from the current operation and calls its End() method</summary>
            <remarks>
              This unsubscribes the queue from the current operation's events, calls End()
              on the operation and, if the operation didn't have an exception to report,
              counts up the accumulated progress of th  e queue.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.asyncOperationEnded(System.Object,System.EventArgs)">
            <summary>Called when the current executing operation ends</summary>
            <param name="sender">Operation that ended</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.asyncOperationProgressChanged(System.Object,Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Called when currently executing operation makes progress</summary>
            <param name="sender">Operation that has achieved progress</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.asyncOperationEndedDelegate">
            <summary>Delegate to the asyncOperationEnded() method</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.asyncOperationProgressChangedDelegate">
            <summary>Delegate to the asyncOperationProgressUpdated() method</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.children">
            <summary>Operations being managed in the queue</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.totalWeight">
            <summary>Summed weight of all operations in the queue</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.completedWeight">
            <summary>Accumulated weight of the operations already completed</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.currentOperationIndex">
            <summary>Index of the operation currently executing</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.completionStatus">
            <summary>Used to detect when an operation completes synchronously</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.exception">
            <summary>Exception that has occured in the background process</summary>
        </member>
        <member name="E:Nuclex.Support.Scheduling.OperationQueue`1.AsyncProgressChanged">
            <summary>will be triggered to report when progress has been achieved</summary>
        </member>
        <member name="P:Nuclex.Support.Scheduling.OperationQueue`1.Children">
            <summary>Provides access to the child operations of this queue</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.OperationQueueTest">
            <summary>Unit Test for the operation queue class</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.Setup">
            <summary>Initialization routine executed before each test is run</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.TestSequentialExecution">
            <summary>Validates that the queue executes operations sequentially</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.TestWeightedSequentialExecution">
            <summary>
              Validates that the queue executes operations sequentially and honors the weights
              assigned to the individual operations
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.TestEndPropagation">
            <summary>
              Validates that the operation queue propagates the ended event once all contained
              operations have completed
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.TestExceptionPropagation">
            <summary>
              Validates that the operation queue delivers an exception occuring in one of the
              contained operations to the operation queue joiner
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.TestTransparentWrapping">
            <summary>
              Ensures that the operation queue transparently wraps the child operations in
              an observation wrapper that is not visible to an outside user
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.mockSubscriber(Nuclex.Support.Scheduling.Operation)">
            <summary>Mocks a subscriber for the events of an operation</summary>
            <param name="operation">Operation to mock an event subscriber for</param>
            <returns>The mocked event subscriber</returns>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueueTest.mockery">
            <summary>Mock object factory</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.OperationQueueTest.IOperationQueueSubscriber">
            <summary>Interface used to test the operation queue</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.IOperationQueueSubscriber.ProgressChanged(System.Object,Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Called when the operations queue's progress changes</summary>
            <param name="sender">Operation queue whose progress has changed</param>
            <param name="arguments">Contains the new progress achieved</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.IOperationQueueSubscriber.Ended(System.Object,System.EventArgs)">
            <summary>Called when the operation queue has ended</summary>
            <param name="sender">Operation queue that as ended</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="T:Nuclex.Support.Scheduling.OperationQueueTest.ProgressUpdateEventArgsMatcher">
            <summary>Compares two ProgressUpdateEventArgsInstances for NMock validation</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.ProgressUpdateEventArgsMatcher.#ctor(Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Initializes a new ProgressUpdateEventArgsMatcher </summary>
            <param name="expected">Expected progress update event arguments</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.ProgressUpdateEventArgsMatcher.Matches(System.Object)">
            <summary>
              Called by NMock to verfiy the ProgressUpdateEventArgs match the expected value
            </summary>
            <param name="actualAsObject">Actual value to compare to the expected value</param>
            <returns>
              True if the actual value matches the expected value; otherwise false
            </returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.ProgressUpdateEventArgsMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>Creates a string representation of the expected value</summary>
            <param name="writer">Writer to write the string representation into</param>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueueTest.ProgressUpdateEventArgsMatcher.expected">
            <summary>Expected progress update event args value</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.OperationQueueTest.TestOperation">
            <summary>Operation used for testing in this unit test</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.TestOperation.Start">
            <summary>Begins executing the operation. Yeah, sure :)</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.TestOperation.SetEnded">
            <summary>Moves the operation into the ended state</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.TestOperation.SetEnded(System.Exception)">
            <summary>Moves the operation into the ended state with an exception</summary>
            <param name="exception">Exception</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.TestOperation.ChangeProgress(System.Single)">
            <summary>Changes the testing operation's indicated progress</summary>
            <param name="progress">
              New progress to be reported by the testing operation
            </param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.TestOperation.ReraiseExceptions">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.TestOperation.OnAsyncProgressChanged(System.Single)">
            <summary>Fires the progress update event</summary>
            <param name="progress">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this operation about the achieved progress.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueueTest.TestOperation.OnAsyncProgressChanged(Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Fires the progress update event</summary>
            <param name="eventArguments">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this operation about the achieved progress.
              Allows for classes derived from the Operation class to easily provide
              a custom event arguments class that has been derived from the
              operation's ProgressUpdateEventArgs class.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueueTest.TestOperation.exception">
            <summary>Exception that has occured in the background process</summary>
        </member>
        <member name="E:Nuclex.Support.Scheduling.OperationQueueTest.TestOperation.AsyncProgressChanged">
            <summary>will be triggered to report when progress has been achieved</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.ThreadCallbackOperation">
            <summary>Operation that executes a method in a background thread</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.ThreadOperation">
            <summary>Operation that executes a method in a background thread</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.#ctor">
            <summary>
              Initializes a new threaded operation.
            </summary>
            <remarks>
              Uses a ThreadPool thread to execute the method in a background thread.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.#ctor(System.Boolean)">
            <summary>
              Initializes a new threaded operation which optionally uses the ThreadPool.
            </summary>
            <param name="useThreadPool">Whether to use a ThreadPool thread.</param>
            <remarks>
              If useThreadPool is false, a new thread will be created. This guarantees
              that the method will be executed immediately but has an impact on
              performance since the creation of new threads is not a cheap operation.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.Start">
            <summary>Launches the background operation</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.Execute">
            <summary>Contains the payload to be executed in the background thread</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.callMethod(System.Object)">
            <summary>Invokes the delegate passed as an argument</summary>
            <param name="state">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.callMethod">
            <summary>Invokes the delegate passed as an argument</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.ReraiseExceptions">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.ThreadOperation.useThreadPool">
            <summary>Whether to use the ThreadPool for obtaining a background thread</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.ThreadOperation.exception">
            <summary>Exception that has occured in the background process</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadCallbackOperation.#ctor(System.Threading.ThreadStart)">
            <summary>
              Initializes a new threaded method operation that will call back a
              parameterless method from the background thread.
            </summary>
            <param name="method">Method to be invoked in a background thread</param>
            <remarks>
              Uses a ThreadPool thread to execute the method in
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadCallbackOperation.#ctor(System.Threading.ThreadStart,System.Boolean)">
            <summary>
              Initializes a new threaded method operation that will call back a
              parameterless method from the background thread and use the
              thread pool optionally.
            </summary>
            <param name="method">Method to be invoked in a background thread</param>
            <param name="useThreadPool">Whether to use a ThreadPool thread</param>
            <remarks>
              If useThreadPool is false, a new thread will be created. This guarantees
              that the method will be executed immediately but has an impact on
              performance since the creation of new threads is not a cheap operation.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadCallbackOperation.Execute">
            <summary>Executes the thread callback in the background thread</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.ThreadCallbackOperation.method">
            <summary>Method to be invoked in a background thread</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.ThreadCallbackOperationTest">
            <summary>Unit Test for the thread callback operation class</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadCallbackOperationTest.TestDefaultConstructor">
            <summary>Verifies that the default constructor for a thread operation works</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadCallbackOperationTest.TestExecutionInThreadPool">
            <summary>
              Verifies that the threaded operation can execute in a thread pool thread
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadCallbackOperationTest.TestExecutionInExplicitThread">
            <summary>
              Verifies that the threaded operation can execute in an explicit thread
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadCallbackOperationTest.TestForwardExceptionFromThreadPool">
            <summary>
              Verifies that the threaded operation forwards an exception that occurred in
              a thread pool thread.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadCallbackOperationTest.TestForwardExceptionFromExplicitThread">
            <summary>
              Verifies that the threaded operation forwards an exception that occurred in
              an explicit thread.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadCallbackOperationTest.errorCallback">
            <summary>
              Callback which throws an exception to simulate an error during callback execution
            </summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.ThreadCallbackOperationTest.TestCallbackProvider">
            <summary>
              Provides a test callback for unit testing the thread callback operation
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadCallbackOperationTest.TestCallbackProvider.Callback">
            <summary>Method that can be invoked as a callback</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.ThreadCallbackOperationTest.TestCallbackProvider.called">
            <summary>Set to true when the callback has been called</summary>
        </member>
        <member name="P:Nuclex.Support.Scheduling.ThreadCallbackOperationTest.TestCallbackProvider.Called">
            <summary>Whether the callback has been called</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.ThreadOperationTest">
            <summary>Unit Test for the thread operation class</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperationTest.TestDefaultConstructor">
            <summary>Verifies that the default constructor for a thread operation works</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperationTest.TestExecutionInThreadPool">
            <summary>
              Verifies that the threaded operation can execute in a thread pool thread
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperationTest.TestExecutionInExplicitThread">
            <summary>
              Verifies that the threaded operation can execute in an explicit thread
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperationTest.TestForwardExceptionFromThreadPool">
            <summary>
              Verifies that the threaded operation forwards an exception that occurred in
              a thread pool thread.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperationTest.TestForwardExceptionFromExplicitThread">
            <summary>
              Verifies that the threaded operation forwards an exception that occurred in
              an explicit thread.
            </summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.ThreadOperationTest.TestThreadOperation">
            <summary>Dummy operation used to run the unit tests</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperationTest.TestThreadOperation.#ctor">
            <summary>Initializes a dummy operation</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperationTest.TestThreadOperation.#ctor(System.Boolean)">
            <summary>Initializes a dummy operation</summary>
            <param name="useThreadPool">Whether to use a ThreadPool thread.</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperationTest.TestThreadOperation.Execute">
            <summary>Contains the payload to be executed in the background thread</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.ThreadOperationTest.FailingThreadOperation">
            <summary>Dummy operation used to run the unit tests</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperationTest.FailingThreadOperation.#ctor(System.Boolean)">
            <summary>Initializes a dummy operation</summary>
            <param name="useThreadPool">Whether to use a ThreadPool thread.</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperationTest.FailingThreadOperation.Execute">
            <summary>Contains the payload to be executed in the background thread</summary>
        </member>
        <member name="T:Nuclex.Support.Shared`1">
            <summary>Manages a globally shared instance of the given Type</summary>
            <typeparam name="SharedType">
              Type of which a globally shared instance will be provided
            </typeparam>
        </member>
        <member name="F:Nuclex.Support.Shared`1.instance">
            <summary>Stored the globally shared instance</summary>
        </member>
        <member name="P:Nuclex.Support.Shared`1.Instance">
            <summary>Returns the global instance of the class</summary>
        </member>
        <member name="T:Nuclex.Support.SharedTest">
            <summary>Unit Test for the shared instance provider class</summary>
        </member>
        <member name="M:Nuclex.Support.SharedTest.TestSameInstance">
            <summary>
              Verifies that the shared instance provider returns the same instance of a class
              when asked for the same class twice.
            </summary>
        </member>
        <member name="T:Nuclex.Support.SharedTest.Dummy">
            <summary>Dummy class for testing the shared instance provider</summary>
        </member>
        <member name="M:Nuclex.Support.SharedTest.Dummy.#ctor">
            <summary>Initializes a new dummy</summary>
        </member>
        <member name="T:Nuclex.Support.IO.ChainStream">
            <summary>Chains a series of independent streams into a single stream</summary>
            <remarks>
              <para>
                This class can be used to chain multiple independent streams into a single
                stream that acts as if its chained streams were only one combined stream.
                It is useful to avoid creating huge memory streams or temporary files when
                you just need to prepend or append some data to a stream or if you need to
                read a file that was split into several parts as if it was a single file.
              </para>
              <para>
                It is not recommended to change the size of any chained stream after it
                has become part of a stream chainer, though the stream chainer will do its
                best to cope with the changes as they occur. Increasing the length of a
                chained stream is generally not an issue for streams that support seeking,
                but reducing the length might invalidate the stream chainer's file pointer,
                resulting in an IOException when Read() or Write() is next called.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.#ctor(System.IO.Stream[])">
            <summary>Initializes a new stream chainer</summary>
            <param name="streams">Array of streams that will be chained together</param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.Flush">
            <summary>
              Clears all buffers for this stream and causes any buffered data to be written
              to the underlying device.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Reads a sequence of bytes from the stream and advances the position of
              the file pointer by the number of bytes read.
            </summary>
            <param name="buffer">Buffer that will receive the data read from the stream</param>
            <param name="offset">
              Offset in the buffer at which the stream will place the data read
            </param>
            <param name="count">Maximum number of bytes that will be read</param>
            <returns>
              The number of bytes that were actually read from the stream and written into
              the provided buffer
            </returns>
            <exception cref="T:System.NotSupportedException">
              The chained stream at the current position does not support reading
            </exception>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Changes the position of the file pointer</summary>
            <param name="offset">
              Offset to move the file pointer by, relative to the position indicated by
              the <paramref name="origin" /> parameter.
            </param>
            <param name="origin">
              Reference point relative to which the file pointer is placed
            </param>
            <returns>The new absolute position within the stream</returns>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.SetLength(System.Int64)">
            <summary>Changes the length of the stream</summary>
            <param name="value">New length the stream shall have</param>
            <exception cref="T:System.NotSupportedException">
              Always, the stream chainer does not support the SetLength() operation
            </exception>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Writes a sequence of bytes to the stream and advances the position of
              the file pointer by the number of bytes written.
            </summary>
            <param name="buffer">
              Buffer containing the data that will be written to the stream
            </param>
            <param name="offset">
              Offset in the buffer at which the data to be written starts
            </param>
            <param name="count">Number of bytes that will be written into the stream</param>
            <remarks>
              The behavior of this method is as follows: If one or more chained streams
              do not support seeking, all data is appended to the final stream in the
              chain. Otherwise, writing will begin with the stream the current file pointer
              offset falls into. If the end of that stream is reached, writing continues
              in the next stream. On the last stream, writing more data into the stream
              that it current size allows will enlarge the stream.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.moveFilePointer(System.Int64)">
            <summary>Moves the file pointer</summary>
            <param name="position">New position the file pointer will be moved to</param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.findStreamIndexAndOffset(System.Int64,System.Int32@,System.Int64@)">
            <summary>
              Finds the stream index and local offset for an absolute position within
              the combined streams.
            </summary>
            <param name="overallPosition">Absolute position within the combined streams</param>
            <param name="streamIndex">
              Index of the stream the overall position falls into
            </param>
            <param name="streamPosition">
              Local position within the stream indicated by <paramref name="streamIndex" />
            </param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.determineCapabilities">
            <summary>Determines the capabilities of the chained streams</summary>
            <remarks>
              <para>
                Theoretically, it would be possible to create a stream chainer that supported
                writing only when the file pointer was on a chained stream with write support,
                that could seek within the beginning of the stream until the first chained
                stream with no seek capability was encountered and so on.
              </para>
              <para>
                However, the interface of the Stream class requires us to make a definitive
                statement as to whether the Stream supports seeking, reading and writing.
                We can't return "maybe" or "mostly" in CanSeek, so the only sane choice that
                doesn't violate the Stream interface is to implement these capabilities as
                all or nothing - either all streams support a feature, or the stream chainer
                will report the feature as unsupported.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.makeSeekNotSupportedException(System.String)">
            <summary>
              Constructs a NotSupportException for an error caused by one of the chained
              streams having no seek support
            </summary>
            <param name="action">Action that was tried to perform</param>
            <returns>The newly constructed NotSupportedException</returns>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.streams">
            <summary>Streams that have been chained together</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.position">
            <summary>Current position of the overall file pointer</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.activeReadStreamIndex">
            <summary>Stream we're currently reading from if seeking is not supported</summary>
            <remarks>
              If seeking is not supported, the stream chainer will read from each stream
              until the end was reached
              sequentially
            </remarks>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.activeReadStreamPosition">
            <summary>Position in the current read stream if seeking is not supported</summary>
            <remarks>
              If there is a mix of streams supporting seeking and not supporting seeking, we
              need to keep track of the read index for those streams that do. If, for example,
              the last stream is written to and read from in succession, the file pointer
              of that stream would have been moved to the end by the write attempt, skipping
              data that should have been read in the following read attempt.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.allStreamsCanSeek">
            <summary>Whether all of the chained streams support seeking</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.allStreamsCanRead">
            <summary>Whether all of the chained streams support reading</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.allStreamsCanWrite">
            <summary>Whether all of the chained streams support writing</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.CanRead">
            <summary>Whether data can be read from the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.CanSeek">
            <summary>Whether the stream supports seeking</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.CanWrite">
            <summary>Whether data can be written into the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.Length">
            <summary>Length of the stream in bytes</summary>
            <exception cref="T:System.NotSupportedException">
              At least one of the chained streams does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.Position">
            <summary>Absolute position of the file pointer within the stream</summary>
            <exception cref="T:System.NotSupportedException">
              At least one of the chained streams does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.ChainedStreams">
            <summary>Streams being combined by the stream chainer</summary>
        </member>
        <member name="T:Nuclex.Support.IO.ChainStreamTest">
            <summary>Unit Test for the stream chainer</summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestPartitionedWrite">
            <summary>
              Tests whether the stream chainer correctly partitions a long write request
              over its chained streams and appends any remaining data to the end of
              the last chained stream.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestPartitionedRead">
            <summary>
              Tests whether the stream chainer correctly partitions a long read request
              over its chained streams.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestWriteAfterResize">
            <summary>
              Tests whether the stream chainer can handle a stream resize
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestWriteToUnseekableStream">
            <summary>
              Tests writing to a stream chainer that contains an unseekable stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestReadFromUnseekableStream">
            <summary>
              Tests reading from a stream chainer that contains an unseekable stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnReadFromUnreadableStream">
            <summary>
              Tests reading from a stream chainer that contains an unreadable stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnWriteToUnwriteableStream">
            <summary>
              Tests writing to a stream chainer that contains an unwriteable stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnLengthChange">
            <summary>
              Verifies that the stream chainer throws an exception if the attempt is
              made to change the length of the stream
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestCanRead">
            <summary>
              Verifies that the CanRead property is correctly determined by the stream chainer
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestCanWrite">
            <summary>
              Verifies that the CanRead property is correctly determined by the stream chainer
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestCanSeek">
            <summary>
              Verifies that the CanSeek property is correctly determined by the stream chainer
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnSeekWithUnseekableStream">
            <summary>
              Tests whether an exception is thrown if the Seek() method is called on
              a stream chainer with streams that do not support seeking
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnGetPositionWithUnseekableStream">
            <summary>
              Tests whether an exception is thrown if the Position property is retrieved
              on a stream chainer with streams that do not support seeking
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnSetPositionWithUnseekableStream">
            <summary>
              Tests whether an exception is thrown if the Position property is set
              on a stream chainer with streams that do not support seeking
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnGetLengthWithUnseekableStream">
            <summary>
              Tests whether an exception is thrown if the Length property is retrieved
              on a stream chainer with streams that do not support seeking
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestSeeking">
            <summary>
              Tests whether the Seek() method of the stream chainer is working
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestReadBeyondEndOfStream">
            <summary>
              Tests whether the stream behaves correctly if data is read from beyond its end
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestThrowOnInvalidSeekReferencePoint">
            <summary>
              Tests whether the Seek() method throws an exception if an invalid
              reference point is provided
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestPositionChange">
            <summary>Verifies that the position property works correctly</summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestFlush">
            <summary>Tests the Flush() method of the stream chainer</summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.chainTwoStreamsOfTenBytes">
            <summary>
              Creates a stream chainer with two streams that each have a size of 10 bytes
            </summary>
            <returns>The new stream chainer with two chained 10-byte streams</returns>
        </member>
        <member name="T:Nuclex.Support.IO.ChainStreamTest.TestStream">
            <summary>Testing stream that allows specific features to be disabled</summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.#ctor(System.IO.Stream,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Initializes a new test stream</summary>
            <param name="wrappedStream">Stream that will be wrapped</param>
            <param name="allowRead">Whether to allow reading from the stream</param>
            <param name="allowWrite">Whether to allow writing to the stream</param>
            <param name="allowSeek">Whether to allow seeking within the stream</param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.Flush">
            <summary>
              Clears all buffers for this stream and causes any buffered data to be written
              to the underlying device.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Reads a sequence of bytes from the stream and advances the position of
              the file pointer by the number of bytes read.
            </summary>
            <param name="buffer">Buffer that will receive the data read from the stream</param>
            <param name="offset">
              Offset in the buffer at which the stream will place the data read
            </param>
            <param name="count">Maximum number of bytes that will be read</param>
            <returns>
              The number of bytes that were actually read from the stream and written into
              the provided buffer
            </returns>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Changes the position of the file pointer</summary>
            <param name="offset">
              Offset to move the file pointer by, relative to the position indicated by
              the <paramref name="origin" /> parameter.
            </param>
            <param name="origin">
              Reference point relative to which the file pointer is placed
            </param>
            <returns>The new absolute position within the stream</returns>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.SetLength(System.Int64)">
            <summary>Changes the length of the stream</summary>
            <param name="value">New length the stream shall have</param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Writes a sequence of bytes to the stream and advances the position of
              the file pointer by the number of bytes written.
            </summary>
            <param name="buffer">
              Buffer containing the data that will be written to the stream
            </param>
            <param name="offset">
              Offset in the buffer at which the data to be written starts
            </param>
            <param name="count">Number of bytes that will be written into the stream</param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.enforceReadAllowed">
            <summary>Throws an exception if reading is not allowed</summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.enforceWriteAllowed">
            <summary>Throws an exception if writing is not allowed</summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStreamTest.TestStream.enforceSeekAllowed">
            <summary>Throws an exception if seeking is not allowed</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStreamTest.TestStream.stream">
            <summary>Stream being wrapped for testing</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStreamTest.TestStream.readAllowed">
            <summary>whether to allow reading from the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStreamTest.TestStream.writeAllowed">
            <summary>Whether to allow writing to the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStreamTest.TestStream.seekAllowed">
            <summary>Whether to allow seeking within the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStreamTest.TestStream.flushCallCount">
            <summary>Number of times the Flush() method has been called</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStreamTest.TestStream.CanRead">
            <summary>Whether data can be read from the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStreamTest.TestStream.CanSeek">
            <summary>Whether the stream supports seeking</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStreamTest.TestStream.CanWrite">
            <summary>Whether data can be written into the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStreamTest.TestStream.Length">
            <summary>Length of the stream in bytes</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStreamTest.TestStream.Position">
            <summary>Absolute position of the file pointer within the stream</summary>
            <exception cref="T:System.NotSupportedException">
              At least one of the chained streams does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStreamTest.TestStream.FlushCallCount">
            <summary>Number of times the Flush() method has been called</summary>
        </member>
        <member name="T:Nuclex.Support.StringBuilderHelper">
            <summary>Contains helper methods for the string builder class</summary>
        </member>
        <member name="F:Nuclex.Support.StringBuilderHelper.numbers">
            <summary>Predefined unicode characters for the numbers 0 to 9</summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Clear(System.Text.StringBuilder)">
            <summary>Clears the contents of a string builder</summary>
            <param name="builder">String builder that will be cleared</param>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Byte)">
            <summary>
              Appends an integer to a string builder without generating garbage
            </summary>
            <param name="builder">String builder to which an integer will be appended</param>
            <param name="value">Byte that will be appended to the string builder</param>
            <remarks>
              The normal StringBuilder.Append() method generates garbage when converting
              integer arguments whereas this method will avoid any garbage, albeit probably
              with a small performance impact compared to the built-in method.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Int32)">
            <summary>
              Appends an integer to a string builder without generating garbage
            </summary>
            <param name="builder">String builder to which an integer will be appended</param>
            <param name="value">Integer that will be appended to the string builder</param>
            <remarks>
              The normal StringBuilder.Append() method generates garbage when converting
              integer arguments whereas this method will avoid any garbage, albeit probably
              with a small performance impact compared to the built-in method.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Int64)">
            <summary>
              Appends an long integer to a string builder without generating garbage
            </summary>
            <param name="builder">String builder to which an integer will be appended</param>
            <param name="value">Long integer that will be appended to the string builder</param>
            <remarks>
              The normal StringBuilder.Append() method generates garbage when converting
              integer arguments whereas this method will avoid any garbage, albeit probably
              with a small performance impact compared to the built-in method.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Single)">
            <summary>
              Appends a floating point value to a string builder without generating garbage
            </summary>
            <param name="builder">String builder the value will be appended to</param>
            <param name="value">Value that will be appended to the string builder</param>
            <returns>Whether the value was inside the algorithm's supported range</returns>
            <remarks>
              Uses an algorithm that covers the sane range of possible values but will
              fail to render extreme values, NaNs and infinity. In these cases, false
              is returned and the traditional double.ToString() method can be used.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Single,System.Int32)">
            <summary>
              Appends a floating point value to a string builder without generating garbage
            </summary>
            <param name="builder">String builder the value will be appended to</param>
            <param name="value">Value that will be appended to the string builder</param>
            <param name="decimalPlaces">Maximum number of decimal places to display</param>
            <returns>Whether the value was inside the algorithm's supported range</returns>
            <remarks>
              Uses an algorithm that covers the sane range of possible values but will
              fail to render extreme values, NaNs and infinity. In these cases, false
              is returned and the traditional double.ToString() method can be used.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Double)">
            <summary>
              Appends a double precision floating point value to a string builder
              without generating garbage
            </summary>
            <param name="builder">String builder the value will be appended to</param>
            <param name="value">Value that will be appended to the string builder</param>
            <returns>Whether the value was inside the algorithm's supported range</returns>
            <remarks>
              Uses an algorithm that covers the sane range of possible values but will
              fail to render extreme values, NaNs and infinity. In these cases, false
              is returned and the traditional double.ToString() method can be used.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Double,System.Int32)">
            <summary>
              Appends a double precision floating point value to a string builder
              without generating garbage
            </summary>
            <param name="builder">String builder the value will be appended to</param>
            <param name="value">Value that will be appended to the string builder</param>
            <param name="decimalPlaces">Maximum number of decimal places to display</param>
            <returns>Whether the value was inside the algorithm's supported range</returns>
            <remarks>
              Uses an algorithm that covers the sane range of possible values but will
              fail to render extreme values, NaNs and infinity. In these cases, false
              is returned and the traditional double.ToString() method can be used.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.recursiveAppend(System.Text.StringBuilder,System.Int32)">
            <summary>Recursively appends a number's characters to a string builder</summary>
            <param name="builder">String builder the number will be appended to</param>
            <param name="remaining">Remaining digits that will be recursively processed</param>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.recursiveAppend(System.Text.StringBuilder,System.Int64)">
            <summary>Recursively appends a number's characters to a string builder</summary>
            <param name="builder">String builder the number will be appended to</param>
            <param name="remaining">Remaining digits that will be recursively processed</param>
        </member>
        <member name="T:Nuclex.Support.StringBuilderHelperTest">
            <summary>
              Unit test for the helper class to .NET's string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendByte">
            <summary>
              Verifies that bytes are correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNullByte">
            <summary>
              Verifies that a byte with value 0 is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendPositiveInteger">
            <summary>
              Verifies that a positive integer is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNullInteger">
            <summary>
              Verifies that an integer with value 0 is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNegativeInteger">
            <summary>
              Verifies that a negative integer is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendPositiveLong">
            <summary>
              Verifies that a positive long integer is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNullLong">
            <summary>
              Verifies that a long integer with value 0 is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNegativeLong">
            <summary>
              Verifies that a negative long integer is correctly appended to a string builder
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNegativeFloat">
            <summary>
              Verifies that negative floating point values are correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendPositiveFloat">
            <summary>
              Verifies that positive floating point values are correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendSmallFloat">
            <summary>
              Verifies that very small floating point values are correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendHugeFloat">
            <summary>
              Verifies that very large floating point values are correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendFloatLimitDecimalPlaces">
            <summary>Tests whether the number of decimal places can be restricted</summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendFloatWithoutDecimalPlaces">
            <summary>
              Verifies that a float with no decimal places is correctly appended
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendOutOfRangeFloat">
            <summary>
              Verifies the behavior of the helper with unsupported floating point values
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendNegativeDouble">
            <summary>
              Verifies that negative double precision floating point values are
              correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendPositiveDouble">
            <summary>
              Verifies that positive double precision floating point values are
              correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendSmallDouble">
            <summary>
              Verifies that very small double precision floating point values are
              correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendHugeDouble">
            <summary>
              Verifies that very large double precision floating point values are
              correctly converted
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendDoubleLimitDecimalPlaces">
            <summary>Tests whether the number of decimal places can be restricted</summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendDoubleWithoutDecimalPlaces">
            <summary>
              Verifies that a double with no decimal places is correctly appended
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestAppendOutOfRangeDouble">
            <summary>
              Verifies the behavior of the helper with unsupported double precision
              floating point values
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelperTest.TestClear">
            <summary>
              Verifies that the contents of a string builder can be cleared
            </summary>
        </member>
        <member name="T:Nuclex.Support.StringHelper">
            <summary>Helper routines for working with strings</summary>
        </member>
        <member name="M:Nuclex.Support.StringHelper.IndexNotOfAny(System.String,System.Char[])">
            <summary>
              Searches for the first occurence of a character other than the characters
              listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.IndexNotOfAny(System.String,System.Char[],System.Int32)">
            <summary>
              Searches for the first occurence of a character other than the characters
              listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <param name="startIndex">
              Index of the character in the haystack at which to start scanning
            </param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.IndexNotOfAny(System.String,System.Char[],System.Int32,System.Int32)">
            <summary>
              Searches for the first occurence of a character other than the characters
              listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <param name="startIndex">
              Index of the character in the haystack at which to start scanning
            </param>
            <param name="count">Number of characters in the haystack to scan</param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.LastIndexNotOfAny(System.String,System.Char[])">
            <summary>
              Searches backwards for the first occurence of a character other than the
              characters listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.LastIndexNotOfAny(System.String,System.Char[],System.Int32)">
            <summary>
              Searches backwards for the first occurence of a character other than the
              characters listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <param name="startIndex">
              Index of the character in the haystack at which to start scanning
            </param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.LastIndexNotOfAny(System.String,System.Char[],System.Int32,System.Int32)">
            <summary>
              Searches backwards for the first occurence of a character other than the
              characters listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <param name="startIndex">
              Index of the character in the haystack at which to start scanning
            </param>
            <param name="count">Number of characters in the haystack to scan</param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="T:Nuclex.Support.StringHelperTest">
            <summary>Unit Test for the string helper class</summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestIndexNotOfAny">
            <summary>
              Verifies that the IndexNotOfAny() method works identical to the framework's
              implementation of the IndexOfAny() method, only inverted.
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestIndexNotOfAnyWithStartIndex">
            <summary>
              Verifies that the IndexNotOfAny() method works identical to the framework's
              implementation of the IndexOfAny() method, only inverted, using a start index.
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestLastIndexNotOfAny">
            <summary>
              Verifies that the LastIndexNotOfAny() method works identical to the framework's
              implementation of the LastIndexOfAny() method, only inverted.
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestLastIndexNotOfAnyWithStartIndex">
            <summary>
              Verifies that the LastIndexNotOfAny() method works identical to the framework's
              implementation of the LastIndexOfAny() method, only inverted, using a start index.
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestMultipleCharIndexNotOfAny">
            <summary>
              Verifies that the IndexNotOfAny() method works with multiple characters
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestMultipleCharIndexNotOfAnyWithStartIndex">
            <summary>
              Verifies that the IndexNotOfAny() method works with multiple characters,
              using a start index
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestMultipleCharLastIndexNotOfAny">
            <summary>
              Verifies that the LastIndexNotOfAny() method works with multiple characters
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestMultipleCharLastIndexNotOfAnyWithStartIndex">
            <summary>
              Verifies that the LastIndexNotOfAny() method works with multiple characters,
              using a start index
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestIndexNotOfAnyMatchesOnly">
            <summary>
              Verifies that the IndexNotOfAny() method fails when only matches are found
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestIndexNotOfAnyMatchesOnlyWithStartIndex">
            <summary>
              Verifies that the IndexNotOfAny() method fails when only matches are found,
              using a start index
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestLastIndexNotOfAnyMatchesOnly">
            <summary>
              Verifies that the LastIndexNotOfAny() method fails when only matches are found
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringHelperTest.TestLastIndexNotOfAnyMatchesOnlyWithStartIndex">
            <summary>
              Verifies that the LastIndexNotOfAny() method fails when only matches are found,
              using a start index
            </summary>
        </member>
        <member name="T:Nuclex.Support.StringSegment">
            <summary>Delimits a section of a string</summary>
            <remarks>
              <para>
                The design of this class pretty much mirrors that of the
                <see cref="T:System.ArraySegment" /> class found in the .NET framework, but is
                specialized to be used for strings, which can not be expressed as arrays but
                share a lot of the characteristics of an array.
              </para>
              <para>
                In certain situations, passing a StringSegment instead of the the actual
                section from a string is useful. For example, the caller might want to know
                from which index of the original string the substring was taken. Used internally
                in parsers, it can also prevent needless string copying and garbage generation.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringSegment.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Nuclex.Support.StringSegment"/> class that delimits
              all the elements in the specified string
            </summary>
            <param name="text">String that will be wrapped</param>
            <exception cref="T:System.ArgumentNullException">String is null</exception>
        </member>
        <member name="M:Nuclex.Support.StringSegment.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Nuclex.Support.StringSegment"/> class that delimits
              the specified range of the elements in the specified string
            </summary>
            <param name="text">The string containing the range of elements to delimit</param>
            <param name="offset">The zero-based index of the first element in the range</param>
            <param name="count">The number of elements in the range</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Offset or count is less than 0
            </exception>
            <exception cref="T:System.ArgumentException">
              Offset and count do not specify a valid range in array
            </exception>
            <exception cref="T:System.ArgumentNullException">String is null</exception>
        </member>
        <member name="M:Nuclex.Support.StringSegment.GetHashCode">
            <summary>Returns the hash code for the current instance</summary>
            <returns>A 32-bit signed integer hash code</returns>
        </member>
        <member name="M:Nuclex.Support.StringSegment.Equals(System.Object)">
            <summary>
              Determines whether the specified object is equal to the current instance
            </summary>
            <returns>
              True if the specified object is a <see cref="T:Nuclex.Support.StringSegment"/> structure and is
              equal to the current instance; otherwise, false
            </returns>
            <param name="other">The object to be compared with the current instance</param>
        </member>
        <member name="M:Nuclex.Support.StringSegment.Equals(Nuclex.Support.StringSegment)">
            <summary>
              Determines whether the specified <see cref="T:Nuclex.Support.StringSegment"/> structure is equal
              to the current instance
            </summary>
            <returns>
              True if the specified <see cref="T:Nuclex.Support.StringSegment"/> structure is equal to the
              current instance; otherwise, false
            </returns>
            <param name="other">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure to be compared with the current instance
            </param>
        </member>
        <member name="M:Nuclex.Support.StringSegment.op_Equality(Nuclex.Support.StringSegment,Nuclex.Support.StringSegment)">
            <summary>
              Indicates whether two <see cref="T:Nuclex.Support.StringSegment"/> structures are equal
            </summary>
            <returns>True if a is equal to b; otherwise, false</returns>
            <param name="left">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure on the left side of the
              equality operator
            </param>
            <param name="right">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure on the right side of the
              equality operator
            </param>
        </member>
        <member name="M:Nuclex.Support.StringSegment.op_Inequality(Nuclex.Support.StringSegment,Nuclex.Support.StringSegment)">
            <summary>
              Indicates whether two <see cref="T:Nuclex.Support.StringSegment"/> structures are unequal
            </summary>
            <returns>True if a is not equal to b; otherwise, false</returns>
            <param name="left">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure on the left side of the
              inequality operator
            </param>
            <param name="right">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure on the right side of the
              inequality operator
            </param>
        </member>
        <member name="M:Nuclex.Support.StringSegment.ToString">
            <summary>Returns a string representation of the string segment</summary>
            <returns>The string representation of the string segment</returns>
        </member>
        <member name="F:Nuclex.Support.StringSegment.text">
            <summary>String wrapped by the string segment</summary>
        </member>
        <member name="F:Nuclex.Support.StringSegment.offset">
            <summary>Offset in the original string the segment begins at</summary>
        </member>
        <member name="F:Nuclex.Support.StringSegment.count">
            <summary>Number of characters in the segment</summary>
        </member>
        <member name="P:Nuclex.Support.StringSegment.Text">
            <summary>
              Gets the original string containing the range of elements that the string
              segment delimits
            </summary>
            <returns>
              The original array that was passed to the constructor, and that contains the range
              delimited by the <see cref="T:Nuclex.Support.StringSegment"/>
            </returns>
        </member>
        <member name="P:Nuclex.Support.StringSegment.Offset">
            <summary>
              Gets the position of the first element in the range delimited by the array segment,
              relative to the start of the original array
            </summary>
            <returns>
              The position of the first element in the range delimited by the
              <see cref="T:Nuclex.Support.StringSegment"/>, relative to the start of the original array
            </returns>
        </member>
        <member name="P:Nuclex.Support.StringSegment.Count">
            <summary>
              Gets the number of elements in the range delimited by the array segment
            </summary>
            <returns>
              The number of elements in the range delimited by the <see cref="T:Nuclex.Support.StringSegment"/>
            </returns>
        </member>
        <member name="T:Nuclex.Support.StringSegmentTest">
            <summary>Unit Test for the strign segment class</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestNullStringInSimpleConstructor">
            <summary>
              Tests whether the default constructor of the StringSegment class throws the
              right exception when being passed 'null' instead of a string
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestEmptyStringInSimpleConstructor">
            <summary>
              Tests whether the simple constructor of the StringSegment class accepts
              an empty string
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestNullStringInFullConstructor">
            <summary>
              Tests whether the full constructor of the StringSegment class throws the
              right exception when being passed 'null' instead of a string
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestEmptyStringInFullConstructor">
            <summary>
              Tests whether the full constructor of the StringSegment class accepts
              an empty string
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestInvalidOffsetInConstructor">
            <summary>
              Tests whether the full constructor of the StringSegment class throws the
              right exception when being passed an invalid start offset
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestInvalidLengthInConstructor">
            <summary>
              Tests whether the full constructor of the StringSegment class throws the
              right exception when being passed an invalid string length
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestExcessiveLengthInConstructor">
            <summary>
              Tests whether the full constructor of the StringSegment class throws the
              right exception when being passed a string length that's too large
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestTextProperty">
            <summary>Tests whether the 'Text' property works as expected</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestOffsetProperty">
            <summary>Tests whether the 'Offset' property works as expected</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestCountProperty">
            <summary>Tests whether the 'Count' property works as expected</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestHashCodeOnDifferingInstances">
            <summary>
              Tests whether two differing instances produce different hash codes
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestHashCodeOnEquivalentInstances">
            <summary>
              Tests whether two equivalent instances produce an identical hash code
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestEqualsOnNull">
            <summary>Tests the equals method performing a comparison against null</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestEqualityOnDifferingInstances">
            <summary>Tests the equality operator with differing instances</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestEqualityOnEquivalentInstances">
            <summary>Tests the equality operator with equivalent instances</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestInequalityOnDifferingInstances">
            <summary>Tests the inequality operator with differing instances</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestInequalityOnEquivalentInstances">
            <summary>Tests the inequality operator with equivalent instances</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestToString">
            <summary>Tests the ToString() method of the string segment</summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestToStringWithInvalidString">
            <summary>
              Tests the ToString() method of the string segment with an invalid string
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestToStringWithInvalidOffset">
            <summary>
              Tests the ToString() method of the string segment with an invalid offset
            </summary>
        </member>
        <member name="M:Nuclex.Support.StringSegmentTest.TestToStringWithInvalidCount">
            <summary>
              Tests the ToString() method of the string segment with an invalid count
            </summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.IdleStateEventArgs">
            <summary>Event arguments for an idle state change notification</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.IdleStateEventArgs.#ctor(System.Boolean)">
            <summary>Initializes the idle state change notification</summary>
            <param name="idle">The new idle state</param>
        </member>
        <member name="F:Nuclex.Support.Tracking.IdleStateEventArgs.idle">
            <summary>Current idle state</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.IdleStateEventArgs.Idle">
            <summary>Current idle state</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.IdleStateEventArgsTest">
            <summary>Unit Test for the "idle state" event argument container</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.IdleStateEventArgsTest.TestIdleStateChangedToFalse">
            <summary>
              Tests whether the idle state event arguments correctly report a non-idle state
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.IdleStateEventArgsTest.TestIdleStateChangedToTrue">
            <summary>
              Tests whether the idle state event arguments correctly report an idle state
            </summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ObservedWeightedTransaction`1">
            <summary>Transaction being observed by another object</summary>
            <typeparam name="TransactionType">
              Type of the transaction that is being observed
            </typeparam>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.#ctor(Nuclex.Support.Tracking.WeightedTransaction{`0},Nuclex.Support.Tracking.ObservedWeightedTransaction{`0}.ReportDelegate,Nuclex.Support.Tracking.ObservedWeightedTransaction{`0}.ReportDelegate)">
            <summary>Initializes a new observed transaction</summary>
            <param name="weightedTransaction">Weighted transaction being observed</param>
            <param name="progressUpdateCallback">
              Callback to invoke when the transaction's progress changes
            </param>
            <param name="endedCallback">
              Callback to invoke when the transaction has ended
            </param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.Dispose">
            <summary>Immediately releases all resources owned by the object</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.asyncEnded(System.Object,System.EventArgs)">
            <summary>Called when the observed transaction has ended</summary>
            <param name="sender">Transaction that has ended</param>
            <param name="e">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.asyncProgressChanged(System.Object,Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Called when the progress of the observed transaction changes</summary>
            <param name="sender">Transaction whose progress has changed</param>
            <param name="arguments">Contains the updated progress</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.asyncDisconnectEvents">
            <summary>Unsubscribes from all events of the observed transaction</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.progressReporter">
            <summary>The observed transaction's progress reporting interface</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.weightedTransaction">
            <summary>The weighted wable that is being observed</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.progressUpdateCallback">
            <summary>Callback to invoke when the progress updates</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.endedCallback">
            <summary>Callback to invoke when the transaction ends</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.progress">
            <summary>Progress achieved so far</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.WeightedTransaction">
            <summary>Weighted transaction being observed</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.Progress">
            <summary>Amount of progress this transaction has achieved so far</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.ReportDelegate">
            <summary>Delegate for reporting progress updates</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ObservedWeightedTransactionTest">
            <summary>Unit Test for the observation wrapper of weighted transactions</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransactionTest.Setup">
            <summary>Initialization routine executed before each test is run</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransactionTest.TestConstructorWithAlreadyEndedTransaction">
            <summary>Verifies that the constructor of the observation wrapper works</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransactionTest.TestConstructorWithEndingTransaction">
            <summary>
              Verifies that the constructor of the observation wrapper can handle a transaction
              entering the 'ended' state right on subscription
            </summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ObservedWeightedTransactionTest.mockery">
            <summary>Mock object factory</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ObservedWeightedTransactionTest.IObservationSubscriber">
            <summary>
              Interface used to test the observation wrapper of weighted transactions
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransactionTest.IObservationSubscriber.ProgressUpdated">
            <summary>Will be invoked when an observed transaction's progress changes</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransactionTest.IObservationSubscriber.Ended">
            <summary>Will be invoked when an observed transaction completes</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ObservedWeightedTransactionTest.FunkyTransaction">
            <summary>
              Transaction that goes into the 'ended' state as soon as someone registers for
              state change notifications
            </summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ObservedWeightedTransactionTest.FunkyTransaction.alreadyEnded">
            <summary>Whether the transaction has already been ended</summary>
        </member>
        <member name="E:Nuclex.Support.Tracking.ObservedWeightedTransactionTest.FunkyTransaction.AsyncEnded">
            <summary>Manages registrations to the AsyncEnded event</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.WeightedTransactionWrapperCollection`1">
            <summary>Collection of transactions with a weighting value</summary>
            <typeparam name="TransactionType">Type of transactions to manage</typeparam>
            <remarks>
              <para>
                This collection is exposed as a read-only collection to the user that
                stores WeightedTransactions. Internally, it merely wraps a collection of
                an internal type used to keep track of the individual transaction's
                progress in the TransactionGroup and OperationQueue classes.
              </para>
              <para>
                It is read-only because the design requires a transaction to only ever finish
                once. If it was possible eg. to add items after a TransactionGroup had signalled
                itself as being finished, it would be moved into an unfinished state again.
                Also, an empty TransactionGroup is, by definition, finished (simply because
                there is no work to do) - unless the contents of the group are passed to the
                TransactionGroup's constructor and never modified at all, the design would be
                violated as soon as an instance of the TransactionGroup or OperationQueue
                classes was created.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransactionWrapperCollection`1.#ctor(System.Collections.Generic.IList{Nuclex.Support.Tracking.ObservedWeightedTransaction{`0}})">
            <summary>Initializes a new weighted transaction collection wrapper</summary>
            <param name="items">Items to be exposed as weighted transactions</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransactionWrapperCollection`1.Transform(Nuclex.Support.Tracking.ObservedWeightedTransaction{`0})">
            <summary>Transforms an item into the exposed type</summary>
            <param name="item">Item to be transformed</param>
            <returns>The transformed item</returns>
            <remarks>
              This method is used to transform an item in the wrapped collection into
              the exposed item type whenever the user accesses an item. Expect it to
              be called frequently, because the TransformingReadOnlyCollection does
              not cache otherwise store the transformed items.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Tracking.WeightedTransactionWrapperCollectionTest">
            <summary>
              Unit Test for the observation wrapper collection of weighted transactions
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransactionWrapperCollectionTest.TestWrapperCollection">
            <summary>
              Tests whether the wrapper collection is handing out the unwrapped transactions
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransactionWrapperCollectionTest.endedCallback">
            <summary>Dummy callback used as event subscriber in the tests</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransactionWrapperCollectionTest.progressUpdatedCallback">
            <summary>Dummy callback used as event subscriber in the tests</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.IStatusReporter">
            <summary>Interface for processes that report their status</summary>
        </member>
        <member name="E:Nuclex.Support.Tracking.IStatusReporter.AsyncStatusChanged">
            <summary>Triggered when the status of the process changes</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ProgressReportEventArgs">
            <summary>Event arguments for a progress update notification</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressReportEventArgs.#ctor(System.Single)">
            <summary>Initializes the progress update informations</summary>
            <param name="progress">Achieved progress ranging from 0.0 to 1.0</param>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressReportEventArgs.progress">
            <summary>Achieved progress</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.ProgressReportEventArgs.Progress">
            <summary>Currently achieved progress</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ProgressReportEventArgsTest">
            <summary>Unit Test for the progress report event argument container</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressReportEventArgsTest.TestZeroProgress">
            <summary>
              Tests whether the progress report event arguments correctly report zero progress
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressReportEventArgsTest.TestCompleteProgress">
            <summary>
              Tests whether the progress report event arguments correctly report complete progress
            </summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ProgressTracker">
            <summary>
              Helps tracking the progress of one or more background transactions
            </summary>
            <remarks>
              <para>
                This is useful if you want to display a progress bar for multiple
                transactions but can not guarantee that no additional transactions
                will appear inmidst of execution.
              </para>
              <para>
                This class does not implement the <see cref="T:Nuclex.Support.Tracking.Transaction"/> interface itself
                in order to not violate the design principles of transactions which
                guarantee that a <see cref="T:Nuclex.Support.Tracking.Transaction"/> will only finish once (whereas the
                progress tracker might 'finish' any number of times).
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.#ctor">
            <summary>Initializes a new transaction tracker</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.Track(Nuclex.Support.Tracking.Transaction)">
            <summary>Begins tracking the specified background transactions</summary>
            <param name="transaction">Background transaction to be tracked</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.Track(Nuclex.Support.Tracking.Transaction,System.Single)">
            <summary>Begins tracking the specified background transaction</summary>
            <param name="transaction">Background transaction to be tracked</param>
            <param name="weight">Weight to assign to this background transaction</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.Untrack(Nuclex.Support.Tracking.Transaction)">
            <summary>Stops tracking the specified background transaction</summary>
            <param name="transaction">Background transaction to stop tracking of</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.OnAsyncIdleStateChanged(System.Boolean)">
            <summary>Fires the AsyncIdleStateChanged event</summary>
            <param name="idle">New idle state to report</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.OnAsyncProgressUpdated(System.Single)">
            <summary>Fires the AsyncProgressUpdated event</summary>
            <param name="progress">New progress to report</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.recalculateProgress">
            <summary>Recalculates the total progress of the tracker</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.asyncEnded">
            <summary>Called when one of the tracked transactions has ended</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.asyncProgressChanged">
            <summary>Called when one of the tracked transactions has achieved progress</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.setIdle(System.Boolean)">
            <summary>Changes the idle state</summary>
            <param name="idle">Whether or not the tracker is currently idle</param>
            <remarks>
              This method expects to be called during a lock() on trackedTransactions!
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.idle">
            <summary>Whether the tracker is currently idle</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.progress">
            <summary>Current summed progress of the tracked transactions</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.totalWeight">
            <summary>Total weight of all transactions being tracked</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.trackedTransactions">
            <summary>Transactions being tracked by this tracker</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.asyncEndedDelegate">
            <summary>Delegate for the asyncEnded() method</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.asyncProgressUpdatedDelegate">
            <summary>Delegate for the asyncProgressUpdated() method</summary>
        </member>
        <member name="E:Nuclex.Support.Tracking.ProgressTracker.AsyncIdleStateChanged">
            <summary>Triggered when the idle state of the tracker changes</summary>
            <remarks>
              The tracker is idle when no transactions are being tracked in it. If you're
              using this class to feed a progress bar, this would be the event to use for
              showing or hiding the progress bar. The tracker starts off as idle because,
              upon construction, its list of transactions will be empty.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Tracking.ProgressTracker.AsyncProgressChanged">
            <summary>Triggered when the total progress has changed</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.ProgressTracker.Idle">
            <summary>Whether the tracker is currently idle</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.ProgressTracker.Progress">
            <summary>Current summed progress of the tracked transactions</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ProgressTracker.TransactionMatcher">
            <summary>Matches a direct transaction to a fully wrapped one</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.TransactionMatcher.#ctor(Nuclex.Support.Tracking.Transaction)">
            <summary>
              Initializes a new transaction matcher that matches against
              the specified transaction
            </summary>
            <param name="toMatch">Transaction to match against</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.TransactionMatcher.Matches(Nuclex.Support.Tracking.ObservedWeightedTransaction{Nuclex.Support.Tracking.Transaction})">
            <summary>
              Checks whether the provided transaction matches the comparison
              transaction of the instance
            </summary>
            <param name="other">Transaction to match to the comparison transaction</param>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.TransactionMatcher.toMatch">
            <summary>Transaction this instance compares against</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ProgressTrackerTest">
            <summary>Unit Test for the progress tracker class</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.Setup">
            <summary>Initialization routine executed before each test is run</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestSummedProgress">
            <summary>Validates that the tracker properly sums the progress</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestDelayedRemoval">
            <summary>
              Validates that the tracker only removes transactions when the whole
              tracking list has reached the 'ended' state.
            </summary>
            <remarks>
              If the tracker would remove ended transactions right when they finished,
              the total progress would jump back each time. This is unwanted, of course.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestSoleEndedTransaction">
            <summary>
              Validates that the tracker behaves correctly if it is fed with transactions
              that have already ended.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestEndedTransaction">
            <summary>
              Validates that the tracker behaves correctly if it is fed with transactions
              that have already ended in addition to transactions that are actively executing.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestProvokedDeadlock">
            <summary>
              Tries to provoke a deadlock by re-entering the tracker from one of its own events
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestIdleWithUntrack">
            <summary>
              Tests whether the progress tracker enters and leaves the idle state correctly
              when a transaction is removed via Untrack()
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestIdleWithAutoRemoval">
            <summary>
              Tests whether the progress tracker enters and leaves the idle state correctly
              when a transaction is removed the transaction finishing
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestProgressWithUntrack">
            <summary>
              Tests whether the progress tracker enters and leaves the idle state correctly
              when a transaction is removed via Untrack()
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestThrowOnUntrackNonTrackedTransaction">
            <summary>
              Verifies that the progress tracker throws an exception if it is instructed
              to untrack a transaction it doesn't know about
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestProgressReportDuringUnsubscribe">
            <summary>
              Verifies that the progress tracker throws an exception if it is instructed
              to untrack a transaction it doesn't know about
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestMultiTrackedTransaction">
            <summary>
              Verifies that the progress tracker doesn't choke on a transaction being tracked
              multiple times.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.mockSubscriber(Nuclex.Support.Tracking.ProgressTracker)">
            <summary>Mocks a subscriber for the events of a tracker</summary>
            <param name="tracker">Tracker to mock an event subscriber for</param>
            <returns>The mocked event subscriber</returns>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTrackerTest.mockery">
            <summary>Mock object factory</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ProgressTrackerTest.IProgressTrackerSubscriber">
            <summary>Interface used to test the progress tracker</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.IProgressTrackerSubscriber.ProgressChanged(System.Object,Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Called when the tracked progress changes</summary>
            <param name="sender">Progress tracker whose progress has changed</param>
            <param name="arguments">Contains the new progress achieved</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.IProgressTrackerSubscriber.IdleStateChanged(System.Object,Nuclex.Support.Tracking.IdleStateEventArgs)">
            <summary>Called when the progress tracker's idle state changes</summary>
            <param name="sender">Progress tracker whose idle state has changed</param>
            <param name="arguments">Contains the new idle state of the tracker</param>
        </member>
        <member name="T:Nuclex.Support.Tracking.ProgressTrackerTest.ProgressReportEventArgsMatcher">
            <summary>Compares two ProgressUpdateEventArgs instances</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.ProgressReportEventArgsMatcher.#ctor(Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Initializes a new ProgressUpdateEventArgsMatcher</summary>
            <param name="expected">Expected progress update event arguments</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.ProgressReportEventArgsMatcher.Matches(System.Object)">
            <summary>
              Called by NMock to verfiy the ProgressUpdateEventArgs match the expected value
            </summary>
            <param name="actualAsObject">Actual value to compare to the expected value</param>
            <returns>
              True if the actual value matches the expected value; otherwise false
            </returns>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.ProgressReportEventArgsMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>Creates a string representation of the expected value</summary>
            <param name="writer">Writer to write the string representation into</param>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTrackerTest.ProgressReportEventArgsMatcher.expected">
            <summary>Expected progress update event args value</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ProgressTrackerTest.TestTransaction">
            <summary>Transaction used for testing in this unit test</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestTransaction.ChangeProgress(System.Single)">
            <summary>Changes the testing transaction's indicated progress</summary>
            <param name="progress">New progress to be reported by the testing transaction</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestTransaction.End">
            <summary>Transitions the transaction into the ended state</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestTransaction.OnAsyncProgressChanged(System.Single)">
            <summary>Fires the progress update event</summary>
            <param name="progress">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this transaction about the achieved progress.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTrackerTest.TestTransaction.OnAsyncProgressChanged(Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Fires the progress update event</summary>
            <param name="eventArguments">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this transaction about the achieved progress.
              Allows for classes derived from the transaction class to easily provide
              a custom event arguments class that has been derived from the
              transaction's ProgressUpdateEventArgs class.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Tracking.ProgressTrackerTest.TestTransaction.AsyncProgressChanged">
            <summary>will be triggered to report when progress has been achieved</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ProgressTrackerTest.EvilTransaction">
            <summary>
              Transaction that tries to emulate a thread giving a progress report at
              a very inconvenient time ;)
            </summary>
        </member>
        <member name="E:Nuclex.Support.Tracking.ProgressTrackerTest.EvilTransaction.AsyncProgressChanged">
            <summary>will be triggered to report when progress has been achieved</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.Request`1">
            <summary>Request providing a result that can be passed to the caller</summary>
            <typeparam name="ResultType">
              Type of the result being provided by the request
            </typeparam>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.CreateSucceededDummy(`0)">
            <summary>Creates a new failed dummy request</summary>
            <param name="result">Result to provide to the caller</param>
            <returns>
              A succeeded request that returns the provided result to the caller
            </returns>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.CreateFailedDummy(System.Exception)">
            <summary>Creates a new failed dummy request</summary>
            <param name="exception">Exception that supposedly caused the request to fail</param>
            <returns>
              A failed request that reports the provided exception as cause for its failure
            </returns>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.Join">
            <summary>Waits for the background operation to end</summary>
            <remarks>
              Any exceptions raised in the background operation will be thrown
              in this method. If you decide to override this method, you should
              call End() first (and let any possible exception through to your
              caller).
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.ReraiseExceptions">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.GatherResults">
            <summary>
              Allows the specific request to return the results of the Request to the
              caller of the Join() method
            </summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.Request`1.SucceededDummyRequest">
            <summary>Succeeded dummy request that is always in the ended state</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.SucceededDummyRequest.#ctor(`0)">
            <summary>Creates a new failed dummy request</summary>
            <param name="result">Result to return to the request's caller</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.SucceededDummyRequest.GatherResults">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.Request`1.SucceededDummyRequest.result">
            <summary>Results the succeede dummy request will provide to the caller</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.Request`1.FailedDummyRequest">
            <summary>Failed dummy request that is always in the ended state</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.FailedDummyRequest.#ctor(System.Exception)">
            <summary>Creates a new failed dummy request</summary>
            <param name="exception">Exception that caused the dummy to fail</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.FailedDummyRequest.GatherResults">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.Request`1.FailedDummyRequest.exception">
            <summary>Exception that supposedly caused the request to fail</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.RequestTest">
            <summary>Unit Test for the request class</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.RequestTest.TestSucceededDummy">
            <summary>
              Verifies that the SucceededDummy request is in the ended state
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.RequestTest.TestFailedDummy">
            <summary>
              Verifies that the FailedDummy request is in the ended state and throws
              an exception when Join()ing
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.RequestTest.TestJoinWithWaiting">
            <summary>
              Verifies that the Request's Wait() method is invoked if the request is joined
              before the request has finished.
            </summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.RequestTest.CustomWaitRequest">
            <summary>
              Request with a custom wait implementation that completes the request instead
              of waiting for it complete by outside means
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.RequestTest.CustomWaitRequest.Wait">
            <summary>Waits until the background process finishes</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.GenericRequestTest">
            <summary>Unit Test for the generic request class</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.GenericRequestTest.TestSucceededDummy">
            <summary>
              Verifies that the SucceededDummy request is in the ended state
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.GenericRequestTest.TestFailedDummy">
            <summary>
              Verifies that the FailedDummy request is in the ended state and throws
              an exception when Join()ing
            </summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.StatusReportEventArgsTest">
            <summary>Unit Test for the status report event argument container</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.StatusReportEventArgsTest.TestEmptyStatus">
            <summary>
              Tests whether the status report event arguments correctly reports an empty status
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.StatusReportEventArgsTest.TestSimpleStatus">
            <summary>
              Tests whether the status report event arguments correctly reports simple
              status indications
            </summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.TransactionTest">
            <summary>Unit Test for the transaction class</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.Setup">
            <summary>Initialization routine executed before each test is run</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.TestThrowOnRepeatedlyEndedTransaction">
            <summary>
              Verifies that the transaction throws an exception when it is ended multiple times
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.TestEndedEventAfterSubscription">
            <summary>
              Tests whether the Ended event of the transaction is correctly delivered if
              the transaction ends after the subscription already took place
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.TestEndedEventDuingSubscription">
            <summary>
              Tests whether the Ended event of the transaction is correctly delivered if
              the transaction is already done when the subscription takes place
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.TestWaitUnlimited">
            <summary>
              Verifies that the Wait() method of the transaction works as expected
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.TestWaitMilliseconds">
            <summary>
              Verifies that the Wait() method of the transaction works as expected using
              a millisecond count as its argument
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.TestWaitTimeSpan">
            <summary>
              Verifies that the Wait() method of the transaction works as expected using
              a TimeSpan as its argument
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.TestUnsubscribeInEndedCallback">
            <summary>
              Verifies that no error occurs when an even subscriber to the AsyncEnded event
              unsubscribes in the event callback handler
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.mockSubscriber(Nuclex.Support.Tracking.Transaction)">
            <summary>Mocks a subscriber for the events of a transaction</summary>
            <param name="transaction">Transaction to mock an event subscriber for</param>
            <returns>The mocked event subscriber</returns>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionTest.mockery">
            <summary>Mock object factory</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.TransactionTest.ITransactionSubscriber">
            <summary>Interface used to test the transaction</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.ITransactionSubscriber.Ended(System.Object,System.EventArgs)">
            <summary>Called when the set transaction has ended</summary>
            <param name="sender">Transaction group that as ended</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="T:Nuclex.Support.Tracking.TransactionTest.TestTransaction">
            <summary>Transaction used for testing in this unit test</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.TestTransaction.End">
            <summary>Transitions the transaction into the ended state</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.TransactionTest.UnsubscribingTransaction">
            <summary>Transaction that unsubscribes during an event callback</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.UnsubscribingTransaction.#ctor(Nuclex.Support.Tracking.Transaction)">
            <summary>Initializes a new unsubscribing transaction</summary>
            <param name="transactionToMonitor">
              Transaction whose AsyncEnded event will be monitored to trigger
              the this transaction unsubscribing from the event.
            </param>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.UnsubscribingTransaction.monitoredTransactionEnded(System.Object,System.EventArgs)">
            <summary>Called when the monitored transaction has ended</summary>
            <param name="sender">Monitored transaction that has ended</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionTest.UnsubscribingTransaction.End">
            <summary>Transitions the transaction into the ended state</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionTest.UnsubscribingTransaction.transactionToMonitor">
            <summary>Transaction whose ending in being monitored</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionTest.UnsubscribingTransaction.monitoredTransactionEndedDelegate">
            <summary>Delegate to the monitoredTransactionEnded() method</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.TransactionGroup`1">
            <summary>Forms a single transaction from a group of transactions</summary>
            <typeparam name="TransactionType">Type of transactions to manage as a set</typeparam>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Initializes a new transaction group</summary>
            <param name="children">Transactions to track with this group</param>
            <remarks>
              Uses a default weighting factor of 1.0 for all transactions.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.#ctor(System.Collections.Generic.IEnumerable{Nuclex.Support.Tracking.WeightedTransaction{`0}})">
            <summary>Initializes a new transaction group</summary>
            <param name="children">Transactions to track with this group</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.Dispose">
            <summary>Immediately releases all resources owned by the object</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.OnAsyncProgressChanged(System.Single)">
            <summary>Fires the progress update event</summary>
            <param name="progress">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this transaction about the achieved progress.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.OnAsyncProgressChanged(Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Fires the progress update event</summary>
            <param name="eventArguments">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this transaction about the achieved progress.
              Allows for classes derived from the transaction class to easily provide
              a custom event arguments class that has been derived from the
              transaction's ProgressUpdateEventArgs class.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.asyncProgressUpdated">
            <summary>
              Called when the progress of one of the observed transactions changes
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.asyncChildEnded">
            <summary>
              Called when an observed transaction ends
            </summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionGroup`1.children">
            <summary>Transactions being managed in the set</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionGroup`1.wrapper">
            <summary>
              Wrapper collection for exposing the child transactions under the
              WeightedTransaction interface
            </summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionGroup`1.totalWeight">
            <summary>Summed weight of all transactions in the set</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionGroup`1.endedCalled">
            <summary>Whether we already called OnAsyncEnded</summary>
        </member>
        <member name="E:Nuclex.Support.Tracking.TransactionGroup`1.AsyncProgressChanged">
            <summary>will be triggered to report when progress has been achieved</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.TransactionGroup`1.Children">
            <summary>Childs contained in the transaction set</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.TransactionGroupTest">
            <summary>Unit Test for the transaction group class</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.Setup">
            <summary>Initialization routine executed before each test is run</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.TestSummedProgress">
            <summary>Validates that the transaction group correctly sums the progress</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.TestWeightedSummedProgress">
            <summary>Validates that the transaction group respects the weights</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.TestEndedEventWithTwoTransactions">
            <summary>
              Validates that the ended event is triggered when the last transaction out of
              multiple transactions in the group ends.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.TestEndedEventWithSingleTransaction">
            <summary>
              Validates that the ended event is triggered when a single transaction contained
              in the group ends.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.TestAlreadyEndedTransactions">
            <summary>
              Verifies that the transaction group immediately enters the ended state when
              the contained transactions have already ended before the constructor
            </summary>
            <remarks>
              This was a bug at one time and should prevent a regression
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.TestAlreadyEndedTransactionAsFirstTransaction">
            <summary>
              Verifies that the transaction group doesn't think it's already ended when
              the first transaction being added is in the ended state
            </summary>
            <remarks>
              This was a bug at one time and should prevent a regression
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.TestTransactionEndingDuringConstructor">
            <summary>
              Verifies that a transaction ending while the constructor is running doesn't
              wreak havoc on the transaction group
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.mockSubscriber(Nuclex.Support.Tracking.Transaction)">
            <summary>Mocks a subscriber for the events of a transaction</summary>
            <param name="transaction">Transaction to mock an event subscriber for</param>
            <returns>The mocked event subscriber</returns>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionGroupTest.mockery">
            <summary>Mock object factory</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.TransactionGroupTest.ITransactionGroupSubscriber">
            <summary>Interface used to test the transaction group</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.ITransactionGroupSubscriber.ProgressChanged(System.Object,Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Called when the transaction group's progress changes</summary>
            <param name="sender">Transaction group whose progress has changed</param>
            <param name="arguments">Contains the new progress achieved</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.ITransactionGroupSubscriber.Ended(System.Object,System.EventArgs)">
            <summary>Called when the transaction group has ended</summary>
            <param name="sender">Transaction group that as ended</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="T:Nuclex.Support.Tracking.TransactionGroupTest.ProgressUpdateEventArgsMatcher">
            <summary>Compares two ProgressUpdateEventArgsInstances for NMock validation</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.ProgressUpdateEventArgsMatcher.#ctor(Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Initializes a new ProgressUpdateEventArgsMatcher </summary>
            <param name="expected">Expected progress update event arguments</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.ProgressUpdateEventArgsMatcher.Matches(System.Object)">
            <summary>
              Called by NMock to verfiy the ProgressUpdateEventArgs match the expected value
            </summary>
            <param name="actualAsObject">Actual value to compare to the expected value</param>
            <returns>
              True if the actual value matches the expected value; otherwise false
            </returns>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.ProgressUpdateEventArgsMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>Creates a string representation of the expected value</summary>
            <param name="writer">Writer to write the string representation into</param>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionGroupTest.ProgressUpdateEventArgsMatcher.expected">
            <summary>Expected progress update event args value</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.TransactionGroupTest.TestTransaction">
            <summary>Transaction used for testing in this unit test</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.TestTransaction.ChangeProgress(System.Single)">
            <summary>Changes the testing transaction's indicated progress</summary>
            <param name="progress">
              New progress to be reported by the testing transaction
            </param>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.TestTransaction.End">
            <summary>Transitions the transaction into the ended state</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.TestTransaction.OnAsyncProgressChanged(System.Single)">
            <summary>Fires the progress update event</summary>
            <param name="progress">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this transaction about the achieved progress.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.TestTransaction.OnAsyncProgressChanged(Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Fires the progress update event</summary>
            <param name="eventArguments">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this transaction about the achieved progress.
              Allows for classes derived from the transaction class to easily provide
              a custom event arguments class that has been derived from the
              transaction's ProgressUpdateEventArgs class.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Tracking.TransactionGroupTest.TestTransaction.AsyncProgressChanged">
            <summary>will be triggered to report when progress has been achieved</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.TransactionGroupTest.ChainEndingTransaction">
            <summary>
              Transaction that ends another transaction when its Ended property is called
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.ChainEndingTransaction.#ctor">
            <summary>Initializes a new chain ending transaction</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroupTest.ChainEndingTransaction.End">
            <summary>Transitions the transaction into the ended state</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionGroupTest.ChainEndingTransaction.chainedTransaction">
            <summary>
              Transaction that will end when this transaction's ended property is accessed
            </summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionGroupTest.ChainEndingTransaction.endedCalled">
            <summary>Whether we already ended the chained transaction and ourselves</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.TransactionGroupTest.ChainEndingTransaction.ChainedTransaction">
            <summary>
              Transaction that will end when this transaction's ended property is accessed
            </summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.TransactionGroupTest.ChainEndingTransaction.Ended">
            <summary>Whether the transaction has ended already</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.StatusReportEventArgs">
            <summary>Event arguments for reporting a status to the subscriber</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.StatusReportEventArgs.#ctor(System.String)">
            <summary>Initializes a new status report event arguments container</summary>
            <param name="status">Status to report to the event's subscribers</param>
        </member>
        <member name="F:Nuclex.Support.Tracking.StatusReportEventArgs.status">
            <summary>Reported status</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.StatusReportEventArgs.Status">
            <summary>The currently reported status</summary>
            <remarks>
              The contents of this string are up to the publisher of the event to
              define. Though it is recommended to report the status as a human-readable
              string, these strings might not in all cases be properly localized or
              suitable for display in a GUI.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Tracking.WeightedTransaction`1">
            <summary>Transaction with an associated weight for the total progress</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransaction`1.#ctor(`0)">
            <summary>
              Initializes a new weighted transaction with a default weight of 1.0
            </summary>
            <param name="transaction">Transaction whose progress to monitor</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransaction`1.#ctor(`0,System.Single)">
            <summary>Initializes a new weighted transaction</summary>
            <param name="transaction">transaction whose progress to monitor</param>
            <param name="weight">Weighting of the transaction's progress</param>
        </member>
        <member name="F:Nuclex.Support.Tracking.WeightedTransaction`1.transaction">
            <summary>Transaction whose progress we're tracking</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.WeightedTransaction`1.weight">
            <summary>Weighting of this transaction in the total progress</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.WeightedTransaction`1.Transaction">
            <summary>Transaction being wrapped by this weighted transaction</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.WeightedTransaction`1.Weight">
            <summary>The contribution of this transaction to the total progress</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.WeightedTransactionTest">
            <summary>Unit Test for the weighted transaction wrapper</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransactionTest.TestTransactionStorage">
            <summary>
              Tests whether the weighted transaction wrapper correctly stores the transaction
              it was given in the constructor
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransactionTest.TestDefaultWeight">
            <summary>
              Tests whether the weighted transaction wrapper correctly applies the default
              unit weight to the transaction if no explicit weight was specified
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransactionTest.TestWeightStorage">
            <summary>
              Tests whether the weighted transaction wrapper correctly stores the weight
              it was given in the constructor
            </summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.WeightedTransactionTest.TestTransaction">
            <summary>Transaction used for testing in this unit test</summary>
        </member>
        <member name="T:Nuclex.Support.WeakReference`1">
            <summary>
              Type-safe weak reference, referencing an object while still allowing
              that object to be garbage collected.
            </summary>
        </member>
        <member name="M:Nuclex.Support.WeakReference`1.#ctor(`0)">
            <summary>
              Initializes a new instance of the WeakReference class, referencing
              the specified object.
            </summary>
            <param name="target">The object to track or null.</param>
        </member>
        <member name="M:Nuclex.Support.WeakReference`1.#ctor(`0,System.Boolean)">
            <summary>
              Initializes a new instance of the WeakReference class, referencing
              the specified object optionally using resurrection tracking.
            </summary>
            <param name="target">An object to track.</param>
            <param name="trackResurrection">
              Indicates when to stop tracking the object. If true, the object is tracked
              after finalization; if false, the object is only tracked until finalization.
            </param>
        </member>
        <member name="M:Nuclex.Support.WeakReference`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the WeakReference class, using deserialized
              data from the specified serialization and stream objects.
            </summary>
            <param name="info">
              An object that holds all the data needed to serialize or deserialize the
              current System.WeakReference object.
            </param>
            <param name="context">
              (Reserved) Describes the source and destination of the serialized stream
              specified by info.
            </param>
            <exception cref="T:System.ArgumentNullException">
              The info parameter is null.
            </exception>
        </member>
        <member name="P:Nuclex.Support.WeakReference`1.Target">
            <summary>
              Gets or sets the object (the target) referenced by the current WeakReference
              object.
            </summary>
            <remarks>
              Is null if the object referenced by the current System.WeakReference object
              has been garbage collected; otherwise, a reference to the object referenced
              by the current System.WeakReference object.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
              The reference to the target object is invalid. This can occur if the current
              System.WeakReference object has been finalized
            </exception>
        </member>
        <member name="T:Nuclex.Support.WeakReferenceTest">
            <summary>Unit Test for the strongly typed weak reference class</summary>
        </member>
        <member name="M:Nuclex.Support.WeakReferenceTest.TestSimpleConstructor">
            <summary>Tests whether the simple constructor works</summary>
        </member>
        <member name="M:Nuclex.Support.WeakReferenceTest.TestFullConstructor">
            <summary>Test whether the full constructor works</summary>
        </member>
        <member name="M:Nuclex.Support.WeakReferenceTest.TestTargetRetrieval">
            <summary>
              Test whether the target object can be retrieved from the weak reference
            </summary>
        </member>
        <member name="M:Nuclex.Support.WeakReferenceTest.TestTargetReassignment">
            <summary>
              Test whether the target object can be reassigned in the weak reference
            </summary>
        </member>
        <member name="M:Nuclex.Support.WeakReferenceTest.TestSerialization">
            <summary>
              Test whether the target object can be reassigned in the weak reference
            </summary>
        </member>
        <member name="T:Nuclex.Support.WeakReferenceTest.Dummy">
            <summary>Dummy class for testing the shared instance provider</summary>
        </member>
        <member name="M:Nuclex.Support.WeakReferenceTest.Dummy.#ctor">
            <summary>Initializes a new dummy</summary>
        </member>
        <member name="T:Nuclex.Support.XmlHelper">
            <summary>Helper routines for handling XML code</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadSchema(System.String)">
            <summary>Loads a schema from a file</summary>
            <param name="schemaPath">Path to the file containing the schema</param>
            <returns>The loaded schema</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadSchema(System.IO.Stream)">
            <summary>Loads a schema from the provided stream</summary>
            <param name="schemaStream">Stream containing the schema that will be loaded</param>
            <returns>The loaded schema</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadSchema(System.IO.TextReader)">
            <summary>Loads a schema from a text reader</summary>
            <param name="schemaReader">Text reader through which the schema can be read</param>
            <returns>The loaded schema</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.TryLoadSchema(System.String,System.Xml.Schema.XmlSchema@)">
            <summary>Attempts to load a schema from a file</summary>
            <param name="schemaPath">Path to the file containing the schema</param>
            <param name="schema">Output parameter that will receive the loaded schema</param>
            <returns>True if the schema was loaded successfully, otherwise false</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.TryLoadSchema(System.IO.Stream,System.Xml.Schema.XmlSchema@)">
            <summary>Attempts to load a schema from the provided stream</summary>
            <param name="schemaStream">Stream containing the schema that will be loaded</param>
            <param name="schema">Output parameter that will receive the loaded schema</param>
            <returns>True if the schema was loaded successfully, otherwise false</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.TryLoadSchema(System.IO.TextReader,System.Xml.Schema.XmlSchema@)">
            <summary>Attempts to load a schema from the provided text reader</summary>
            <param name="schemaReader">Reader from which the schema can be read</param>
            <param name="schema">Output parameter that will receive the loaded schema</param>
            <returns>True if the schema was loaded successfully, otherwise false</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadDocument(System.Xml.Schema.XmlSchema,System.String)">
            <summary>Loads an XML document from a file</summary>
            <param name="schema">Schema to use for validating the XML document</param>
            <param name="documentPath">
              Path to the file containing the XML document that will be loaded
            </param>
            <returns>The loaded XML document</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadDocument(System.Xml.Schema.XmlSchema,System.IO.Stream)">
            <summary>Loads an XML document from a stream</summary>
            <param name="schema">Schema to use for validating the XML document</param>
            <param name="documentStream">
              Stream from which the XML document will be read
            </param>
            <returns>The loaded XML document</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.openFileForSharedReading(System.String)">
            <summary>Opens a file for shared reading</summary>
            <param name="path">Path to the file that will be opened</param>
            <returns>The opened file's stream</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.tryOpenFileForSharedReading(System.String,System.IO.FileStream@)">
            <summary>Opens a file for shared reading</summary>
            <param name="path">Path to the file that will be opened</param>
            <param name="fileStream">
              Output parameter that receives the opened file's stream
            </param>
            <returns>True if the file was opened successfully</returns>
        </member>
        <member name="T:Nuclex.Support.XmlHelper.ValidationEventProcessor">
            <summary>Handles any events occurring when an XML schema is loaded</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.ValidationEventProcessor.OnValidationEvent(System.Object,System.Xml.Schema.ValidationEventArgs)">
            <summary>
              Callback for notifications being sent by the XmlSchema.Read() method
            </summary>
            <param name="sender">Not used</param>
            <param name="arguments">Contains the notification being sent</param>
        </member>
        <member name="F:Nuclex.Support.XmlHelper.ValidationEventProcessor.OccurredException">
            <summary>Exception that has occurred during schema loading</summary>
        </member>
        <member name="T:Nuclex.Support.XmlHelperTest">
            <summary>Unit Test for the XML helper class</summary>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.brokenSchemaXml">
            <summary>A broken XML schema</summary>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.syntaxErrorSchemaXml">
            <summary>An XML schema with a syntax error</summary>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.pointsSchemaXml">
            <summary>A valid XML schema for a list of 2D points</summary>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.brokenXml">
            <summary>A broken XML document</summary>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.unconformantXml">
            <summary>
              Well-formed XML document that is not conformant to the schema above
            </summary>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.conformantXml">
            <summary>Well-formed XML document that is conformant to the schema</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestThrowOnInvalidSchema">
            <summary>
              Verifies that an exception is thrown when a schema fails to load
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestThrowOnSyntaxErrorSchema">
            <summary>
              Verifies that an exception is thrown when a schema contains a syntax error
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestFailOnTryLoadNonExistingFile">
            <summary>
              Verfifies that TryLoadSchema() can fail without throwing an exception
              when the schema is not a valid XML document
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestFailOnTryLoadBrokenSchema">
            <summary>
              Verfifies that TryLoadSchema() can fail without throwing an exception
              when the schema is not a valid XML document
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestFailOnTryLoadSyntaxErrorSchema">
            <summary>
              Verfifies that TryLoadSchema() can fail without throwing an exception
              when the schema contains a syntax error
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestLoadSchema">
            <summary>Tests whether a normal, valid schema can be loaded successfully</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestTryLoadSchema">
            <summary>Tests whether a normal, valid schema can be loaded successfully</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestFailOnLoadInvalidDocument">
            <summary>
              Verifies that an exception is thrown when an invalid XML document is loaded
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestFailOnLoadNonConformingDocument">
            <summary>
              Verifies that an exception is thrown when a nonconformant XML document is loaded
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TestLoadConformingDocument">
            <summary>
              Tests whether a normal, conformant XML document can be loaded successfully
            </summary>
        </member>
        <member name="T:Nuclex.Support.XmlHelperTest.TempFileKeeper">
            <summary>
              Creates a temporary file and automatically deletes it on dispose
            </summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TempFileKeeper.#ctor(System.String)">
            <summary>
              Creates a temporary file with the specified contents using the UTF8 encoding
            </summary>
            <param name="fileContents">
              Contents that will be written into the temporary file
            </param>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TempFileKeeper.#ctor(System.String,System.Text.Encoding)">
            <summary>Creates a temporary file with the specified contents</summary>
            <param name="fileContents">
              Contents that will be written into the temporary file
            </param>
            <param name="encoding">
              Encoding to use for writing the contents into the file
            </param>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TempFileKeeper.Finalize">
            <summary>Called when the instance is collected by the GC</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TempFileKeeper.Dispose">
            <summary>Immediately releases all resources used by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelperTest.TempFileKeeper.op_Implicit(Nuclex.Support.XmlHelperTest.TempFileKeeper)~System.String">
            <summary>Implicitely converts a TempFileKeeper into a file path</summary>
            <param name="tempFileKeeper">TempFileKeeper that will be converted</param>
            <returns>The path to the temporary file managed by the TempFileKeeper</returns>
        </member>
        <member name="F:Nuclex.Support.XmlHelperTest.TempFileKeeper.tempFilePath">
            <summary>Path to the temporary file the TempFileKeeper is managing</summary>
        </member>
    </members>
</doc>
