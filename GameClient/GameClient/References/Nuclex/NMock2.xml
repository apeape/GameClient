<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NMock2</name>
    </assembly>
    <members>
        <member name="T:NMock2.Matchers.TypeMatcher">
            <summary>
            Matcher that checks whether the actual object can be assigned to the expected type.
            </summary>
        </member>
        <member name="T:NMock2.Matcher">
            <summary>
            A matcher is used to match objects against it.
            </summary>
        </member>
        <member name="T:NMock2.ISelfDescribing">
            <summary>
            This interface is used to get a description of the implementator.
            </summary>
        </member>
        <member name="M:NMock2.ISelfDescribing.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="M:NMock2.Matcher.op_BitwiseAnd(NMock2.Matcher,NMock2.Matcher)">
            <summary>
            Logical and of to matchers.
            </summary>
            <param name="m1">First matcher.</param>
            <param name="m2">Second matcher.</param>
            <returns>Matcher combining the two operands.</returns>
        </member>
        <member name="M:NMock2.Matcher.op_BitwiseOr(NMock2.Matcher,NMock2.Matcher)">
            <summary>
            Logical or of to matchers.
            </summary>
            <param name="m1">First matcher.</param>
            <param name="m2">Second matcher.</param>
            <returns>Matcher combining the two operands.</returns>
        </member>
        <member name="M:NMock2.Matcher.op_LogicalNot(NMock2.Matcher)">
            <summary>
            Negation of a matcher.
            </summary>
            <param name="m">Matcher to negate.</param>
            <returns>Negation of the specified matcher.</returns>
        </member>
        <member name="M:NMock2.Matcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object matches.</returns>
        </member>
        <member name="M:NMock2.Matcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="M:NMock2.Matcher.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NMock2.Matchers.TypeMatcher.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.TypeMatcher"/> class.
            </summary>
            <param name="type">The expected type.</param>
        </member>
        <member name="M:NMock2.Matchers.TypeMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object castable to the expected type.</returns>
        </member>
        <member name="M:NMock2.Matchers.TypeMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Matchers.NullMatcher">
            <summary>
            Matcher that checks whether to actual value is equal to null.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.NullMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object is equal to null.</returns>
        </member>
        <member name="M:NMock2.Matchers.NullMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Internal.IExpectationOrdering">
            <summary>
            Represents expectations (order or unordered).
            </summary>
        </member>
        <member name="T:NMock2.IExpectation">
            <summary>
            Represents an expectation.
            </summary>
        </member>
        <member name="M:NMock2.IExpectation.Matches(NMock2.Monitoring.Invocation)">
            <summary>
            Checks whether stored expectations matches the specified invocation.
            </summary>
            <param name="invocation">The invocation to check.</param>
            <returns>Returns whether one of the stored expectations has met the specified invocation.</returns>
        </member>
        <member name="M:NMock2.IExpectation.MatchesIgnoringIsActive(NMock2.Monitoring.Invocation)">
            <summary>
            Matcheses the ignoring is active.
            </summary>
            <param name="invocation">The invocation.</param>
            <returns></returns>
        </member>
        <member name="M:NMock2.IExpectation.Perform(NMock2.Monitoring.Invocation)">
            <summary>
            Performs the specified invocation.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.IExpectation.DescribeActiveExpectationsTo(System.IO.TextWriter)">
            <summary>
            Describes the active expectations to.
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:NMock2.IExpectation.DescribeUnmetExpectationsTo(System.IO.TextWriter)">
            <summary>
            Describes the unmet expectations to.
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:NMock2.IExpectation.QueryExpectationsBelongingTo(NMock2.Internal.IMockObject,System.Collections.Generic.IList{NMock2.IExpectation})">
            <summary>
            Adds all expectations to <paramref name="result"/> that are associated to <paramref name="mock"/>.
            </summary>
            <param name="mock">The mock for which expectations are queried.</param>
            <param name="result">The result to add matching expectations to.</param>
        </member>
        <member name="P:NMock2.IExpectation.IsActive">
            <summary>
            Gets a value indicating whether this instance is active.
            </summary>
            <value><c>true</c> if this instance is active; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NMock2.IExpectation.HasBeenMet">
            <summary>
            Gets a value indicating whether this instance has been met.
            </summary>
            <value>
                <c>true</c> if this instance has been met; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:NMock2.Internal.IExpectationOrdering.AddExpectation(NMock2.IExpectation)">
            <summary>
            Adds an expectation.
            </summary>
            <param name="expectation">The expectation to add.</param>
        </member>
        <member name="M:NMock2.Internal.IExpectationOrdering.RemoveExpectation(NMock2.IExpectation)">
            <summary>
            Removes the specified expectation.
            </summary>
            <param name="expectation">The expectation to remove.</param>
        </member>
        <member name="F:NMock2.Internal.UnorderedExpectations.expectations">
            <summary>
            Stores the expectations that could be added.
            </summary>
        </member>
        <member name="F:NMock2.Internal.UnorderedExpectations.depth">
            <summary>
            Stores the calling depth for the document writer output.
            </summary>
        </member>
        <member name="F:NMock2.Internal.UnorderedExpectations.prompt">
            <summary>
            Stores the string to be presented whe describing the expectation.
            </summary>
        </member>
        <member name="M:NMock2.Internal.UnorderedExpectations.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.UnorderedExpectations"/> class.
            </summary>
        </member>
        <member name="M:NMock2.Internal.UnorderedExpectations.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.UnorderedExpectations"/> class.
            </summary>
            <param name="depth">The calling depth.</param>
        </member>
        <member name="M:NMock2.Internal.UnorderedExpectations.Matches(NMock2.Monitoring.Invocation)">
            <summary>
            Checks whether stored expectations matches the specified invocation.
            </summary>
            <param name="invocation">The invocation to check.</param>
            <returns>Returns whether one of the stored expectations has met the specified invocation.</returns>
        </member>
        <member name="M:NMock2.Internal.UnorderedExpectations.Perform(NMock2.Monitoring.Invocation)">
            <summary>
            Performs the specified invocation on the corresponding expectation if a match was found.
            </summary>
            <param name="invocation">The invocation to match.</param>
        </member>
        <member name="M:NMock2.Internal.UnorderedExpectations.QueryExpectationsBelongingTo(NMock2.Internal.IMockObject,System.Collections.Generic.IList{NMock2.IExpectation})">
            <summary>
            Adds all expectations to <paramref name="result"/> that are associated to <paramref name="mock"/>.
            </summary>
            <param name="mock">The mock for which expectations are queried.</param>
            <param name="result">The result to add matching expectations to.</param>
        </member>
        <member name="P:NMock2.Internal.UnorderedExpectations.IsActive">
            <summary>
            Gets a value indicating whether this instance is active.
            </summary>
            <value><c>true</c> if this instance is active; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NMock2.Internal.UnorderedExpectations.HasBeenMet">
            <summary>
            Gets a value indicating whether this instance has been met.
            </summary>
            <value>
                <c>true</c> if this instance has been met; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.INamingScope">
            <summary>
            Represents the scope of uniquenes of names for types and their members
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)">
            <summary>
            Gets a unique name based on <paramref name="suggestedName"/>
            </summary>
            <param name="suggestedName">Name suggested by the caller</param>
            <returns>Unique name based on <paramref name="suggestedName"/>.</returns>
            <remarks>
            Implementers should provide name as closely resembling <paramref name="suggestedName"/> as possible.
            Generally if no collision occurs it is suggested to return suggested name, otherwise append sequential suffix.
            Implementers must return deterministic names, that is when <see cref="M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)"/> is called twice 
            with the same suggested name, the same returned name should be provided each time. Non-deterministic return
            values, like appending random suffices will break serialization of proxies.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.INamingScope.SafeSubScope">
            <summary>
            Returns new, disposable naming scope. It is responsibilty of the caller to make sure that no naming collision
            with enclosing scope, or other subscopes is possible.
            </summary>
            <returns>New naming scope.</returns>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.ClassProxyGenerator">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.BaseProxyGenerator">
            <summary>
            Base class that exposes the common functionalities
            to proxy generation.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.GenerateParameterlessConstructor(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference)">
            <summary>
            Generates a parameters constructor that initializes the proxy
            state with <see cref="T:Castle.Core.Interceptor.StandardInterceptor"/> just to make it non-null.
            <para>
            This constructor is important to allow proxies to be XML serializable
            </para>
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.AddMappingNoCheck(System.Type,Castle.DynamicProxy.Contributors.ITypeContributor,System.Collections.Generic.IDictionary{System.Type,Castle.DynamicProxy.Contributors.ITypeContributor})">
            <summary>
            It is safe to add mapping (no mapping for the interface exists)
            </summary>
            <param name="implementer"></param>
            <param name="interface"></param>
            <param name="mapping"></param>
        </member>
        <member name="T:Castle.DynamicProxy.IProxyGenerationHook">
            <summary>
            Used during the target type inspection process. Implementors have a chance to customize the
            proxy generation process.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyGenerationHook.ShouldInterceptMethod(System.Type,System.Reflection.MethodInfo)">
            <summary>
            Invoked by the generation process to determine if the specified method should be proxied.
            </summary>
            <param name="type">The type which declares the given method.</param>
            <param name="methodInfo">The method to inspect.</param>
            <returns>True if the given method should be proxied; false otherwise.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyGenerationHook.NonVirtualMemberNotification(System.Type,System.Reflection.MemberInfo)">
            <summary>
            Invoked by the generation process to notify that a member was not marked as virtual.
            </summary>
            <param name="type">The type which declares the non-virtual member.</param>
            <param name="memberInfo">The non-virtual member.</param>
            <remarks>
            Non-virtual members cannot be proxied. This method gives an opportunity to inspect
            any non-virtual member of a type that has been requested to be proxied, and if
            appropriate - throw an exception to notify the caller.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyGenerationHook.MethodsInspected">
            <summary>
            Invoked by the generation process to notify that the whole process has completed.
            </summary>
        </member>
        <member name="T:Castle.Core.Resource.IResource">
            <summary>
            Represents a 'streamable' resource. Can
            be a file, a resource in an assembly.
            </summary>
        </member>
        <member name="M:Castle.Core.Resource.IResource.GetStreamReader">
            <summary>
            Returns a reader for the stream
            </summary>
            <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Resource.IResource.GetStreamReader(System.Text.Encoding)">
            <summary>
            Returns a reader for the stream
            </summary>
            <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Resource.IResource.CreateRelative(System.String)">
            <summary>
            Returns an instance of <see cref="T:Castle.Core.Resource.IResource"/>
            created according to the <c>relativePath</c>
            using itself as the root.
            </summary>
            <param name="relativePath"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.Core.Resource.IResource.FileBasePath">
            <summary>
            
            </summary>
            <remarks>
            Only valid for resources that
            can be obtained through relative paths
            </remarks>
        </member>
        <member name="T:Castle.Core.ProxyServices">
            <summary>
            List of utility methods related to dynamic proxy operations
            </summary>
        </member>
        <member name="M:Castle.Core.ProxyServices.IsDynamicProxy(System.Type)">
            <summary>
            Determines whether the specified type is a proxy generated by
            DynamicProxy (1 or 2).
            </summary>
            <param name="type">The type.</param>
            <returns>
            	<c>true</c> if it is a proxy; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Castle.Core.Pair`2">
            <summary>
            General purpose class to represent a standard pair of values. 
            </summary>
            <typeparam name="TFirst">Type of the first value</typeparam>
            <typeparam name="TSecond">Type of the second value</typeparam>
        </member>
        <member name="M:Castle.Core.Pair`2.#ctor(`0,`1)">
            <summary>
            Constructs a pair with its values
            </summary>
            <param name="first"></param>
            <param name="second"></param>
        </member>
        <member name="T:Castle.Core.Logging.TraceLogger">
            <summary>
            The TraceLogger sends all logging to the System.Diagnostics.TraceSource
            built into the .net framework. 
            </summary>
            <remarks>
            Logging can be configured in the system.diagnostics configuration 
            section. 
            
            If logger doesn't find a source name with a full match it will
            use source names which match the namespace partially. For example you can
            configure from all castle components by adding a source name with the
            name "Castle". 
            
            If no portion of the namespace matches the source named "Default" will
            be used.
            </remarks>
        </member>
        <member name="T:Castle.Core.Logging.LevelFilteredLogger">
            <summary>
            The Level Filtered Logger class.  This is a base clase which
            provides a LogLevel attribute and reroutes all functions into
            one Log method.
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.ILogger">
            <summary>
            Manages logging.
            </summary>
            <remarks>
            This is a facade for the different logging subsystems.
            It offers a simplified interface that follows IOC patterns
            and a simplified priority/level/severity abstraction. 
            </remarks>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Debug(System.String)">
            <summary>
            Logs a debug message.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Exception)">
            <summary>
            Logs a debug message. 
            </summary>
            <param name="exception">The exception to log</param>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Object[])">
            <summary>
            Logs a debug message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.String,System.Object[])">
            <summary>
            Logs a debug message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Logs a debug message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs a debug message.
            </summary>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs a debug message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Info(System.String)">
            <summary>
            Logs an info message.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Exception)">
            <summary>
            Logs an info message. 
            </summary>
            <param name="exception">The exception to log</param>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Object[])">
            <summary>
            Logs an info message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.String,System.Object[])">
            <summary>
            Logs an info message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Logs an info message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs an info message.
            </summary>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs an info message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Warn(System.String)">
            <summary>
            Logs a warn message.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Exception)">
            <summary>
            Logs a warn message. 
            </summary>
            <param name="exception">The exception to log</param>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Object[])">
            <summary>
            Logs a warn message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.String,System.Object[])">
            <summary>
            Logs a warn message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Logs a warn message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs a warn message.
            </summary>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs a warn message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Error(System.String)">
            <summary>
            Logs an error message.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Exception)">
            <summary>
            Logs an error message. 
            </summary>
            <param name="exception">The exception to log</param>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Object[])">
            <summary>
            Logs an error message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.String,System.Object[])">
            <summary>
            Logs an error message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Logs an error message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs an error message.
            </summary>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs an error message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String)">
            <summary>
            Logs a fatal message.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Exception)">
            <summary>
            Logs a fatal message. 
            </summary>
            <param name="exception">The exception to log</param>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Object[])">
            <summary>
            Logs a fatal message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.String,System.Object[])">
            <summary>
            Logs a fatal message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Logs a fatal message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs a fatal message.
            </summary>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs a fatal message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalError(System.String)">
            <summary>
            Logs a fatal error message.
            </summary>
            <param name="message">The Message</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalError(System.String,System.Exception)">
            <summary>
            Logs a fatal error message.
            </summary>
            <param name="message">The Message</param>
            <param name="exception">The Exception</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalError(System.String,System.Object[])">
            <summary>
            Logs a fatal error message.
            </summary>
            <param name="format">Message format</param>
            <param name="args">Array of objects to write using format</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.CreateChildLogger(System.String)">
            <summary>
            Create a new child logger.
            The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
            <param name="loggerName">The Subname of this logger.</param>
            <returns>The New ILogger instance.</returns> 
            <exception cref="T:System.ArgumentException">If the name has an empty element name.</exception>
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsDebugEnabled">
            <summary>
            Determines if messages of priority "debug" will be logged.
            </summary>
            <value>True if "debug" messages will be logged.</value> 
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsInfoEnabled">
            <summary>
            Determines if messages of priority "info" will be logged.
            </summary>
            <value>True if "info" messages will be logged.</value> 
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsWarnEnabled">
            <summary>
            Determines if messages of priority "warn" will be logged.
            </summary>
            <value>True if "warn" messages will be logged.</value> 
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsErrorEnabled">
            <summary>
            Determines if messages of priority "error" will be logged.
            </summary>
            <value>True if "error" messages will be logged.</value> 
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsFatalEnabled">
            <summary>
            Determines if messages of priority "fatal" will be logged.
            </summary>
            <value>True if "fatal" messages will be logged.</value> 
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsFatalErrorEnabled">
            <summary>
            Determines if messages of priority "fatalError" will be logged.
            </summary>
            <value>True if "fatalError" messages will be logged.</value>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.#ctor">
            <summary>
            Creates a new <c>LevelFilteredLogger</c>.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.InitializeLifetimeService">
            <summary>
            Keep the instance alive in a remoting scenario
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String)">
            <summary>
            Logs a debug message.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String,System.Exception)">
            <summary>
            Logs a debug message. 
            </summary>
            <param name="exception">The exception to log</param>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.String,System.Object[])">
            <summary>
            Logs a debug message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Logs a debug message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs a debug message.
            </summary>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs a debug message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String,System.Object[])">
            <summary>
            Logs a debug message.
            </summary>
            <param name="format">Message format</param>
            <param name="args">Array of objects to write using format</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String)">
            <summary>
            Logs an info message.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String,System.Exception)">
            <summary>
            Logs an info message. 
            </summary>
            <param name="exception">The exception to log</param>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.String,System.Object[])">
            <summary>
            Logs an info message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Logs an info message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs an info message.
            </summary>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs an info message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String,System.Object[])">
            <summary>
            Logs an info message.
            </summary>
            <param name="format">Message format</param>
            <param name="args">Array of objects to write using format</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String)">
            <summary>
            Logs a warn message.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String,System.Exception)">
            <summary>
            Logs a warn message. 
            </summary>
            <param name="exception">The exception to log</param>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.String,System.Object[])">
            <summary>
            Logs a warn message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Logs a warn message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs a warn message.
            </summary>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs a warn message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String,System.Object[])">
            <summary>
            Logs a warn message.
            </summary>
            <param name="format">Message format</param>
            <param name="args">Array of objects to write using format</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String)">
            <summary>
            Logs an error message.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String,System.Exception)">
            <summary>
            Logs an error message. 
            </summary>
            <param name="exception">The exception to log</param>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.String,System.Object[])">
            <summary>
            Logs an error message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Logs an error message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs an error message.
            </summary>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs an error message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String,System.Object[])">
            <summary>
            Logs an error message.
            </summary>
            <param name="format">Message format</param>
            <param name="args">Array of objects to write using format</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String)">
            <summary>
            Logs a fatal message.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String,System.Exception)">
            <summary>
            Logs a fatal message. 
            </summary>
            <param name="exception">The exception to log</param>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.String,System.Object[])">
            <summary>
            Logs a fatal message.
            </summary>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Logs a fatal message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs a fatal message.
            </summary>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Logs a fatal message.
            </summary>
            <param name="exception">The exception to log</param>
            <param name="formatProvider">The format provider to use</param>
            <param name="format">Format string for the message to log</param>
            <param name="args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String,System.Object[])">
            <summary>
            Logs a fatal message.
            </summary>
            <param name="format">Message format</param>
            <param name="args">Array of objects to write using format</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalError(System.String)">
            <summary>
            Logs a fatal error message.
            </summary>
            <param name="message">The Message</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalError(System.String,System.Exception)">
            <summary>
            Logs a fatal error message.
            </summary>
            <param name="message">The Message</param>
            <param name="exception">The Exception</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalError(System.String,System.Object[])">
            <summary>
            Logs a fatal error message.
            </summary>
            <param name="format">Message format</param>
            <param name="args">Array of objects to write using format</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
            <summary>
            Implementors output the log content by implementing this method only.
            Note that exception can be null
            </summary>
            <param name="loggerLevel"></param>
            <param name="loggerName"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.Level">
            <value>
            The <c>LoggerLevel</c> that this logger
            will be using. Defaults to <c>LoggerLevel.Off</c>
            </value>
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.Name">
            <value>
            The name that this logger will be using. 
            Defaults to <c>String.Empty</c>
            </value>
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsDebugEnabled">
            <summary>
            Determines if messages of priority "debug" will be logged.
            </summary>
            <value><c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Debug"/> bit</value> 
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsInfoEnabled">
            <summary>
            Determines if messages of priority "info" will be logged.
            </summary>
            <value><c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Info"/> bit</value> 
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsWarnEnabled">
            <summary>
            Determines if messages of priority "warn" will be logged.
            </summary>
            <value><c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Warn"/> bit</value> 
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsErrorEnabled">
            <summary>
            Determines if messages of priority "error" will be logged.
            </summary>
            <value><c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Error"/> bit</value> 
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsFatalEnabled">
            <summary>
            Determines if messages of priority "fatal" will be logged.
            </summary>
            <value><c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Fatal"/> bit</value> 
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsFatalErrorEnabled">
            <summary>
            Determines if messages of priority "fatal" will be logged.
            </summary>
            <value><c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Fatal"/> bit</value> 
        </member>
        <member name="M:Castle.Core.Logging.TraceLogger.#ctor(System.String)">
            <summary>
            Build a new trace logger based on the named TraceSource
            </summary>
            <param name="name">The name used to locate the best TraceSource. In most cases comes from the using type's fullname.</param>
        </member>
        <member name="M:Castle.Core.Logging.TraceLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
            Build a new trace logger based on the named TraceSource
            </summary>
            <param name="name">The name used to locate the best TraceSource. In most cases comes from the using type's fullname.</param>
            <param name="level">The default logging level at which this source should write messages. In almost all cases this
            default value will be overridden in the config file. </param>
        </member>
        <member name="M:Castle.Core.Logging.TraceLogger.CreateChildLogger(System.String)">
            <summary>
            Create a new child logger.
            The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
            <param name="loggerName">The Subname of this logger.</param>
            <returns>The New ILogger instance.</returns> 
        </member>
        <member name="T:NMock2.Syntax.ISetIndexerSyntax">
            <summary>
            Syntax defining an indexer set operation.
            </summary>
        </member>
        <member name="P:NMock2.Syntax.ISetIndexerSyntax.Item(System.Object[])">
            <summary>
            Defines the indexer.
            </summary>
            <value>Defines the value the indexer is set to.</value>
            <param name="args">The argument list.</param>
        </member>
        <member name="T:NMock2.Matchers.DescriptionOverride">
            <summary>
            Matcher that is used to change the description the wrapped matcher.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.DescriptionOverride.description">
            <summary>
            Stores the new description for the wrapped matcher.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.DescriptionOverride.otherMatcher">
            <summary>
            Stores the matcher to wrap.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.DescriptionOverride.#ctor(System.String,NMock2.Matcher)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.DescriptionOverride"/> class.
            </summary>
            <param name="description">The new description for the wrapped matcher.</param>
            <param name="otherMatcher">The matcher to wrap.</param>
        </member>
        <member name="M:NMock2.Matchers.DescriptionOverride.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the wrapped matcher matches.</returns>
        </member>
        <member name="M:NMock2.Matchers.DescriptionOverride.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Has">
            <summary>
            Provides shortcuts to matchers.
            </summary>
        </member>
        <member name="M:NMock2.Has.ToString(NMock2.Matcher)">
            <summary>
            Returns a matcher for testing string representation of objects.
            </summary>
            <param name="matcher">The wrapped matcher.</param>
            <returns>Returns a <see cref="T:NMock2.Matchers.ToStringMatcher"/> for testing string representation of objects.</returns>
        </member>
        <member name="M:NMock2.Has.Property(System.String,NMock2.Matcher)">
            <summary>
            Returns a matcher for checking property values.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="valueMatcher">The value matcher.</param>
            <returns>Returns a <see cref="T:NMock2.Matchers.PropertyMatcher"/> for checking property values.</returns>
        </member>
        <member name="M:NMock2.Has.Field(System.String,NMock2.Matcher)">
            <summary>
            Returns a matcher for checking field values.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <param name="valueMatcher">The value matcher.</param>
            <returns>Returns a <see cref="T:NMock2.Matchers.FieldMatcher"/> for checking field values.</returns>
        </member>
        <member name="T:NMock2.Expect">
            <summary>
            Defines expectations on dynamic mocks.
            Expectations that are not fulfilled result in exceptions in <see cref="M:NMock2.Mockery.VerifyAllExpectationsHaveBeenMet"/>
            or when the <see cref="T:NMock2.Mockery"/> is disposed.
            </summary>
        </member>
        <member name="M:NMock2.Expect.Exactly(System.Int32)">
            <summary>
            Gets a receiver of a method, property, etc. that has to be called exactly <paramref name="count"/> times.
            </summary>
            <param name="count">Expected number of invocations.</param>
            <returns>Returns a receiver of a method, property, etc. that has to be called exactly <paramref name="count"/> times.</returns>
        </member>
        <member name="M:NMock2.Expect.AtLeast(System.Int32)">
            <summary>
            Gets a receiver of a method, property, etc. that has to be called at least <paramref name="count"/> times.
            </summary>
            <param name="count">Minimal allowed number of invocations.</param>
            <returns>Returns a receiver of a method, property, etc. that has to be called at least <paramref name="count"/> times.</returns>
        </member>
        <member name="M:NMock2.Expect.AtMost(System.Int32)">
            <summary>
            Gets a receiver of a method, property, etc. that has to be called at most <paramref name="count"/> times.
            </summary>
            <param name="count">Maximal allowed number of invocations.</param>
            <returns>Returns a receiver of a method, property, etc. that has to be called at most <paramref name="count"/> times.</returns>
        </member>
        <member name="M:NMock2.Expect.Between(System.Int32,System.Int32)">
            <summary>
            Gets a receiver of a method, property, etc. that has to be called between <paramref name="minCount"/>
            and <paramref name="maxCount"/> times.
            </summary>
            <param name="minCount">Minimal allowed number of invocations.</param>
            <param name="maxCount">Maximaal allowed number of invocations.</param>
            <returns>Returns a receiver of a method, property, etc. that has to be called between <paramref name="count"/> times.</returns>
        </member>
        <member name="M:NMock2.Expect.On(System.Object)">
            <summary>
            Default expectation, specifies that a method, property, etc. that has to be called at least once.
            </summary>
            <param name="receiver">The receiver.</param>
            <returns>Returns a receiver of a method, property, etc. that has to be called at least once.</returns>
        </member>
        <member name="M:NMock2.Expect.Times(System.Int32)">
            <summary>
            Returns a string representing grammatically correctness of n times depending on the value of <paramref name="n"/>.
            </summary>
            <param name="n">An integer value representing n times.</param>
            <returns>String representation of n times.</returns>
        </member>
        <member name="P:NMock2.Expect.Never">
            <summary>
            Gets a receiver of a method, property, etc. that must never be called.
            </summary>
        </member>
        <member name="P:NMock2.Expect.Once">
            <summary>
            Gets a receiver of a method, property, etc. that has to be called exactly once.
            </summary>
        </member>
        <member name="P:NMock2.Expect.AtLeastOnce">
            <summary>
            Gets a receiver of a method, property, etc. that has to be called at least once.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferencesToObjectArrayExpression">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.LdcOpCodesDictionary">
            <summary>s
            Provides appropriate Ldc.X opcode for the type of primitive value to be loaded.
            </summary>
        </member>
        <member name="T:Castle.Core.Resource.IResourceFactory">
            <summary>
            Depicts the contract for resource factories.
            </summary>
        </member>
        <member name="M:Castle.Core.Resource.IResourceFactory.Accept(Castle.Core.Resource.CustomUri)">
            <summary>
            Used to check whether the resource factory
            is able to deal with the given resource
            identifier.
            </summary>
            <remarks>
            Implementors should return <c>true</c>
            only if the given identificator is supported
            by the resource factory
            </remarks>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri)">
            <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource"/> instance
            for the given resource identifier
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri,System.String)">
            <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource"/> instance
            for the given resource identifier
            </summary>
            <param name="uri"></param>
            <param name="basePath"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.Core.DependencyModelCollection">
            <summary>
            Collection of <see cref="T:Castle.Core.DependencyModel"/>.
            </summary>
        </member>
        <member name="M:Castle.Core.DependencyModelCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModelCollection"/> class.
            </summary>
        </member>
        <member name="M:Castle.Core.DependencyModelCollection.#ctor(System.Collections.Generic.IEnumerable{Castle.Core.DependencyModel})">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModelCollection"/> class.
            </summary>
            <param name="dependencies">The dependencies.</param>
        </member>
        <member name="T:Castle.Core.IInitializable">
            <summary>
            Lifecycle interface. If implemented by a component,
            the method Initialized will be invoked by the container
            before making the component available to the external world.
            </summary>
        </member>
        <member name="M:Castle.Core.IInitializable.Initialize">
            <summary>
            Implementors should perform any initialization logic.
            </summary>
        </member>
        <member name="T:Castle.Core.IServiceProviderExAccessor">
            <summary>
            This interface should be implemented by classes
            that are available in a bigger context, exposing
            the container to different areas in the same application.
            <para>
            For example, in Web application, the (global) HttpApplication
            subclasses should implement this interface to expose 
            the configured container
            </para>
            </summary>
        </member>
        <member name="T:Castle.Core.IVertex">
            <summary>
            Abstract representation of a vertex.
            </summary>
        </member>
        <member name="P:Castle.Core.GraphNode.Dependers">
            <summary>
            The nodes that dependes on this node
            </summary>
        </member>
        <member name="P:Castle.Core.GraphNode.Dependents">
            <summary>
            The nodes that this node depends
            </summary>
        </member>
        <member name="T:Castle.Core.ComponentActivatorAttribute">
            <summary>
            Associates a custom component with a component
            </summary>
        </member>
        <member name="M:Castle.Core.ComponentActivatorAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ComponentActivatorAttribute"/> class.
            </summary>
            <param name="componentActivatorType">Type of the component activator.</param>
        </member>
        <member name="P:Castle.Core.ComponentActivatorAttribute.ComponentActivatorType">
            <summary>
            Gets the type of the component activator.
            </summary>
            <value>The type of the component activator.</value>
        </member>
        <member name="T:NMock2.Syntax.IArgumentSyntax">
            <summary>
            Syntax for defining expected arguments of a method call.
            </summary>
        </member>
        <member name="T:NMock2.Syntax.IMatchSyntax">
            <summary>
            Syntax defining matching criterias.
            </summary>
        </member>
        <member name="T:NMock2.Syntax.IActionSyntax">
            <summary>
            Syntax for defining actions.
            </summary>
        </member>
        <member name="T:NMock2.Syntax.ICommentSyntax">
            <summary>
            Syntax for adding an explanation for the expectation.
            </summary>
        </member>
        <member name="M:NMock2.Syntax.ICommentSyntax.Comment(System.String)">
            <summary>
            Adds a comment for the expectation that is added to the error message if the expectation is not met.
            </summary>
            <param name="comment">The comment that is shown in the error message if this expectation is not met.
            You can describe here why this expectation has to be met.</param>
        </member>
        <member name="M:NMock2.Syntax.IActionSyntax.Will(NMock2.IAction[])">
            <summary>
            Defines what will happen.
            </summary>
            <param name="actions">The actions to take.</param>
            <returns>Returns the comment syntax defined after will.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMatchSyntax.Matching(NMock2.Matcher)">
            <summary>
            Defines a matching criteria.
            </summary>
            <param name="matcher">The matcher.</param>
            <returns>Action syntax defining the action to take.</returns>
        </member>
        <member name="M:NMock2.Syntax.IArgumentSyntax.With(System.Object[])">
            <summary>
            Defines the arguments that are expected on the method call.
            </summary>
            <param name="expectedArguments">The expected arguments.</param>
            <returns>Matcher syntax.</returns>
        </member>
        <member name="M:NMock2.Syntax.IArgumentSyntax.WithNoArguments">
            <summary>
            Defines that no arguments are expected on the method call.
            </summary>
            <returns>Matcher syntax.</returns>
        </member>
        <member name="M:NMock2.Syntax.IArgumentSyntax.WithAnyArguments">
            <summary>
            Defines that all arguments are allowed on the method call.
            </summary>
            <returns>Matcher syntax.</returns>
        </member>
        <member name="T:NMock2.Return">
            <summary>
            Defines the return value of a mocked method call.
            </summary>
        </member>
        <member name="M:NMock2.Return.Value(System.Object)">
            <summary>
            Returns a value as method return value.
            </summary>
            <param name="result">The result value.</param>
            <returns>Action defining the return value of a method.</returns>
        </member>
        <member name="M:NMock2.Return.CloneOf(System.ICloneable)">
            <summary>
            Returns a clone as method return value.
            </summary>
            <param name="prototype">The prototype to clone.</param>
            <returns>Action defining the return value of a method.</returns>
        </member>
        <member name="M:NMock2.Return.OutValue(System.String,System.Object)">
            <summary>
            Defines the value returned by an out parameter.
            </summary>
            <param name="parameterName">Name of the parameter.</param>
            <param name="value">The value to return.</param>
            <returns>Action defining the value of an out parameter.</returns>
        </member>
        <member name="M:NMock2.Return.OutValue(System.Int32,System.Object)">
            <summary>
            Defines the value returned by an out parameter.
            </summary>
            <param name="parameterIndex">Index of the parameter.</param>
            <param name="value">The value to return.</param>
            <returns>Action defining the value of an out parameter.</returns>
        </member>
        <member name="T:NMock2.Monitoring.CastleMockObjectFactory">
            <summary>
            Class that creates mocks for interfaces and classes (virtual members only) using the
            Castle proxy generator.
            </summary>
        </member>
        <member name="T:NMock2.Monitoring.IMockObjectFactory">
            <summary>
            Implementations of this interface are responsible for generating runtime
            proxies of classes and interfaces for use as mock objects.
            </summary>
            <remarks>
            Returned instances are expected to implement IMockObject and take care of
            intercepting calls to their public members. Intercepted calls should be
            forwarded on to the supplied Mockery for processing against expectations.
            </remarks>
        </member>
        <member name="M:NMock2.Monitoring.IMockObjectFactory.CreateMock(NMock2.Mockery,NMock2.Internal.CompositeType,System.String,NMock2.MockStyle,System.Object[])">
            <summary>
            Creates a mock of the specified type(s).
            </summary>
            <param name="mockery">The mockery used to create this mock instance.</param>
            <param name="typesToMock">The type(s) to include in the mock.</param>
            <param name="name">The name to use for the mock instance.</param>
            <param name="mockStyle">The behaviour of the mock instance when first created.</param>
            <param name="constructorArgs">Constructor arguments for the class to be mocked. Only valid if mocking a class type.</param>
            <returns>A mock instance of the specified type(s).</returns>
        </member>
        <member name="M:NMock2.Monitoring.CastleMockObjectFactory.CreateMock(NMock2.Mockery,NMock2.Internal.CompositeType,System.String,NMock2.MockStyle,System.Object[])">
            <summary>
            Creates a mock of the specified type(s).
            </summary>
            <param name="mockery">The mockery used to create this mock instance.</param>
            <param name="typesToMock">The type(s) to include in the mock.</param>
            <param name="name">The name to use for the mock instance.</param>
            <param name="mockStyle">The behaviour of the mock instance when first created.</param>
            <param name="constructorArgs">Constructor arguments for the class to be mocked. Only valid if mocking a class type.</param>
            <returns>A mock instance of the specified type(s).</returns>
        </member>
        <member name="T:NMock2.Monitoring.CastleMockObjectFactory.InterfaceMockBase">
            <summary>
            Used as a base for interface mocks in order to provide a holder
            for a meaningful ToString() value.
            </summary>
        </member>
        <member name="M:NMock2.Monitoring.CastleMockObjectFactory.InterfaceMockBase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Monitoring.CastleMockObjectFactory.InterfaceMockBase"/> class.
            </summary>
        </member>
        <member name="M:NMock2.Monitoring.CastleMockObjectFactory.InterfaceMockBase.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Monitoring.CastleMockObjectFactory.InterfaceMockBase"/> class.
            </summary>
            <param name="stringValue">The string value.</param>
        </member>
        <member name="T:NMock2.Matchers.SameMatcher">
            <summary>
            Matcher that checks whether the actual object is the same as the expected one (equality by reference).
            </summary>
        </member>
        <member name="M:NMock2.Matchers.SameMatcher.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.SameMatcher"/> class.
            </summary>
            <param name="expected">The expected object.</param>
        </member>
        <member name="M:NMock2.Matchers.SameMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object is the same as the expected one.</returns>
        </member>
        <member name="M:NMock2.Matchers.SameMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Matchers.OrMatcher">
            <summary>
            Matcher that combines two matcher with a logically or.
            </summary>
        </member>
        <member name="T:NMock2.Matchers.BinaryOperator">
            <summary>
            BinaryOperator is an abstract base class for matchers that combine two matchers into a single matcher. 
            </summary>
        </member>
        <member name="F:NMock2.Matchers.BinaryOperator.Right">
            <summary>
            The right hand side of the binary operator.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.BinaryOperator.Left">
            <summary>
            The left hand side of the binary operator.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.BinaryOperator.#ctor(NMock2.Matcher,NMock2.Matcher)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.BinaryOperator"/> class.
            </summary>
            <param name="left">The left operand.</param>
            <param name="right">The right operand.</param>
        </member>
        <member name="M:NMock2.Matchers.OrMatcher.#ctor(NMock2.Matcher,NMock2.Matcher)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.OrMatcher"/> class.
            </summary>
            <param name="left">The left operand.</param>
            <param name="right">The right operand.</param>
        </member>
        <member name="M:NMock2.Matchers.OrMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object matches one of the two combined matchers.</returns>
        </member>
        <member name="M:NMock2.Matchers.OrMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Matchers.ComparisonMatcher">
            <summary>
            Matcher that checks a value against upper and lower bounds.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.ComparisonMatcher.value">
            <summary>
            Stores the value to be compared.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.ComparisonMatcher.minComparisonResult">
            <summary>
            Stores the minimum comparison result for a successful match.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.ComparisonMatcher.maxComparisonResult">
            <summary>
            Stores the maximum comparison result for a successful match.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.ComparisonMatcher.#ctor(System.IComparable,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.ComparisonMatcher"/> class.
            </summary>
            <param name="value">The value to compare.</param>
            <param name="comparisonResult1">The first allowed comparison result (result of value.CompareTo(other)).</param>
            <param name="comparisonResult2">The second allowed comparison result (result of value.CompareTo(other)).</param>
        </member>
        <member name="M:NMock2.Matchers.ComparisonMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object compared to the value resulted in either of both specified comparison results.</returns>
        </member>
        <member name="M:NMock2.Matchers.ComparisonMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:Castle.DynamicProxy.Serialization.ProxyObjectReference">
            <summary>
            Handles the deserialization of proxies.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope">
            <summary>
            Resets the <see cref="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope"/> used for deserialization to a new scope.
            </summary>
            <remarks>This is useful for test cases.</remarks>
        </member>
        <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.SetScope(Castle.DynamicProxy.ModuleScope)">
            <summary>
            Resets the <see cref="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope"/> used for deserialization to a given <paramref name="scope"/>.
            </summary>
            <param name="scope">The scope to be used for deserialization.</param>
            <remarks>By default, the deserialization process uses a different scope than the rest of the application, which can lead to multiple proxies
            being generated for the same type. By explicitly setting the deserialization scope to the application's scope, this can be avoided.</remarks>
        </member>
        <member name="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope">
            <summary>
            Gets the <see cref="T:Castle.DynamicProxy.ModuleScope"/> used for deserialization.
            </summary>
            <value>As <see cref="T:Castle.DynamicProxy.Serialization.ProxyObjectReference"/> has no way of automatically determining the scope used by the application (and the application
            might use more than one scope at the same time), <see cref="T:Castle.DynamicProxy.Serialization.ProxyObjectReference"/> uses a dedicated scope instance for deserializing proxy
            types. This instance can be reset and set to a specific value via <see cref="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope"/> and <see cref="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.SetScope(Castle.DynamicProxy.ModuleScope)"/>.</value>
        </member>
        <member name="M:Castle.DynamicProxy.Contributors.MembersCollector.IsAccessible(System.Reflection.MethodBase)">
            <summary>
            Checks if the method is public or protected.
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.DynamicProxy.Contributors.MembersCollector.AcceptMethod(System.Reflection.MethodInfo,System.Boolean,Castle.DynamicProxy.IProxyGenerationHook)">
            <summary>
            Performs some basic screening and invokes the <see cref="T:Castle.DynamicProxy.IProxyGenerationHook"/>
            to select methods.
            </summary>
            <param name="method"></param>
            <param name="onlyVirtuals"></param>
            <param name="hook"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.DynamicProxy.AttributeUtil.AddDisassembler``1(Castle.DynamicProxy.IAttributeDisassembler)">
            <summary>
            Registers custom disassembler to handle disassembly of specified type of attributes.
            </summary>
            <typeparam name="TAttribute">Type of attributes to handle</typeparam>
            <param name="disassembler">Disassembler converting existing instances of Attributes to CustomAttributeBuilders</param>
            <remarks>
            When disassembling an attribute Dynamic Proxy will first check if an custom disassembler has been registered to handle attributes of that type, 
            and if none is found, it'll use the <see cref="P:Castle.DynamicProxy.AttributeUtil.FallbackDisassembler"/>.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.AttributeUtil.ShouldSkipAttributeReplication(System.Type)">
            <summary>
            Attributes should be replicated if they are non-inheritable,
            but there are some special cases where the attributes means
            something to the CLR, where they should be skipped.
            </summary>
        </member>
        <member name="T:Castle.Core.Configuration.MutableConfiguration">
            <summary>
            Summary description for MutableConfiguration.
            </summary>
        </member>
        <member name="T:Castle.Core.Configuration.AbstractConfiguration">
            <summary>
            This is an abstract <see cref="T:Castle.Core.Configuration.IConfiguration"/> implementation
            that deals with methods that can be abstracted away
            from underlying implementations.
            </summary>
            <remarks>
            <para><b>AbstractConfiguration</b> makes easier to implementers 
            to create a new version of <see cref="T:Castle.Core.Configuration.IConfiguration"/></para>
            </remarks>
        </member>
        <member name="T:Castle.Core.Configuration.IConfiguration">
            <summary>
            <see cref="T:Castle.Core.Configuration.IConfiguration"/> is a interface encapsulating a configuration node
            used to retrieve configuration values.
            </summary>
        </member>
        <member name="M:Castle.Core.Configuration.IConfiguration.GetValue(System.Type,System.Object)">
            <summary>
            Gets the value of the node and converts it 
            into specified <see cref="T:System.Type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/></param>
            <param name="defaultValue">
            The Default value returned if the convertion fails.
            </param>
            <returns>The Value converted into the specified type.</returns>
        </member>
        <member name="P:Castle.Core.Configuration.IConfiguration.Name">
            <summary>
            Gets the name of the node.
            </summary>
            <value>
            The Name of the node.
            </value> 
        </member>
        <member name="P:Castle.Core.Configuration.IConfiguration.Value">
            <summary>
            Gets the value of the node.
            </summary>
            <value>
            The Value of the node.
            </value> 
        </member>
        <member name="P:Castle.Core.Configuration.IConfiguration.Children">
            <summary>
            Gets an <see cref="T:Castle.Core.Configuration.ConfigurationCollection"/> of <see cref="T:Castle.Core.Configuration.IConfiguration"/>
            elements containing all node children.
            </summary>
            <value>The Collection of child nodes.</value>
        </member>
        <member name="P:Castle.Core.Configuration.IConfiguration.Attributes">
            <summary>
            Gets an <see cref="T:System.Collections.IDictionary"/> of the configuration attributes.
            </summary>
        </member>
        <member name="M:Castle.Core.Configuration.AbstractConfiguration.GetValue(System.Type,System.Object)">
            <summary>
            Gets the value of the node and converts it
            into specified <see cref="T:System.Type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/></param>
            <param name="defaultValue">
            The Default value returned if the convertion fails.
            </param>
            <returns>The Value converted into the specified type.</returns>
        </member>
        <member name="P:Castle.Core.Configuration.AbstractConfiguration.Name">
            <summary>
            Gets the name of the <see cref="T:Castle.Core.Configuration.IConfiguration"/>.
            </summary>
            <value>
            The Name of the <see cref="T:Castle.Core.Configuration.IConfiguration"/>.
            </value>
        </member>
        <member name="P:Castle.Core.Configuration.AbstractConfiguration.Value">
            <summary>
            Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration"/>.
            </summary>
            <value>
            The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration"/>.
            </value>
        </member>
        <member name="P:Castle.Core.Configuration.AbstractConfiguration.Children">
            <summary>
            Gets all child nodes.
            </summary>
            <value>The <see cref="T:Castle.Core.Configuration.ConfigurationCollection"/> of child nodes.</value>
        </member>
        <member name="P:Castle.Core.Configuration.AbstractConfiguration.Attributes">
            <summary>
            Gets node attributes.
            </summary>
            <value>
            All attributes of the node.
            </value>
        </member>
        <member name="M:Castle.Core.Configuration.MutableConfiguration.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.Configuration.MutableConfiguration"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="P:Castle.Core.Configuration.MutableConfiguration.Value">
            <summary>
            Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration"/>.
            </summary>
            <value>
            The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration"/>.
            </value>
        </member>
        <member name="T:Castle.Core.Logging.ConsoleLogger">
            <summary>
            The Logger sending everything to the standard output streams.
            This is mainly for the cases when you have a utility that
            does not have a logger to supply.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor">
            <summary>
            Creates a new ConsoleLogger with the <c>Level</c>
            set to <c>LoggerLevel.Debug</c> and the <c>Name</c>
            set to <c>String.Empty</c>.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(Castle.Core.Logging.LoggerLevel)">
            <summary>
            Creates a new ConsoleLogger with the <c>Name</c>
            set to <c>String.Empty</c>.
            </summary>
            <param name="logLevel">The logs Level.</param>
        </member>
        <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String)">
            <summary>
            Creates a new ConsoleLogger with the <c>Level</c>
            set to <c>LoggerLevel.Debug</c>.
            </summary>
            <param name="name">The logs Name.</param>
        </member>
        <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
            Creates a new ConsoleLogger.
            </summary>
            <param name="name">The logs Name.</param>
            <param name="logLevel">The logs Level.</param>
        </member>
        <member name="M:Castle.Core.Logging.ConsoleLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
            <summary>
            A Common method to log.
            </summary>
            <param name="loggerLevel">The level of logging</param>
            <param name="loggerName">The name of the logger</param>
            <param name="message">The Message</param>
            <param name="exception">The Exception</param>
        </member>
        <member name="M:Castle.Core.Logging.ConsoleLogger.CreateChildLogger(System.String)">
            <summary>
            Returns a new <c>ConsoleLogger</c> with the name
            added after this loggers name, with a dot in between.
            </summary>
            <param name="loggerName">The added hierarchical name.</param>
            <returns>A new <c>ConsoleLogger</c>.</returns> 
        </member>
        <member name="T:Castle.Core.Logging.StreamLoggerFactory">
            <summary>
            Creates <see cref="T:Castle.Core.Logging.StreamLogger"/> outputing 
            to files. The name of the file is derived from the log name
            plus the 'log' extension.
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.ILoggerFactory">
            <summary>
            Manages the instantiation of <see cref="T:Castle.Core.Logging.ILogger"/>s.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type)">
            <summary>
            Creates a new logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String)">
            <summary>
            Creates a new logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
            <summary>
            Creates a new logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
            Creates a new logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.AbstractLoggerFactory.GetConfigFile(System.String)">
            <summary>
            Gets the configuration file.
            </summary>
            <param name="fileName">i.e. log4net.config</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Internal.LinkedList.GetNode(System.Int32)">
            <summary>
            Returns the node at the specified index.
            </summary>
            <param name="index">The lookup index.</param>
            <returns>The node at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If the specified <paramref name="index"/> is greater than the
            number of objects within the list.
            </exception>
        </member>
        <member name="M:Castle.Core.Internal.LinkedList.ValidateIndex(System.Int32)">
            <summary>
            Validates the specified index.
            </summary>
            <param name="index">The lookup index.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If the index is invalid.
            </exception>
        </member>
        <member name="T:Castle.Core.Interceptor.IOnBehalfAware">
            <summary>
            Interceptors might implement this to receive the
            ComponentModel on behalf of the component where the
            interceptor is acting.
            </summary>
        </member>
        <member name="T:Castle.Core.Interceptor.IInterceptorSelector">
            <summary>
            Provides an extension point that allows proxies to choose specific interceptors on
            a per method basis.
            </summary>
        </member>
        <member name="M:Castle.Core.Interceptor.IInterceptorSelector.SelectInterceptors(System.Type,System.Reflection.MethodInfo,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Selects the interceptors that should intercept calls to the given <paramref name="method"/>.
            </summary>
            <param name="type">The type declaring the method to intercept.</param>
            <param name="method">The method that will be intercepted.</param>
            <param name="interceptors">All interceptors registered with the proxy.</param>
            <returns>An array of interceptors to invoke upon calling the <paramref name="method"/>.</returns>
            <remarks>
            This method is called only once per proxy instance, upon the first call to the
            <paramref name="method"/>. Either an empty array or null are valid return values to indicate
            that no interceptor should intercept calls to the method. Although it is not advised, it is
            legal to return other <see cref="T:Castle.Core.Interceptor.IInterceptor"/> implementations than these provided in
            <paramref name="interceptors"/>.
            </remarks>
        </member>
        <member name="T:Castle.Core.LifestyleAttribute">
            <summary>
            Base for Attributes that want to express lifestyle
            chosen by the component.
            </summary>
        </member>
        <member name="M:Castle.Core.LifestyleAttribute.#ctor(Castle.Core.LifestyleType)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.LifestyleAttribute"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="P:Castle.Core.LifestyleAttribute.Lifestyle">
            <summary>
            Gets or sets the lifestyle.
            </summary>
            <value>The lifestyle.</value>
        </member>
        <member name="T:Castle.Core.SingletonAttribute">
            <summary>
            Indicates that the target components wants a
            singleton lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.SingletonAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.SingletonAttribute"/> class.
            </summary>
        </member>
        <member name="T:Castle.Core.TransientAttribute">
            <summary>
            Indicates that the target components wants a
            transient lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.TransientAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.TransientAttribute"/> class.
            </summary>
        </member>
        <member name="T:Castle.Core.PerThreadAttribute">
            <summary>
            Indicates that the target components wants a
            per thread lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.PerThreadAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PerThreadAttribute"/> class.
            </summary>
        </member>
        <member name="T:Castle.Core.PerWebRequestAttribute">
            <summary>
            Indicates that the target components wants a
            per web request lifestyle.
            </summary>
        </member>
        <member name="T:Castle.Core.PooledAttribute">
            <summary>
            Indicates that the target components wants a
            pooled lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.PooledAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute"/> class
            using the default initial pool size (5) and the max pool size (15).
            </summary>
        </member>
        <member name="M:Castle.Core.PooledAttribute.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute"/> class.
            </summary>
            <param name="initialPoolSize">Initial size of the pool.</param>
            <param name="maxPoolSize">Max pool size.</param>
        </member>
        <member name="P:Castle.Core.PooledAttribute.InitialPoolSize">
            <summary>
            Gets the initial size of the pool.
            </summary>
            <value>The initial size of the pool.</value>
        </member>
        <member name="P:Castle.Core.PooledAttribute.MaxPoolSize">
            <summary>
            Gets the maximum pool size.
            </summary>
            <value>The size of the max pool.</value>
        </member>
        <member name="T:Castle.Core.CustomLifestyleAttribute">
            <summary>
            Indicates that the target components wants a
            custom lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.CustomLifestyleAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CustomLifestyleAttribute"/> class.
            </summary>
            <param name="lifestyleHandlerType">The lifestyle handler.</param>
        </member>
        <member name="P:Castle.Core.CustomLifestyleAttribute.LifestyleHandlerType">
            <summary>
            Gets the type of the lifestyle handler.
            </summary>
            <value>The type of the lifestyle handler.</value>
        </member>
        <member name="T:NMock2.Syntax.IEventArgumentSyntax">
            <summary>
            Syntax for defining event arguments.
            </summary>
        </member>
        <member name="M:NMock2.Syntax.IEventArgumentSyntax.With(System.Object[])">
            <summary>
            Defines the event arguments.
            </summary>
            <param name="args">The event args.</param>
        </member>
        <member name="T:NMock2.MockStyle">
            <summary>
            Specifies how a mock object should behave when it is first created.
            </summary>
        </member>
        <member name="F:NMock2.MockStyle.Default">
            <summary>
            Calls to members that do not have expectations set will
            result in ExpectationExceptions.
            </summary>
        </member>
        <member name="F:NMock2.MockStyle.Transparent">
            <summary>
            Calls to members that do not have expectations set will
            pass through to the underlying implementation on the class
            being mocked.
            </summary>
        </member>
        <member name="F:NMock2.MockStyle.Stub">
            <summary>
            Calls to members that do not have expectations set will
            be ignored. Default values are used for return values 
            (default value of the return type, stub or empty enumerable)
            and the same value is returned on every call to the same member.
            </summary>
        </member>
        <member name="T:NMock2.Matchers.PropertyMatcher">
            <summary>
            Matcher that checks whether the actual object has a property with the specified name 
            and its value matches the specified matcher.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.PropertyMatcher.#ctor(System.String,NMock2.Matcher)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.PropertyMatcher"/> class.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="valueMatcher">The value matcher.</param>
        </member>
        <member name="M:NMock2.Matchers.PropertyMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object has a property with the expected name and expected value.</returns>
        </member>
        <member name="M:NMock2.Matchers.PropertyMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Matchers.GenericMethodTypeParametersMatcher">
            <summary>
            Matcher that checks whether parameters of a method match with the specified list of matchers.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.GenericMethodTypeParametersMatcher.typeMatchers">
            <summary>
            An ordered list of type <see cref="T:NMock2.Matcher"/>'s each matching a single method argument.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.GenericMethodTypeParametersMatcher.#ctor(NMock2.Matcher[])">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.GenericMethodTypeParametersMatcher"/> class.
            </summary>
            <param name="typeMatchers">The value matchers. This is an ordered list of matchers, each matching a single method argument.</param>
        </member>
        <member name="M:NMock2.Matchers.GenericMethodTypeParametersMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object is an <see cref="T:NMock2.Monitoring.Invocation"/> and all method arguments match their corresponding matcher.</returns>
        </member>
        <member name="M:NMock2.Matchers.GenericMethodTypeParametersMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="M:NMock2.Matchers.GenericMethodTypeParametersMatcher.MatcherCount">
            <summary>
            Number of argument matchers.
            </summary>
            <returns>Returns the number of argument matchers.</returns>
        </member>
        <member name="M:NMock2.Matchers.GenericMethodTypeParametersMatcher.LastMatcher">
            <summary>
            Returns the last argument matcher.
            </summary>
            <returns>Argument matcher</returns>
        </member>
        <member name="M:NMock2.Matchers.GenericMethodTypeParametersMatcher.WriteListOfMatchers(System.Int32,System.IO.TextWriter)">
            <summary>
            Writes the list of matchers to a <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="listLength">Length of the list.</param>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:NMock2.Matchers.GenericMethodTypeParametersMatcher.MatchesTypes(NMock2.Monitoring.Invocation)">
            <summary>
            Determines whether the arguments of the invocation matches the initial arguments.
            </summary>
            <param name="invocation">The invocation to match against the initial arguments.</param>
            <returns>
            Returns true if invocation matches the initial arguments; false otherwise.
            </returns>
        </member>
        <member name="M:NMock2.Matchers.GenericMethodTypeParametersMatcher.MatchesTypeValues(NMock2.Monitoring.Invocation)">
            <summary>
            Determines whether all argument types of the generic method matches the invocation.
            </summary>
            <param name="invocation">The invocation to match against the initial argument types.</param>
            <returns>
            Returns true if invocation types matches the inital argument types; false otherwise.
            </returns>
        </member>
        <member name="T:NMock2.Matchers.ElementMatcher">
            <summary>
            Matcher that checks whether a single object is in a collection of elements.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.ElementMatcher.#ctor(System.Collections.ICollection)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.ElementMatcher"/> class.
            </summary>
            <param name="collection">The collection to match against.</param>
        </member>
        <member name="M:NMock2.Matchers.ElementMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="actual">The object to match.</param>
            <returns>Whether to object matches.</returns>
        </member>
        <member name="M:NMock2.Matchers.ElementMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Fire">
            <summary>
            Fires a mocked event.
            </summary>
        </member>
        <member name="M:NMock2.Fire.Event(System.String)">
            <summary>
            Fires the specified event.
            </summary>
            <param name="eventName">Name of the event.</param>
            <returns>Returns the event mock corresponding to the given <paramref name="eventName"/>.</returns>
        </member>
        <member name="M:NMock2.Fire.On(System.Object)">
            <summary>
            Defines the mock the event is fired on.
            </summary>
            <param name="mock">The mock the event is fired on.</param>
            <returns>Returns the event fire syntax.</returns>
        </member>
        <member name="T:Castle.Core.Resource.FileResource">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.Core.Resource.AbstractStreamResource">
            <summary>
            
            </summary>
        </member>
        <member name="F:Castle.Core.Resource.AbstractStreamResource.createStream">
            <summary>
            This returns a new stream instance each time it is called.
            It is the responsability of the caller to dispose of this stream
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.StreamLogger">
            <summary>
            The Stream Logger class.  This class can stream log information
            to any stream, it is suitable for storing a log file to disk,
            or to a <c>MemoryStream</c> for testing your components.
            </summary>
            <remarks>
            This logger is not thread safe.
            </remarks>
        </member>
        <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream)">
            <summary>
            Creates a new <c>StreamLogger</c> with default encoding 
            and buffer size. Initial Level is set to Debug.
            </summary>
            <param name="name">
            The name of the log.
            </param>
            <param name="stream">
            The stream that will be used for logging,
            seeking while the logger is alive 
            </param>
        </member>
        <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Creates a new <c>StreamLogger</c> with default buffer size.
            Initial Level is set to Debug.
            </summary>
            <param name="name">
            The name of the log.
            </param>
            <param name="stream">
            The stream that will be used for logging,
            seeking while the logger is alive 
            </param>
            <param name="encoding">
            The encoding that will be used for this stream.
            <see cref="T:System.IO.StreamWriter"/>
            </param>
        </member>
        <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding,System.Int32)">
            <summary>
            Creates a new <c>StreamLogger</c>. 
            Initial Level is set to Debug.
            </summary>
            <param name="name">
            The name of the log.
            </param>
            <param name="stream">
            The stream that will be used for logging,
            seeking while the logger is alive 
            </param>
            <param name="encoding">
            The encoding that will be used for this stream.
            <see cref="T:System.IO.StreamWriter"/>
            </param>
            <param name="bufferSize">
            The buffer size that will be used for this stream.
            <see cref="T:System.IO.StreamWriter"/>
            </param>
        </member>
        <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.StreamWriter)">
            <summary>
            Creates a new <c>StreamLogger</c> with 
            Debug as default Level.
            </summary>
            <param name="name">The name of the log.</param>
            <param name="writer">The <c>StreamWriter</c> the log will write to.</param>
        </member>
        <member name="T:Castle.Core.IRecyclable">
            <summary>
            Only called for components that 
            belongs to a pool when the component
            comes back to the pool.
            </summary>
        </member>
        <member name="M:Castle.Core.IRecyclable.Recycle">
            <summary>
            Implementors should perform any 
            initialization/clean up.
            </summary>
        </member>
        <member name="M:Castle.Core.Internal.Lock.Create">
            <summary>
            Creates a new lock.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NMock2.Matchers.FieldMatcher">
            <summary>
            Matcher that checks whether the specified field of the actual object matches with the specified matcher. 
            </summary>
        </member>
        <member name="F:NMock2.Matchers.FieldMatcher.fieldName">
            <summary>
            Name of the field to match against the <seealso cref="F:NMock2.Matchers.FieldMatcher.valueMatcher"/>.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.FieldMatcher.valueMatcher">
            <summary>
            The value <see cref="T:NMock2.Matcher"/> used to match the field of the object under investigation.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.FieldMatcher.#ctor(System.String,NMock2.Matcher)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.FieldMatcher"/> class.
            </summary>
            <param name="fieldName">Name of the field to match against the <paramref name="valueMatcher"/>.</param>
            <param name="valueMatcher">The value matcher.</param>
        </member>
        <member name="M:NMock2.Matchers.FieldMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object matches.</returns>
        </member>
        <member name="M:NMock2.Matchers.FieldMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Collect">
            <summary>
            Gather information about invocations.
            </summary>
        </member>
        <member name="M:NMock2.Collect.MethodArgument``1(System.Int32,NMock2.Actions.CollectAction{``0}.Collect)">
            <summary>
            Calls the specified <paramref name="collectDelegate"/> with the method argument at index <paramref name="argumentIndex"/>.
            Can only be used as action of an expectation on a method call.
            </summary>
            <typeparam name="TArgument">The type of the argument.</typeparam>
            <param name="argumentIndex">Index of the argument.</param>
            <param name="collectDelegate">The collect delegate.</param>
            <returns>Action that collects a method argument.</returns>
        </member>
        <member name="M:NMock2.Collect.PropertyValue``1(NMock2.Actions.CollectAction{``0}.Collect)">
            <summary>
            Calls the specified <paramref name="collectDelegate"/> with the value that is set to the property.
            Can only be used as action of an expectation on a property setter. 
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="collectDelegate">The collect delegate.</param>
            <returns>Action that collects a property value.</returns>
        </member>
        <member name="T:Castle.DynamicProxy.Tokens.InvocationMethods">
            <summary>
            Holds <see cref="T:System.Reflection.MethodInfo"/> objects representing methods of <see cref="T:Castle.DynamicProxy.AbstractInvocation"/> class.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForConstantValue(System.Reflection.Emit.ILGenerator,System.Object)">
            <summary>
            Emits a load opcode of the appropriate kind for a constant string or
            primitive value.
            </summary>
            <param name="gen"></param>
            <param name="value"></param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForDefaultValueOfType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            Emits a load opcode of the appropriate kind for the constant default value of a
            type, such as 0 for value types and null for reference types.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            Emits a load indirect opcode of the appropriate type for a value or object reference.
            Pops a pointer off the evaluation stack, dereferences it and loads
            a value of the specified type.
            </summary>
            <param name="gen"></param>
            <param name="type"></param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitStoreIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            Emits a store indirectopcode of the appropriate type for a value or object reference.
            Pops a value of the specified type and a pointer off the evaluation stack, and
            stores the value.
            </summary>
            <param name="gen"></param>
            <param name="type"></param>
        </member>
        <member name="T:Castle.DynamicProxy.Contributors.ITypeContributor">
            <summary>
            Interface describing elements composing generated type
            </summary>
        </member>
        <member name="T:Castle.Core.LifecycleStepCollection">
            <summary>
            Represents a collection of ordered lifecycle steps.
            </summary>
        </member>
        <member name="M:Castle.Core.LifecycleStepCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.LifecycleStepCollection"/> class.
            </summary>
        </member>
        <member name="M:Castle.Core.LifecycleStepCollection.GetCommissionSteps">
            <summary>
            Returns all steps for the commission phase
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.LifecycleStepCollection.GetDecommissionSteps">
            <summary>
            Returns all steps for the decommission phase
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.LifecycleStepCollection.Add(Castle.Core.LifecycleStepType,System.Object)">
            <summary>
            Adds a step to the commission or decomission phases.
            </summary>
            <param name="type"></param>
            <param name="stepImplementation"></param>
        </member>
        <member name="M:Castle.Core.LifecycleStepCollection.AddFirst(Castle.Core.LifecycleStepType,System.Object)">
            <summary>
            Adds a step as the first step to execute for the commission or decomission phase.
            </summary>
            <param name="type"></param>
            <param name="stepImplementation"></param>
        </member>
        <member name="M:Castle.Core.LifecycleStepCollection.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of
            the <see cref="T:System.Collections.ICollection"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="array"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is less than zero.</exception>
            <exception cref="T:System.ArgumentException">
            	<para>
            		<paramref name="array"/> is multidimensional.</para>
            	<para>-or-</para>
            	<para>
            		<paramref name="index"/> is equal to or greater than the length of <paramref name="array"/>.</para>
            	<para>-or-</para>
            	<para>The number of elements in the source <see cref="T:System.Collections.ICollection"/> is greater than the available space from <paramref name="index"/> to the end of the destination <paramref name="array"/>.</para>
            </exception>
            <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the destination <paramref name="array"/>.</exception>
        </member>
        <member name="M:Castle.Core.LifecycleStepCollection.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/>
            that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Castle.Core.LifecycleStepCollection.HasCommissionSteps">
            <summary>
            Gets a value indicating whether this instance has commission steps.
            </summary>
            <value>
            	<c>true</c> if this instance has commission steps; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.LifecycleStepCollection.HasDecommissionSteps">
            <summary>
            Gets a value indicating whether this instance has decommission steps.
            </summary>
            <value>
            	<c>true</c> if this instance has decommission steps; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.LifecycleStepCollection.Count">
            <summary>
            Gets the number of
            elements contained in the <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.Core.LifecycleStepCollection.SyncRoot">
            <summary>
            Gets an object that
            can be used to synchronize access to the <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.Core.LifecycleStepCollection.IsSynchronized">
            <summary>
            Gets a value
            indicating whether access to the <see cref="T:System.Collections.ICollection"/> is synchronized
            (thread-safe).
            </summary>
            <value></value>
        </member>
        <member name="T:Castle.Core.Logging.TraceLoggerFactory">
            <summary>
            Used to create the TraceLogger implementation of ILogger interface. See <see cref="T:Castle.Core.Logging.TraceLogger"/>. 
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.ConsoleFactory">
            <summary>
            Summary description for ConsoleFactory.
            </summary>
        </member>
        <member name="T:Castle.Core.IStartable">
            <summary>
            Interface for components that wish to be started by the container
            </summary>
        </member>
        <member name="M:Castle.Core.IStartable.Start">
            <summary>
            Starts this instance.
            </summary>
        </member>
        <member name="M:Castle.Core.IStartable.Stop">
            <summary>
            Stops this instance.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.IAttributeDisassembler">
            <summary>
            Provides functionality for disassembling instances of attributes to CustomAttributeBuilder form, during the process of emiting new types by Dynamic Proxy.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.IAttributeDisassembler.Disassemble(System.Attribute)">
            <summary>
            Disassembles given attribute instance back to corresponding CustomAttributeBuilder.
            </summary>
            <param name="attribute">An instance of attribute to disassemble</param>
            <returns><see cref="T:System.Reflection.Emit.CustomAttributeBuilder"/> corresponding 1 to 1 to given attribute instance, or null reference.</returns>
            <remarks>
            Implementers should return <see cref="T:System.Reflection.Emit.CustomAttributeBuilder"/> that corresponds to given attribute instance 1 to 1,
            that is after calling specified constructor with specified arguments, and setting specified properties and fields with values specified
            we should be able to get an attribute instance identical to the one passed in <paramref name="attribute"/>. Implementer can return null
            if it wishes to opt out of replicating the attribute. Notice however, that for some cases, like attributes passed explicitly by the user
            it is illegal to return null, and doing so will result in exception.
            </remarks>
        </member>
        <member name="T:Castle.Core.ComponentProxyBehaviorAttribute">
            <summary>
            Specifies the proxying behavior for a component.
            </summary>
        </member>
        <member name="M:Castle.Core.ComponentProxyBehaviorAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute"/> class.
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.UseMarshalByRefProxy">
            <summary>
            Gets or sets a value indicating whether the generated 
            interface proxy should inherit from <see cref="T:System.MarshalByRefObject"/>.
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.UseSingleInterfaceProxy">
            <summary>
            Determines if the component requires a single interface proxy.
            </summary>
            <value><c>true</c> if the component requires a single interface proxy.</value>
        </member>
        <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.AdditionalInterfaces">
            <summary>
             Gets or sets the additional interfaces used during proxy generation.
            </summary>
        </member>
        <member name="T:NMock2.Actions.LazyReturnAction">
            <summary>
            Action that sets the result value on an invocation. The value is aquired by calling the delegate specified in the constructor.
            </summary>
        </member>
        <member name="T:NMock2.IAction">
            <summary>
            An action defines something that has to be done.
            For example the action to return a result value.
            </summary>
        </member>
        <member name="T:NMock2.Monitoring.IInvokable">
            <summary>
            IInvokable objects can be invoked.
            </summary>
        </member>
        <member name="M:NMock2.Monitoring.IInvokable.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Invokes this object.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="F:NMock2.Actions.LazyReturnAction.evaluate">
            <summary>
            Stores the evaluate delegate for this action.
            </summary>
        </member>
        <member name="M:NMock2.Actions.LazyReturnAction.#ctor(NMock2.Actions.LazyReturnAction.Evaluate)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Actions.LazyReturnAction"/> class.
            </summary>
            <param name="evaluate">The delegate used to aquire the return value.</param>
        </member>
        <member name="M:NMock2.Actions.LazyReturnAction.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Invokes this object.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.Actions.LazyReturnAction.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Actions.LazyReturnAction.Evaluate">
            <summary>
            Delegate that is used to get the return value.
            </summary>
            <returns>
            Returns an object...
            </returns>
        </member>
        <member name="T:NMock2.Syntax.IMethodSyntax">
            <summary>
            Syntax defining a method, property or event (de)registration.
            </summary>
        </member>
        <member name="M:NMock2.Syntax.IMethodSyntax.Method(System.String,System.Type[])">
            <summary>
            Defines a method.
            </summary>
            <param name="name">The name of the method.</param>
            <param name="typeParams">The generic type params to match.</param>
            <returns>
            Argument syntax defining the arguments of the method.
            </returns>
        </member>
        <member name="M:NMock2.Syntax.IMethodSyntax.Method(NMock2.Matcher,System.Type[])">
            <summary>
            Defines a method.
            </summary>
            <param name="nameMatcher">Matcher defining the method.</param>
            <param name="typeParams">The generic type params to match.</param>
            <returns>Argument syntax defining the arguments of the method.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMethodSyntax.Method(System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Defines a method.
            </summary>
            <param name="method">The method.</param>
            <param name="typeParams">The generic type params to match.</param>
            <returns>Argument syntax defining the arguments of the method.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMethodSyntax.Method(NMock2.Matcher,NMock2.Matcher)">
            <summary>
            Defines a method.
            </summary>
            <param name="methodMatcher">Matcher for matching the method on an invocation.</param>
            <param name="typeParamsMatcher">Matchers for matching type parameters.</param>
            <returns>Argument syntax defining the arguments of the method.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMethodSyntax.SetProperty(System.String)">
            <summary>
            Defines a property setter.
            </summary>
            <param name="name">The name of the property.</param>
            <returns>Value syntax defining the value of the property.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMethodSyntax.GetProperty(System.String)">
            <summary>
            Defines a property getter.
            </summary>
            <param name="name">The name of the property.</param>
            <returns>Match Syntax defining the property behavior.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMethodSyntax.EventAdd(System.String)">
            <summary>
            Defines an event registration.
            </summary>
            <param name="eventName">Name of the event.</param>
            <returns>Match syntax defining the behavior of the event adder.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMethodSyntax.EventAdd(System.String,NMock2.Matcher)">
            <summary>
            Defines an event registration.
            </summary>
            <param name="eventName">Name of the event.</param>
            <param name="listenerMatcher">The listener matcher.</param>
            <returns>Match syntax defining the behavior of the event adder.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMethodSyntax.EventAdd(System.String,System.Delegate)">
            <summary>
            Defines an event registration.
            </summary>
            <param name="eventName">Name of the event.</param>
            <param name="equalListener">Delegate defining compatible listeners.</param>
            <returns>Match syntax defining the behavior of the event adder.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMethodSyntax.EventRemove(System.String)">
            <summary>
            Defines an event deregistration.
            </summary>
            <param name="eventName">Name of the event.</param>
            <returns>Match syntax defining the behavior of the event remover.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMethodSyntax.EventRemove(System.String,NMock2.Matcher)">
            <summary>
            Defines an event deregistration.
            </summary>
            <param name="eventName">Name of the event.</param>
            <param name="listenerMatcher">The listener matcher.</param>
            <returns>Match syntax defining the behavior of the event remover.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMethodSyntax.EventRemove(System.String,System.Delegate)">
            <summary>
            Defines an event deregistration.
            </summary>
            <param name="eventName">Name of the event.</param>
            <param name="equalListener">Delegate defining compatible listeners.</param>
            <returns> Match syntax defining the behavior of the event remover.</returns>
        </member>
        <member name="P:NMock2.Syntax.IMethodSyntax.Get">
            <summary>
            Gets an indexer (get operation).
            </summary>
            <value>Get indexer syntax defining the value returned by the indexer.</value>
        </member>
        <member name="P:NMock2.Syntax.IMethodSyntax.Set">
            <summary>
            Gets an indexer (set operation).
            </summary>
            <value>Set indexer syntax defining the value the indexer is set to.</value>
        </member>
        <member name="M:NMock2.Internal.OrderedExpectations.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.OrderedExpectations"/> class.
            </summary>
            <param name="depth">The depth.</param>
        </member>
        <member name="M:NMock2.Internal.OrderedExpectations.Matches(NMock2.Monitoring.Invocation)">
            <summary>
            Checks whether stored expectations matches the specified invocation.
            </summary>
            <param name="invocation">The invocation to check.</param>
            <returns>Returns whether one of the stored expectations has met the specified invocation.</returns>
        </member>
        <member name="M:NMock2.Internal.OrderedExpectations.QueryExpectationsBelongingTo(NMock2.Internal.IMockObject,System.Collections.Generic.IList{NMock2.IExpectation})">
            <summary>
            Adds all expectations to <paramref name="result"/> that are associated to <paramref name="mock"/>.
            </summary>
            <param name="mock">The mock for which expectations are queried.</param>
            <param name="result">The result to add matching expectations to.</param>
        </member>
        <member name="P:NMock2.Internal.OrderedExpectations.IsActive">
            <summary>
            Gets a value indicating whether this instance is active.
            </summary>
            <value><c>true</c> if this instance is active; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NMock2.Internal.OrderedExpectations.HasBeenMet">
            <summary>
            Gets a value indicating whether this instance has been met.
            </summary>
            <value>
            <c>true</c> if this instance has been met; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NMock2.Internal.OrderedExpectations.CurrentExpectation">
            <summary>
            Gets the current expectation.
            </summary>
            <value>The current expectation.</value>
        </member>
        <member name="P:NMock2.Internal.OrderedExpectations.HasNextExpectation">
            <summary>
            Gets a value indicating whether this instance has next expectation.
            </summary>
            <value>
                <c>true</c> if this instance has next expectation; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NMock2.Internal.OrderedExpectations.NextExpectation">
            <summary>
            Gets the next expectation.
            </summary>
            <value>The next expectation.</value>
        </member>
        <member name="T:NMock2.IMockDefinition">
            <summary>
            The definition of a mock object.
            </summary>
            <remarks>
            Implementations of this interface encapsulate the details of
            how a mock object is defined, and provide the ability to be able to
            instantiate an instance of it.
            </remarks>
        </member>
        <member name="M:NMock2.IMockDefinition.Create(System.Type,NMock2.Mockery,NMock2.Monitoring.IMockObjectFactory)">
            <summary>
            This method supports NMock2 infrastructure and is not intended to be called directly from your code.
            </summary>
            <param name="primaryType">The primary type that is being mocked.</param>
            <param name="mockery">The current <see cref="T:NMock2.Mockery"/> instance.</param>
            <param name="mockFactory">An <see cref="T:NMock2.Monitoring.IMockObjectFactory"/> to use when creating the mock.</param>
            <returns>A new mock instance.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.MixinData.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Because we need to cache the types based on the mixed in mixins, we do the following here:
             - Get all the mixin interfaces
             - Sort them by full name
             - Return them by position
            
            The idea is to have reproducable behavior for the case that mixins are registered in different orders.
            This method is here because it is required 
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.Core.Resource.AssemblyResourceFactory">
            <summary>
            
            </summary>
        </member>
        <member name="T:NMock2.Actions.SetNamedParameterAction">
            <summary>
            Action that sets the parameter of the invocation with the specified name to the specified value.
            </summary>
        </member>
        <member name="F:NMock2.Actions.SetNamedParameterAction.name">
            <summary>
            Stores the name of the parameter when the class gets initialized.
            </summary>
        </member>
        <member name="F:NMock2.Actions.SetNamedParameterAction.value">
            <summary>
            Stores the value of the parameter when the class gets initialized.
            </summary>
        </member>
        <member name="M:NMock2.Actions.SetNamedParameterAction.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Actions.SetNamedParameterAction"/> class.
            </summary>
            <param name="name">The name of the parameter to set.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NMock2.Actions.SetNamedParameterAction.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Invokes this object. Sets the value of the parameter with the specified name of the invocation.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.Actions.SetNamedParameterAction.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Throw">
            <summary>
            Defines action for throwing actions.
            </summary>
        </member>
        <member name="M:NMock2.Throw.Exception(System.Exception)">
            <summary>
            Throws an exeception when the action is invoked.
            </summary>
            <param name="exception">The exception to throw when invoked.</param>
            <returns>Returns a new instance of the <see cref="T:NMock2.Actions.ThrowAction"/> class.</returns>
        </member>
        <member name="T:NMock2.Signal">
            <summary>
            Defines that an <see cref="M:NMock2.Signal.EventWaitHandle(System.Threading.EventWaitHandle)"/> should be signaled.
            </summary>
        </member>
        <member name="M:NMock2.Signal.EventWaitHandle(System.Threading.EventWaitHandle)">
            <summary>
            Signals an <see cref="M:NMock2.Signal.EventWaitHandle(System.Threading.EventWaitHandle)"/> to synchronizes threads.
            </summary>
            <param name="signal">The signal to set.</param>
            <returns>Action that signals an <see cref="M:NMock2.Signal.EventWaitHandle(System.Threading.EventWaitHandle)"/>.</returns>
        </member>
        <member name="T:NMock2.Matchers.AndMatcher">
            <summary>
            Matcher that is the logical and combination of two matchers.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.AndMatcher.#ctor(NMock2.Matcher,NMock2.Matcher)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.AndMatcher"/> class.
            </summary>
            <param name="left">The left operand.</param>
            <param name="right">The right operand.</param>
        </member>
        <member name="M:NMock2.Matchers.AndMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Returns whether the object matches.</returns>
        </member>
        <member name="M:NMock2.Matchers.AndMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Internal.EventInvocationBuilder">
            <summary>
            Builder for event invocations.
            </summary>
        </member>
        <member name="T:NMock2.Syntax.IEventSyntax">
            <summary>
            Syntax for defining the object that fires an event. 
            </summary>
        </member>
        <member name="M:NMock2.Syntax.IEventSyntax.On(System.Object)">
            <summary>
            Defines the object that fires the event.
            </summary>
            <param name="o">The object firing the event.</param>
            <returns>Event argument syntax defining the arguments passed to the event.</returns>
        </member>
        <member name="F:NMock2.Internal.EventInvocationBuilder.eventName">
            <summary>
            Stores the event name to be mocked.
            </summary>
        </member>
        <member name="F:NMock2.Internal.EventInvocationBuilder.mock">
            <summary>
            Stores the mock when called in the On mehtod.
            </summary>
        </member>
        <member name="M:NMock2.Internal.EventInvocationBuilder.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.EventInvocationBuilder"/> class.
            </summary>
            <param name="eventName">Name of the event.</param>
        </member>
        <member name="M:NMock2.Internal.EventInvocationBuilder.On(System.Object)">
            <summary>
            Specifies the mock on which the event is fired.
            </summary>
            <param name="o">The mock on which the event is fired.</param>
            <returns>
            Event argument sytax defining the arguments passed to the event.
            </returns>
        </member>
        <member name="M:NMock2.Internal.EventInvocationBuilder.With(System.Object[])">
            <summary>
            Specifies the event arguments that are passed to the event and fires the event.
            </summary>
            <param name="args">The args to be passed to raise the event.</param>
        </member>
        <member name="T:NMock2.Internal.NewEventInvocationBuilder">
            <summary>
            Builder for event invocations.
            </summary>
        </member>
        <member name="T:NMock2.Syntax.INewEventSyntax">
            <summary>
            Syntax for defining the event that is fired.
            </summary>
        </member>
        <member name="M:NMock2.Syntax.INewEventSyntax.Event(System.String)">
            <summary>
            Defines the event to fire.
            </summary>
            <param name="eventName">Name of the event.</param>
            <returns>Event argument syntax defining the arguments passed to the event.</returns>
        </member>
        <member name="F:NMock2.Internal.NewEventInvocationBuilder.eventName">
            <summary>
            Stores the event name to be mocked.
            </summary>
        </member>
        <member name="F:NMock2.Internal.NewEventInvocationBuilder.mock">
            <summary>
            Stores the mock when called in the On method.
            </summary>
        </member>
        <member name="M:NMock2.Internal.NewEventInvocationBuilder.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.NewEventInvocationBuilder"/> class.
            </summary>
            <param name="mock">The mock.</param>
        </member>
        <member name="M:NMock2.Internal.NewEventInvocationBuilder.Event(System.String)">
            <summary>
            Defines the event to fire.
            </summary>
            <param name="eventName">Name of the event.</param>
            <returns>
            Event argument syntax defining the arguments passed to the event.
            </returns>
        </member>
        <member name="M:NMock2.Internal.NewEventInvocationBuilder.With(System.Object[])">
            <summary>
            Specifies the event arguments that are passed to the event and fires the event.
            </summary>
            <param name="args">The args to be passed to raise the event.</param>
        </member>
        <member name="T:Castle.DynamicProxy.IProxyBuilder">
            <summary>
            Abstracts the implementation of proxy type construction.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
            Creates a proxy type for given <paramref name="classToProxy"/>, using <paramref name="options"/> provided.
            </summary>
            <param name="classToProxy">The class type to proxy.</param>
            <param name="options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy"/> is a generic type definition.</exception>
            <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy"/> is not public.
            Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/> 
            pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref="T:Castle.DynamicProxy.Generators.ClassProxyGenerator"/>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
            Creates a proxy type for given <paramref name="classToProxy"/>, implementing <paramref name="additionalInterfacesToProxy"/>, using <paramref name="options"/> provided.
            </summary>
            <param name="classToProxy">The class type to proxy.</param>
            <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name="options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
            Implementers should return a proxy type for the specified class and interfaces.
            Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see cref="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)"/> method.)
            </remarks>
            <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is not public.
            Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/> 
            pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref="T:Castle.DynamicProxy.Generators.ClassProxyGenerator"/>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
            Creates a proxy type for given <paramref name="classToProxy"/>, implementing <paramref name="additionalInterfacesToProxy"/>, using <paramref name="options"/> provided.
            </summary>
            <param name="classToProxy">The class type to proxy.</param>
            <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name="options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
            Implementers should return a proxy type for the specified class and interfaces.
            Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see cref="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)"/> method.)
            </remarks>
            <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is not public.
            Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/> 
            pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref="T:Castle.DynamicProxy.Generators.ClassProxyGenerator"/>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
            Creates a proxy type that proxies calls to <paramref name="interfaceToProxy"/> members on <paramref name="targetType"/>, implementing <paramref name="additionalInterfacesToProxy"/>, using <paramref name="options"/> provided.
            </summary>
            <param name="interfaceToProxy">The interface type to proxy.</param>
            <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name="targetType">Type implementing <paramref name="interfaceToProxy"/> on which calls to the interface members should be intercepted.</param>
            <param name="options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
            Implementers should return a proxy type for the specified interface that 'proceeds' executions to the specified target.
            Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see cref="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)"/> method.)
            </remarks>
            <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is not public.
            Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/> 
            pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator"/>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
            Creates a proxy type for given <paramref name="interfaceToProxy"/> that delegates all calls to the provided interceptors.
            </summary>
            <param name="interfaceToProxy">The interface type to proxy.</param>
            <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name="options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
            Implementers should return a proxy type for the specified interface and additional interfaces that delegate all executions to the specified interceptors.
            </remarks>
            <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is not public.
            Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/> 
            pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithoutTargetGenerator"/>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
            Creates a proxy type for given <paramref name="interfaceToProxy"/> and <parmaref name="additionalInterfacesToProxy"/> that delegates all calls to the provided interceptors and allows interceptors to switch the actual target of invocation.
            </summary>
            <param name="interfaceToProxy">The interface type to proxy.</param>
            <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name="options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
            Implementers should return a proxy type for the specified interface(s) that delegate all executions to the specified interceptors
            and uses an instance of the interface as their targets (i.e. <see cref="P:Castle.Core.Interceptor.IInvocation.InvocationTarget"/>), rather than a class. All <see cref="T:Castle.Core.Interceptor.IInvocation"/> classes should then implement <see cref="T:Castle.Core.Interceptor.IChangeProxyTarget"/> interface,
            to allow interceptors to switch invocation target with instance of another type implementing called interface.
            </remarks>
            <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is not public.
            Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/> 
            pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetInterfaceGenerator"/>
        </member>
        <member name="P:Castle.DynamicProxy.IProxyBuilder.Logger">
            <summary>
            Gets or sets the <see cref="T:Castle.Core.Logging.ILogger"/> that this <see cref="T:Castle.DynamicProxy.ProxyGenerator"/> logs to.
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope">
            <summary>
            Gets the <see cref="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope"/> associated with this builder.
            </summary>
            <value>The module scope associated with this builder.</value>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.InvocationTypeGenerator.GetCtorArgumentsAndBaseCtorToCall(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Reflection.ConstructorInfo@)">
            <summary>
            Generates the constructor for the class that extends
            <see cref="T:Castle.DynamicProxy.AbstractInvocation"/>
            </summary>
            <param name="targetFieldType"></param>
            <param name="proxyGenerationOptions"></param>
            <param name="baseConstructor"></param>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.IndirectReference">
            <summary>
            Wraps a reference that is passed 
            ByRef and provides indirect load/store support.
            </summary>
        </member>
        <member name="T:Castle.Core.Resource.UncResource">
            <summary>
            Enable access to files on network shares
            </summary>
        </member>
        <member name="T:Castle.Core.ConstructorCandidate">
            <summary>
            Represents a constructor of the component 
            that the container can use to initialize it properly.
            </summary>
        </member>
        <member name="M:Castle.Core.ConstructorCandidate.#ctor(System.Reflection.ConstructorInfo,Castle.Core.DependencyModel[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ConstructorCandidate"/> class.
            </summary>
            <param name="constructorInfo">The constructor info.</param>
            <param name="dependencies">The dependencies.</param>
        </member>
        <member name="P:Castle.Core.ConstructorCandidate.Constructor">
            <summary>
            Gets the ConstructorInfo (from reflection).
            </summary>
            <value>The constructor.</value>
        </member>
        <member name="P:Castle.Core.ConstructorCandidate.Dependencies">
            <summary>
            Gets the dependencies this constructor candidate exposes.
            </summary>
            <value>The dependencies.</value>
        </member>
        <member name="T:Castle.Core.Logging.IExtendedLogger">
            <summary>
            Provides an interface that supports <see cref="T:Castle.Core.Logging.ILogger"/> and
            allows the storage and retrieval of Contexts. These are supported in
            both log4net and NLog.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.IExtendedLogger.GlobalProperties">
            <summary>
            Exposes the Global Context of the extended logger. 
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadProperties">
            <summary>
            Exposes the Thread Context of the extended logger.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadStacks">
            <summary>
            Exposes the Thread Stack of the extended logger.
            </summary>
        </member>
        <member name="T:Castle.Core.Interceptor.IInterceptor">
            <summary>
            New interface that is going to be used by DynamicProxy 2
            </summary>
        </member>
        <member name="T:Castle.Core.DoNotWireAttribute">
            <summary>
            Marks as property to be skipped and not be wired
            by the IoC container
            </summary>
        </member>
        <member name="T:NMock2.Actions.ResultSynthesizer">
            <summary>
            Responsible for handling the results of an invocation.
            </summary>
        </member>
        <member name="F:NMock2.Actions.ResultSynthesizer.defaultResults">
            <summary>
            Stores the default results.
            </summary>
        </member>
        <member name="F:NMock2.Actions.ResultSynthesizer.results">
            <summary>
            Stores the results.
            </summary>
        </member>
        <member name="M:NMock2.Actions.ResultSynthesizer.#cctor">
            <summary>
            Initializes static members of the <see cref="T:NMock2.Actions.ResultSynthesizer"/> class.
            </summary>
        </member>
        <member name="M:NMock2.Actions.ResultSynthesizer.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Invokes this object.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.Actions.ResultSynthesizer.SetResult(System.Type,System.Object)">
            <summary>
            Sets the result of the specified <paramref name="returnType"/>.
            </summary>
            <param name="returnType">The type to be returned as a result.</param>
            <param name="result">The result to be set.</param>
        </member>
        <member name="M:NMock2.Actions.ResultSynthesizer.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object to the specified <paramref name="writer"/>.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="M:NMock2.Actions.ResultSynthesizer.NewEmptyArray(System.Type)">
            <summary>
            Gets a new the empty array of the specified <paramref name="arrayType"/>.
            </summary>
            <param name="arrayType">Type of the array to be returned.</param>
            <returns>
            Returns a new empty array of the specified <paramref name="arrayType"/>.
            </returns>
        </member>
        <member name="M:NMock2.Actions.ResultSynthesizer.GetAction(System.Type,System.Collections.Hashtable)">
            <summary>
            Gets the action of the specified <paramref name="returnType"/>.
            </summary>
            <param name="returnType">Type of the returned action.</param>
            <param name="results">The results to get the action from. This is used as a parameter for the <see cref="F:NMock2.Actions.ResultSynthesizer.defaultResults"/>.</param>
            <returns>
            Returns the action of the specified <paramref name="returnType"/> out of the <paramref name="results"/>.
            </returns>
        </member>
        <member name="M:NMock2.Actions.ResultSynthesizer.SetAction(System.Type,NMock2.IAction)">
            <summary>
            Sets the action of the specified <paramref name="returnType"/>.
            </summary>
            <param name="returnType">Type of the action to be set.</param>
            <param name="action">The action to be set.</param>
        </member>
        <member name="T:NMock2.Stub">
            <summary>
            Defines stubs for interfaces. Stubs are used when it does not matter how many times (even 0) something is called.
            A stub is the same as an "at least once" expecation.
            Normally you use stubs on mocks that just provide information to your object under test.
            </summary>
        </member>
        <member name="M:NMock2.Stub.On(System.Object)">
            <summary>
            Defines the mock that is stubbed.
            </summary>
            <param name="mock">The mock to stub.</param>
            <returns>Method syntax defining the method, property or event to stub.</returns>
        </member>
        <member name="T:NMock2.Monitoring.InterfaceOnlyMockObjectFactory">
            <summary>
            Class that creates mocks for interfaces only. This was the original implementation
            of NMock2 mocks used before the Castle proxies were introduced.
            </summary>
        </member>
        <member name="M:NMock2.Monitoring.InterfaceOnlyMockObjectFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Monitoring.InterfaceOnlyMockObjectFactory"/> class.
            </summary>
        </member>
        <member name="M:NMock2.Monitoring.InterfaceOnlyMockObjectFactory.GetGenericParameterNames(System.Type[])">
            <summary>
            Returns an array of <see langword="string"/>s that represent
            the names of the generic type parameter.
            </summary>
            <param name="args">The parameter info array.</param>
            <returns>An array containing parameter names.</returns>
        </member>
        <member name="M:NMock2.Monitoring.InterfaceOnlyMockObjectFactory.GetParameterTypes(System.Reflection.ParameterInfo[])">
            <summary>
            Returns an array of parameter <see cref="T:System.Type"/>s for the
            specified parameter info array.
            </summary>
            <param name="args">The parameter info array.</param>
            <returns>
            An array containing parameter <see cref="T:System.Type"/>s.
            </returns>
        </member>
        <member name="M:NMock2.Monitoring.InterfaceOnlyMockObjectFactory.CreateMock(NMock2.Mockery,NMock2.Internal.CompositeType,System.String,NMock2.MockStyle,System.Object[])">
            <summary>
            Creates a mock of the specified type(s).
            </summary>
            <param name="mockery">The mockery used to create this mock instance.</param>
            <param name="typesToMock">The type(s) to include in the mock.</param>
            <param name="name">The name to use for the mock instance.</param>
            <param name="mockStyle">The behaviour of the mock instance when first created.</param>
            <param name="constructorArgs">Constructor arguments for the class to be mocked. Only valid if mocking a class type.</param>
            <returns>
            A mock instance of the specified type(s).
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NMock2.Monitoring.InterfaceOnlyMockObjectFactory.DefineMethod(System.Reflection.Emit.TypeBuilder,System.Reflection.MethodInfo,System.Boolean)" -->
        <member name="M:NMock2.Monitoring.InterfaceOnlyMockObjectFactory.DefineParameters(System.Reflection.Emit.MethodBuilder,System.Reflection.MethodInfo)">
            <summary>
            Defines method parameters based on proxied method metadata.
            </summary>
            <param name="methodBuilder">The <see cref="T:System.Reflection.Emit.MethodBuilder"/> to use.</param>
            <param name="method">The method to proxy.</param>
        </member>
        <member name="M:NMock2.Monitoring.InterfaceOnlyMockObjectFactory.TypeId.#ctor(System.Type[])">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Monitoring.InterfaceOnlyMockObjectFactory.TypeId"/> class.
            </summary>
            <param name="types">The types.</param>
        </member>
        <member name="T:NMock2.Matchers.GenericMatcher`1">
            <summary>
            Matcher that checks whether a value matches the check provided as a delegate.
            the expectation.
            </summary>
            <typeparam name="T">The type of the expected value.</typeparam>
        </member>
        <member name="F:NMock2.Matchers.GenericMatcher`1.matchExpression">
            <summary>
            The test that is performed to see if the value matches the expectation.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.GenericMatcher`1.#ctor(NMock2.Matchers.GenericMatcher{`0}.MatchExpression)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.GenericMatcher`1"/> class.
            </summary>
            <param name="matchExpression">The test that is performed to check if the value matches expectation.</param>
            <exception cref="T:System.ArgumentNullException"><c>matchExpression</c> is null.</exception>
        </member>
        <member name="M:NMock2.Matchers.GenericMatcher`1.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object matches.</returns>
        </member>
        <member name="M:NMock2.Matchers.GenericMatcher`1.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Matchers.GenericMatcher`1.MatchExpression">
            <summary>
            The test that is performed to check if the <paramref name="value"/> matches the expectation.
            </summary>
            <param name="value">The actually received value.</param>
            <returns>True then value matches the expectation.</returns>
        </member>
        <member name="T:Castle.DynamicProxy.Tokens.SerializationInfoMethods">
            <summary>
            Holds <see cref="T:System.Reflection.MethodInfo"/> objects representing methods of <see cref="T:System.Runtime.Serialization.SerializationInfo"/> class.
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Bool">
            <summary>
            <see cref="M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Boolean)"/>
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Int32">
            <summary>
            <see cref="M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Int32)"/>
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Object">
            <summary>
            <see cref="M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Object)"/>
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.GetValue">
            <summary>
            <see cref="M:System.Runtime.Serialization.SerializationInfo.GetValue(System.String,System.Type)"/>
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.SetType">
            <summary>
            <see cref="M:System.Runtime.Serialization.SerializationInfo.SetType(System.Type)"/>
            </summary>
        </member>
        <member name="T:Castle.Core.ReflectionBasedDictionaryAdapter">
            <summary>
            Pendent
            </summary>
        </member>
        <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ReflectionBasedDictionaryAdapter"/> class.
            </summary>
            <param name="target">The target.</param>
        </member>
        <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary"/> object contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary"/> object.</param>
            <returns>
            true if the <see cref="T:System.Collections.IDictionary"/> contains an element with the key; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="key"/> is null. </exception>
        </member>
        <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Add(System.Object,System.Object)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary"/> object.
            </summary>
            <param name="key">The <see cref="T:System.Object"/> to use as the key of the element to add.</param>
            <param name="value">The <see cref="T:System.Object"/> to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="key"/> is null. </exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary"/> object. </exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"/> is read-only.-or- The <see cref="T:System.Collections.IDictionary"/> has a fixed size. </exception>
        </member>
        <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Clear">
            <summary>
            Removes all elements from the <see cref="T:System.Collections.IDictionary"/> object.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"/> object is read-only. </exception>
        </member>
        <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator"/> object for the <see cref="T:System.Collections.IDictionary"/> object.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator"/> object for the <see cref="T:System.Collections.IDictionary"/> object.
            </returns>
        </member>
        <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Remove(System.Object)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary"/> object.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="key"/> is null. </exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"/> object is read-only.-or- The <see cref="T:System.Collections.IDictionary"/> has a fixed size. </exception>
        </member>
        <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="array"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is less than zero. </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="array"/> is multidimensional.-or- <paramref name="index"/> is equal to or greater than the length of <paramref name="array"/>.-or- The number of elements in the source <see cref="T:System.Collections.ICollection"/> is greater than the available space from <paramref name="index"/> to the end of the destination <paramref name="array"/>. </exception>
            <exception cref="T:System.ArgumentException">The type of the source <see cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the destination <paramref name="array"/>. </exception>
        </member>
        <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Item(System.Object)">
            <summary>
            Gets or sets the <see cref="T:System.Object"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Keys">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> object containing the keys of the <see cref="T:System.Collections.IDictionary"/> object.
            </summary>
            <value></value>
            <returns>An <see cref="T:System.Collections.ICollection"/> object containing the keys of the <see cref="T:System.Collections.IDictionary"/> object.</returns>
        </member>
        <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Values">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> object containing the values in the <see cref="T:System.Collections.IDictionary"/> object.
            </summary>
            <value></value>
            <returns>An <see cref="T:System.Collections.ICollection"/> object containing the values in the <see cref="T:System.Collections.IDictionary"/> object.</returns>
        </member>
        <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"/> object is read-only.
            </summary>
            <value></value>
            <returns>true if the <see cref="T:System.Collections.IDictionary"/> object is read-only; otherwise, false.</returns>
        </member>
        <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"/> object has a fixed size.
            </summary>
            <value></value>
            <returns>true if the <see cref="T:System.Collections.IDictionary"/> object has a fixed size; otherwise, false.</returns>
        </member>
        <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <value></value>
            <returns>The number of elements contained in the <see cref="T:System.Collections.ICollection"/>.</returns>
        </member>
        <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <value></value>
            <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"/>.</returns>
        </member>
        <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is synchronized (thread safe).
            </summary>
            <value></value>
            <returns>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized (thread safe); otherwise, false.</returns>
        </member>
        <member name="T:Castle.Core.InterceptorReference">
            <summary>
            Represents an reference to a Interceptor component.
            </summary>
        </member>
        <member name="M:Castle.Core.InterceptorReference.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference"/> class.
            </summary>
            <param name="componentKey">The component key.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReference.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference"/> class.
            </summary>
            <param name="serviceType">Type of the service.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReference.ForKey(System.String)">
            <summary>
            Gets an <see cref="T:Castle.Core.InterceptorReference"/> for the component key.
            </summary>
            <param name="key">The component key.</param>
            <returns>The <see cref="T:Castle.Core.InterceptorReference"/></returns>
        </member>
        <member name="M:Castle.Core.InterceptorReference.ForType(System.Type)">
            <summary>
            Gets an <see cref="T:Castle.Core.InterceptorReference"/> for the service.
            </summary>
            <param name="service">The service.</param>
            <returns>The <see cref="T:Castle.Core.InterceptorReference"/></returns>
        </member>
        <member name="M:Castle.Core.InterceptorReference.ForType``1">
            <summary>
            Gets an <see cref="T:Castle.Core.InterceptorReference"/> for the service.
            </summary>
            <typeparam name="T">The service type.</typeparam>
            <returns>The <see cref="T:Castle.Core.InterceptorReference"/></returns>
        </member>
        <member name="P:Castle.Core.InterceptorReference.ServiceType">
            <summary>
            Gets the type of the service.
            </summary>
            <value>The type of the service.</value>
        </member>
        <member name="P:Castle.Core.InterceptorReference.ComponentKey">
            <summary>
            Gets the interceptor component key.
            </summary>
            <value>The component key.</value>
        </member>
        <member name="P:Castle.Core.InterceptorReference.ReferenceType">
            <summary>
            Gets the type of the reference.
            </summary>
            <value>The type of the reference.</value>
        </member>
        <member name="T:Castle.Core.DependencyModel">
            <summary>
            Represents a dependency (other component or a 
            fixed value available through external configuration).
            </summary>
        </member>
        <member name="M:Castle.Core.DependencyModel.#ctor(Castle.Core.DependencyType,System.String,System.Type,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModel"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="dependencyKey">The dependency key.</param>
            <param name="targetType">Type of the target.</param>
            <param name="isOptional">if set to <c>true</c> [is optional].</param>
        </member>
        <member name="M:Castle.Core.DependencyModel.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Castle.Core.DependencyModel.GetHashCode">
            <summary>
            Serves as a hash function for a particular type, suitable
            for use in hashing algorithms and data structures like a hash table.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Castle.Core.DependencyModel.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            	<see langword="true"/> if the specified <see cref="T:System.Object"/> is equal to the
            current <see cref="T:System.Object"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="P:Castle.Core.DependencyModel.DependencyType">
            <summary>
            Gets or sets the type of the dependency.
            </summary>
            <value>The type of the dependency.</value>
        </member>
        <member name="P:Castle.Core.DependencyModel.DependencyKey">
            <summary>
            Gets or sets the dependency key.
            </summary>
            <value>The dependency key.</value>
        </member>
        <member name="P:Castle.Core.DependencyModel.TargetType">
            <summary>
            Gets the type of the target.
            </summary>
            <value>The type of the target.</value>
        </member>
        <member name="P:Castle.Core.DependencyModel.IsOptional">
            <summary>
            Gets or sets whether this dependency is optional.
            </summary>
            <value>
            	<c>true</c> if this dependency is optional; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Castle.Core.InterceptorAttribute">
            <summary>
            Used to declare that a component wants interceptors acting on it.
            </summary>
        </member>
        <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.String)">
            <summary>
            Constructs the InterceptorAttribute pointing to
            a key to a interceptor
            </summary>
            <param name="componentKey"></param>
        </member>
        <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.Type)">
            <summary>
            Constructs the InterceptorAttribute pointing to
            a service
            </summary>
            <param name="interceptorType"></param>
        </member>
        <member name="T:NMock2.Actions.ReturnAction">
            <summary>
            Action that sets the result value on an invocation.
            </summary>
        </member>
        <member name="F:NMock2.Actions.ReturnAction.result">
            <summary>
            Stores the result to set on the invocation as the return value.
            </summary>
        </member>
        <member name="M:NMock2.Actions.ReturnAction.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Actions.ReturnAction"/> class.
            </summary>
            <param name="result">The result to set on the invocation as the return value.</param>
        </member>
        <member name="M:NMock2.Actions.ReturnAction.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Invokes this object. Sets the result value of the invocation.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.Actions.ReturnAction.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Actions.DelegateAction">
            <summary>
            Action that executes the delegate passed to the constructor.
            </summary>
        </member>
        <member name="F:NMock2.Actions.DelegateAction.handler">
            <summary>
            Stores the handler of the delegate action.
            </summary>
        </member>
        <member name="M:NMock2.Actions.DelegateAction.#ctor(NMock2.Actions.DelegateAction.Handler)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Actions.DelegateAction"/> class.
            </summary>
            <param name="actionHandler">The action handler.</param>
        </member>
        <member name="M:NMock2.Actions.DelegateAction.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Invokes this object.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.Actions.DelegateAction.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Actions.DelegateAction.Handler">
            <summary>
            Delegate that is executed on invocation of the action.
            </summary>
        </member>
        <member name="T:NMock2.Internal.IMockObject">
            <summary>
            Interface for mocks.
            </summary>
        </member>
        <member name="M:NMock2.Internal.IMockObject.HasMethodMatching(NMock2.Matcher)">
            <summary>
            Determines if this mock has a particular method.
            </summary>
            <param name="methodMatcher">A Matcher to use in identifying the method.</param>
            <returns>True if a matching method exists, otherwise false.</returns>
        </member>
        <member name="M:NMock2.Internal.IMockObject.GetMethodsMatching(NMock2.Matcher)">
            <summary>
            Retrieves all matching methods on this mock. 
            </summary>
            <param name="methodMatcher">A Matcher to use in identifying the methods.</param>
            <returns>A list of zero or more matching MethodInfo instances.</returns>
        </member>
        <member name="M:NMock2.Internal.IMockObject.AddExpectation(NMock2.IExpectation)">
            <summary>
            Adds an expectation to this mock.
            </summary>
            <param name="expectation">The expectation to add.</param>
        </member>
        <member name="M:NMock2.Internal.IMockObject.AddEventHandler(System.String,System.Delegate)">
            <summary>
            Adds an event handler on this mock.
            </summary>
            <param name="eventName">The name of the event.</param>
            <param name="handler">The handler to add.</param>
        </member>
        <member name="M:NMock2.Internal.IMockObject.RemoveEventHandler(System.String,System.Delegate)">
            <summary>
            Removes an event handler from this mock.
            </summary>
            <param name="eventName">The name of the event.</param>
            <param name="handler">The handler to remove.</param>
        </member>
        <member name="M:NMock2.Internal.IMockObject.RaiseEvent(System.String,System.Object[])">
            <summary>
            Raises an event on this mock.
            </summary>
            <param name="eventName">Name of the event to fire.</param>
            <param name="args">The arguments passed to the event.</param>
        </member>
        <member name="P:NMock2.Internal.IMockObject.MockName">
            <summary>
            Gets the name of the mock instance. This is often used in error messages
            to identify a specific mock instance.
            </summary>
        </member>
        <member name="F:NMock2.Internal.MockObject.mockery">
            <summary>
            Stores the backlink to the mockery which created this mock object.
            </summary>
        </member>
        <member name="F:NMock2.Internal.MockObject.mockedTypes">
            <summary>
            Stores the mocked type(s).
            </summary>
        </member>
        <member name="F:NMock2.Internal.MockObject.name">
            <summary>
            Stores the name of the mock object.
            </summary>
        </member>
        <member name="F:NMock2.Internal.MockObject.eventHandlers">
            <summary>
            Stores the event handlers that could be added to the mock object.
            </summary>
        </member>
        <member name="F:NMock2.Internal.MockObject.assignedPropertyResults">
            <summary>
            Results that have been explicitly assigned via a call to a property setter.
            These will be returned for all subsequent calls to the matching property getter.
            </summary>
        </member>
        <member name="F:NMock2.Internal.MockObject.rememberedMethodResults">
            <summary>
            Results that have been generated for methods or property getters.
            These will be returned for all subsequent calls to the same member.
            </summary>
        </member>
        <member name="M:NMock2.Internal.MockObject.#ctor(NMock2.Mockery,System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.MockObject"/> class.
            This constructor is needed by the <see cref="T:NMock2.Monitoring.InterfaceOnlyMockObjectFactory"/> (the IL generation has to be changed!)
            </summary>
            <param name="mockery">The mockery.</param>
            <param name="mockedType">Type of the mocked.</param>
            <param name="name">The name.</param>
        </member>
        <member name="M:NMock2.Internal.MockObject.#ctor(NMock2.Mockery,NMock2.Internal.CompositeType,System.String,NMock2.MockStyle)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.MockObject"/> class.
            </summary>
            <param name="mockery">The mockery.</param>
            <param name="mockedType">Type of the mocked.</param>
            <param name="name">The name.</param>
            <param name="mockStyle">The mock style.</param>
        </member>
        <member name="M:NMock2.Internal.MockObject.GetStubResult(NMock2.Monitoring.Invocation)">
            <summary>
            Gets the default result for an invocation.
            </summary>
            <param name="invocation">The invocation.</param>
            <returns>The default value to return as result of the invocation. 
            <see cref="F:System.Reflection.Missing.Value"/> if no default value was provided.</returns>
        </member>
        <member name="M:NMock2.Internal.MockObject.GetMemberName(NMock2.Monitoring.Invocation)">
            <summary>
            Gets the name of the member to be used as the name for a mock returned an a call to a stub.
            </summary>
            <param name="invocation">The invocation.</param>
            <returns>Name of the mock created as a result value on a call to a stub.</returns>
        </member>
        <member name="P:NMock2.Internal.MockObject.MockStyle">
            <summary>
            Gets the mock style of this mock.
            </summary>
        </member>
        <member name="M:NMock2.Monitoring.MockObjectInterceptor.#cctor">
            <summary>
            Initializes static members of the <see cref="T:NMock2.Monitoring.MockObjectInterceptor"/> class.
            </summary>
        </member>
        <member name="M:NMock2.Monitoring.MockObjectInterceptor.#ctor(NMock2.Mockery,NMock2.Internal.CompositeType,System.String,NMock2.MockStyle)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Monitoring.MockObjectInterceptor"/> class.
            </summary>
            <param name="mockery">The mockery.</param>
            <param name="mockedType">Type of the mocked.</param>
            <param name="name">The name.</param>
            <param name="mockStyle">The mock style.</param>
        </member>
        <member name="T:NMock2.Syntax.IReceiverSyntax">
            <summary>
            Syntax defining a receiver.
            </summary>
        </member>
        <member name="M:NMock2.Syntax.IReceiverSyntax.On(System.Object)">
            <summary>
            Defines the receiver.
            </summary>
            <param name="receiver">The dynamic mock on which the expectation or stub is applied.</param>
            <returns>Method syntax defining the method, property or event.</returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.#ctor(System.String,NMock2.Matcher,NMock2.Matcher)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.ExpectationBuilder"/> class.
            </summary>
            <param name="description">The description.</param>
            <param name="requiredCountMatcher">The required count matcher.</param>
            <param name="acceptedCountMatcher">The accepted count matcher.</param>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.On(System.Object)">
            <summary>
            Defines the receiver.
            </summary>
            <param name="receiver">The dynamic mock on which the expectation or stub is applied.</param>
            <returns>Method syntax defining the method, property or event.</returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.Method(System.String,System.Type[])">
            <summary>
            Methods the specified method name.
            </summary>
            <param name="methodName">Name of the method.</param>
            <param name="typeParams">The type params.</param>
            <returns></returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.Method(System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Defines a method.
            </summary>
            <param name="method">The method.</param>
            <param name="typeParams">The generic type params to match.</param>
            <returns>
            Argument syntax defining the arguments of the method.
            </returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.Method(NMock2.Matcher,System.Type[])">
            <summary>
            Methods the specified method matcher.
            </summary>
            <param name="methodMatcher">The method matcher.</param>
            <param name="typeParams">The type params.</param>
            <returns></returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.Method(NMock2.Matcher,NMock2.Matcher)">
            <summary>
            Defines a method.
            </summary>
            <param name="methodMatcher">Matcher for matching the method on an invocation.</param>
            <param name="typeParamsMatcher">Matchers for matching type parameters.</param>
            <returns>
            Argument syntax defining the arguments of the method.
            </returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.GetProperty(System.String)">
            <summary>
            Gets the property.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns></returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.SetProperty(System.String)">
            <summary>
            Sets the property.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns></returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.EventAdd(System.String)">
            <summary>
            Defines an event registration.
            </summary>
            <param name="eventName">Name of the event.</param>
            <returns>
            Match syntax defining the behavior of the event adder.
            </returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.EventAdd(System.String,NMock2.Matcher)">
            <summary>
            Defines an event registration.
            </summary>
            <param name="eventName">Name of the event.</param>
            <param name="listenerMatcher">The listener matcher.</param>
            <returns>
            Match syntax defining the behavior of the event adder.
            </returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.EventAdd(System.String,System.Delegate)">
            <summary>
            Defines an event registration.
            </summary>
            <param name="eventName">Name of the event.</param>
            <param name="equalListener">Delegate defining compatible listeners.</param>
            <returns>
            Match syntax defining the behavior of the event adder.
            </returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.EventRemove(System.String,NMock2.Matcher)">
            <summary>
            Defines an event deregistration.
            </summary>
            <param name="eventName">Name of the event.</param>
            <param name="listenerMatcher">The listener matcher.</param>
            <returns>
            Match syntax defining the behavior of the event remover.
            </returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.EventRemove(System.String)">
            <summary>
            Defines an event deregistration.
            </summary>
            <param name="eventName">Name of the event.</param>
            <returns>
            Match syntax defining the behavior of the event remover.
            </returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.EventRemove(System.String,System.Delegate)">
            <summary>
            Defines an event deregistration.
            </summary>
            <param name="eventName">Name of the event.</param>
            <param name="equalListener">Delegate defining compatible listeners.</param>
            <returns>
            Match syntax defining the behavior of the event remover.
            </returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.With(System.Object[])">
            <summary>
            Defines the arguments that are expected on the method call.
            </summary>
            <param name="expectedArguments">The expected arguments.</param>
            <returns>Matcher syntax.</returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.WithNoArguments">
            <summary>
            Defines that no arguments are expected on the method call.
            </summary>
            <returns>Matcher syntax.</returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.WithAnyArguments">
            <summary>
            Defines that all arguments are allowed on the method call.
            </summary>
            <returns>Matcher syntax.</returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.Matching(NMock2.Matcher)">
            <summary>
            Defines a matching criteria.
            </summary>
            <param name="matcher">The matcher.</param>
            <returns>
            Action syntax defining the action to take.
            </returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.Will(NMock2.IAction[])">
            <summary>
            Defines what will happen.
            </summary>
            <param name="actions">The actions to take.</param>
            <returns>
            Returns the comment syntax defined after will.
            </returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.Comment(System.String)">
            <summary>
            Adds a comment for the expectation that is added to the error message if the expectation is not met.
            </summary>
            <param name="comment">The comment that is shown in the error message if this expectation is not met.
            You can describe here why this expectation has to be met.</param>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.ArgumentMatchers(System.Object[])">
            <summary>
            Arguments the matchers.
            </summary>
            <param name="expectedArguments">The expected arguments.</param>
            <returns></returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.NewMethodNameMatcher(System.String,System.String)">
            <summary>
            News the method name matcher.
            </summary>
            <param name="description">The description.</param>
            <param name="methodName">Name of the method.</param>
            <returns></returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.EnsureMatchingMethodExistsOnMock(NMock2.Matcher,System.String)">
            <summary>
            Ensures the matching method exists on mock.
            </summary>
            <param name="methodMatcher">The method matcher.</param>
            <param name="methodDescription">The method description.</param>
        </member>
        <member name="P:NMock2.Internal.ExpectationBuilder.Get">
            <summary>
            Gets an indexer (get operation).
            </summary>
            <value>Get indexer syntax defining the value returned by the indexer.</value>
        </member>
        <member name="P:NMock2.Internal.ExpectationBuilder.Set">
            <summary>
            Gets an indexer (set operation).
            </summary>
            <value>Set indexer syntax defining the value the indexer is set to.</value>
        </member>
        <member name="T:NMock2.Syntax.IValueSyntax">
            <summary>
            Syntax defining a value.
            </summary>
        </member>
        <member name="M:NMock2.Syntax.IValueSyntax.To(NMock2.Matcher)">
            <summary>
            Defines a value.
            </summary>
            <param name="valueMatcher">The value matcher.</param>
            <returns>Match syntax defining the behavior of the value.</returns>
        </member>
        <member name="M:NMock2.Syntax.IValueSyntax.To(System.Object)">
            <summary>
            Defines a value.
            </summary>
            <param name="equalValue">The value.</param>
            <returns>Match syntax defining the behavior of the value.</returns>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.PropertyValueBuilder.#ctor(NMock2.Internal.ExpectationBuilder)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.ExpectationBuilder.PropertyValueBuilder"/> class.
            </summary>
            <param name="builder">The builder.</param>
        </member>
        <member name="T:NMock2.Syntax.IGetIndexerSyntax">
            <summary>
            Syntax defining an indexer get operation.
            </summary>
        </member>
        <member name="P:NMock2.Syntax.IGetIndexerSyntax.Item(System.Object[])">
            <summary>
            Defines the indexer.
            </summary>
            <value>
            Match syntax to define a matcher for the object returned by the indexer.
            </value>
            <param name="args">The arguments of the matcher.</param>
        </member>
        <member name="F:NMock2.Internal.ExpectationBuilder.IndexGetterBuilder.builder">
            <summary>
            Holds the instance to the <see cref="T:NMock2.Internal.ExpectationBuilder"/>.
            </summary>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.IndexGetterBuilder.#ctor(NMock2.Internal.BuildableExpectation,NMock2.Internal.ExpectationBuilder)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.ExpectationBuilder.IndexGetterBuilder"/> class.
            </summary>
            <param name="expectation">The expectation.</param>
            <param name="builder">The builder.</param>
        </member>
        <member name="M:NMock2.Internal.ExpectationBuilder.IndexSetterBuilder.#ctor(NMock2.Internal.BuildableExpectation,NMock2.Internal.ExpectationBuilder)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.ExpectationBuilder.IndexSetterBuilder"/> class.
            </summary>
            <param name="expectation">The expectation.</param>
            <param name="builder">The builder.</param>
        </member>
        <member name="T:NMock2.Syntax.IMockDefinitionSyntax">
            <summary>
            Syntax describing the initial characteristics of a new mock object.
            </summary>
        </member>
        <member name="M:NMock2.Syntax.IMockDefinitionSyntax.Implementing``1">
            <summary>
            Specifies a type that this mock should implement. This may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
            <typeparam name="T">The type to implement.</typeparam>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMockDefinitionSyntax.Implementing(System.Type[])">
            <summary>
            Specifies the types that this mock should implement. These may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
            <param name="types">The types to implement.</param>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMockDefinitionSyntax.OfStyle(NMock2.MockStyle)">
            <summary>
            Specifies how the mock object should behave when first created.
            It is invalid to set the MockStyle of a mock more than once.
            </summary>
            <param name="style">A MockStyle value.</param>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMockDefinitionSyntax.WithArgs(System.Object[])">
            <summary>
            Specifies the arguments for the constructor of the class to be mocked.
            Only applicable when mocking a class with a non-default constructor.
            It is invalid to specify the constructor arguments of a mock more than once.
            </summary>
            <param name="args">The arguments for the class constructor.</param>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:NMock2.Syntax.IMockDefinitionSyntax.Named(System.String)">
            <summary>
            Specifies a name for the mock. This will be used in error messages,
            and as the return value of ToString() if not mocking a class.
            It is invalid to specify the name of a mock more than once.
            </summary>
            <param name="name">The name for the mock.</param>
            <returns>The mock object definition.</returns>
        </member>
        <member name="T:Castle.Core.Interceptor.IInvocation">
            <summary>
            Encapsulates an invocation of a proxied method.
            </summary>
        </member>
        <member name="M:Castle.Core.Interceptor.IInvocation.SetArgumentValue(System.Int32,System.Object)">
            <summary>
            Overrides the value of an argument at the given <paramref name="index"/> with the
            new <paramref name="value"/> provided.
            </summary>
            <remarks>
            This method accepts an <see cref="T:System.Object"/>, however the value provided must be compatible
            with the type of the argument defined on the method, otherwise an exception will be thrown.
            </remarks>
            <param name="index">The index of the argument to override.</param>
            <param name="value">The new value for the argument.</param>
        </member>
        <member name="M:Castle.Core.Interceptor.IInvocation.GetArgumentValue(System.Int32)">
            <summary>
            Gets the value of the argument at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The index.</param>
            <returns>The value of the argument at the specified <paramref name="index"/>.</returns>
        </member>
        <member name="M:Castle.Core.Interceptor.IInvocation.GetConcreteMethod">
            <summary>
            Returns the concrete instantiation of the <see cref="P:Castle.Core.Interceptor.IInvocation.Method"/>, with any generic
            parameters bound to real types.
            </summary>
            <returns>
            The concrete instantiation of the <see cref="P:Castle.Core.Interceptor.IInvocation.Method"/>, or the <see cref="P:Castle.Core.Interceptor.IInvocation.Method"/> if
            not a generic method.
            </returns>
            <remarks>Can be slower than calling <see cref="P:Castle.Core.Interceptor.IInvocation.Method"/>.</remarks>
        </member>
        <member name="M:Castle.Core.Interceptor.IInvocation.GetConcreteMethodInvocationTarget">
            <summary>
            Returns the concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget"/>, with any
            generic parameters bound to real types.
            </summary>
            <returns>The concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget"/>, or
            <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget"/> if not a generic method.</returns>
            <remarks>Can be slower than calling <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget"/>.</remarks>
        </member>
        <member name="M:Castle.Core.Interceptor.IInvocation.Proceed">
            <summary>
            Proceeds the call to the next interceptor in line, and ultimately to the target method.
            </summary>
            <remarks>
            Since interface proxies without a target don't have the target implementation to proceed to,
            it is important, that the last interceptor does not call this method, otherwise a
            <see cref="T:System.NotImplementedException"/> will be thrown.
            </remarks>
        </member>
        <member name="P:Castle.Core.Interceptor.IInvocation.Proxy">
            <summary>
            Gets the proxy object on which the intercepted method is invoked.
            </summary>
            <value>Proxy object on which the intercepted method is invoked.</value>
        </member>
        <member name="P:Castle.Core.Interceptor.IInvocation.InvocationTarget">
            <summary>
            Gets the object on which the invocation is performed. This is different from proxy object
            because most of the time this will be the proxy target object.
            </summary>
            <seealso cref="T:Castle.Core.Interceptor.IChangeProxyTarget"/>
            <value>The invocation target.</value>
        </member>
        <member name="P:Castle.Core.Interceptor.IInvocation.TargetType">
            <summary>
            Gets the type of the target object for the intercepted method.
            </summary>
            <value>The type of the target object.</value>
        </member>
        <member name="P:Castle.Core.Interceptor.IInvocation.Arguments">
            <summary>
            Gets the arguments that the <see cref="P:Castle.Core.Interceptor.IInvocation.Method"/> has been invoked with.
            </summary>
            <value>The arguments the method was invoked with.</value>
        </member>
        <member name="P:Castle.Core.Interceptor.IInvocation.GenericArguments">
            <summary>
            Gets the generic arguments of the method.
            </summary>
            <value>The generic arguments, or null if not a generic method.</value>
        </member>
        <member name="P:Castle.Core.Interceptor.IInvocation.Method">
            <summary>
            Gets the <see cref="T:System.Reflection.MethodInfo"/> representing the method being invoked.
            </summary>
            <value>The <see cref="T:System.Reflection.MethodInfo"/> representing the method being invoked.</value>
        </member>
        <member name="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget">
            <summary>
            For interface proxies, this will point to the <see cref="T:System.Reflection.MethodInfo"/> on the target class.
            </summary>
            <value>The method invocation target.</value>
        </member>
        <member name="P:Castle.Core.Interceptor.IInvocation.ReturnValue">
            <summary>
            Gets or sets the return value of the method.
            </summary>
            <value>The return value of the method.</value>
        </member>
        <member name="T:NMock2.Actions.FireAction">
            <summary>
            Action that fires an event.
            </summary>
        </member>
        <member name="F:NMock2.Actions.FireAction.eventName">
            <summary>
            Stores the name of the event to fire.
            </summary>
        </member>
        <member name="F:NMock2.Actions.FireAction.eventArgs">
            <summary>
            Stores the event arguments.
            </summary>
        </member>
        <member name="M:NMock2.Actions.FireAction.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Actions.FireAction"/> class.
            </summary>
            <param name="eventName">Name of the event.</param>
            <param name="eventArgs">The event args.</param>
        </member>
        <member name="M:NMock2.Actions.FireAction.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Invokes this object. The event is fired on the receiver of the invocation.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.Actions.FireAction.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="M:NMock2.Monitoring.ProxiedObjectIdentity.#ctor(System.Object,NMock2.Monitoring.IInvokable)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Monitoring.ProxiedObjectIdentity"/> class.
            </summary>
            <param name="identityProvider">The identity provider.</param>
            <param name="next">The next object to be invoked.</param>
        </member>
        <member name="T:NMock2.Monitoring.ParameterList">
            <summary>
            Manages a list of parameters for a mocked method together with the parameter's values.
            </summary>
        </member>
        <member name="F:NMock2.Monitoring.ParameterList.method">
            <summary>
            Holds the method to be mocked.
            </summary>
        </member>
        <member name="F:NMock2.Monitoring.ParameterList.values">
            <summary>
            An array holding the values of the parameters.
            </summary>
        </member>
        <member name="F:NMock2.Monitoring.ParameterList.isValueSet">
            <summary>
            Holds a boolean for each value if it was set or not.
            </summary>
        </member>
        <member name="M:NMock2.Monitoring.ParameterList.#ctor(System.Reflection.MethodInfo,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Monitoring.ParameterList"/> class.
            </summary>
            <param name="method">The method to be mocked.</param>
            <param name="values">The values of the parameters.</param>
        </member>
        <member name="M:NMock2.Monitoring.ParameterList.IsValueSet(System.Int32)">
            <summary>
            Determines whether the value specified by index was set.
            </summary>
            <param name="index">The index.</param>
            <returns>
            Returns <c>true</c> if value specified by index was set; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NMock2.Monitoring.ParameterList.MarkAllValuesAsSet">
            <summary>
            Marks all values as set.
            </summary>
        </member>
        <member name="M:NMock2.Monitoring.ParameterList.CanValueBeSet(System.Int32)">
            <summary>
            Determines whether the parameter specified by index can be set.
            </summary>
            <param name="index">The index of the parameter.</param>
            <returns>
            Returns <c>true</c> if the parameter specified by index can be set; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NMock2.Monitoring.ParameterList.GetParameterName(System.Int32)">
            <summary>
            Gets the parameter name by index.
            </summary>
            <param name="index">The index of the parameter name to get.</param>
            <returns>
            Returns the parameter name with the given index.
            </returns>
        </member>
        <member name="P:NMock2.Monitoring.ParameterList.Count">
            <summary>
            Gets the number of values.
            </summary>
            <value>The number of values.</value>
        </member>
        <member name="P:NMock2.Monitoring.ParameterList.AsArray">
            <summary>
            Gets the values as array.
            </summary>
            <value>Values as array.</value>
        </member>
        <member name="P:NMock2.Monitoring.ParameterList.Item(System.Int32)">
            <summary>
            Gets or sets the <see cref="T:System.Object"/> with the specified index.
            </summary>
            <param name="index">The index of the value to be get or set.</param>
            <value>
            The value of a parameter specified by its <paramref name="index"/>.
            </value>
        </member>
        <member name="T:NMock2.Monitoring.Invocation">
            <summary>
            Represents the invocation of a method on an object (receiver).
            </summary>
        </member>
        <member name="F:NMock2.Monitoring.Invocation.Receiver">
            <summary>
            Holds the receiver providing the method.
            </summary>
        </member>
        <member name="F:NMock2.Monitoring.Invocation.Method">
            <summary>
            Holds the method that is being invoked.
            </summary>
        </member>
        <member name="F:NMock2.Monitoring.Invocation.Parameters">
            <summary>
            Holds the parameterlist of the invocation.
            </summary>
        </member>
        <member name="F:NMock2.Monitoring.Invocation.result">
            <summary>
            Holds the result of the invocation.
            </summary>
        </member>
        <member name="F:NMock2.Monitoring.Invocation.exception">
            <summary>
            Holds the exception to be thrown. When this field has been set, <see cref="F:NMock2.Monitoring.Invocation.isThrowing"/> will become true.
            </summary>
        </member>
        <member name="F:NMock2.Monitoring.Invocation.isThrowing">
            <summary>
            Holds a boolean value whether the method is throwing an exception or not.
            </summary>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.#ctor(System.Object,System.Reflection.MethodInfo,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Monitoring.Invocation"/> class.
            </summary>
            <param name="receiver">The receiver providing the method.</param>
            <param name="method">The method.</param>
            <param name="parameters">The parameters passed to the method..</param>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.InvokeOn(System.Object)">
            <summary>
            Invokes this invocation on the specified receiver and stores the result and exception
            returns/thrown by the invocation.
            </summary>
            <param name="otherReceiver">The other receiver.</param>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object to the specified <paramref name="writer"/>.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.CheckReturnType(System.Object)">
            <summary>
            Checks the returnType of the initialized method if it is valid to be mocked.
            </summary>
            <param name="value">The return value to be checked.</param>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.MethodIsProperty">
            <summary>
            Determines whether the initialized method is a property.
            </summary>
            <returns>
            Returns true if initialized method is a property; false otherwise.
            </returns>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.MethodIsIndexerGetter">
            <summary>
            Determines whether the initialized method is an index getter.
            </summary>
            <returns>
            Returns true if initialized method is an index getter; false otherwise.
            </returns>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.MethodIsIndexerSetter">
            <summary>
            Determines whether the initialized method is an index setter.
            </summary>
            <returns>
            Returns true if initialized method is an index setter; false otherwise.
            </returns>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.MethodIsEventAdder">
            <summary>
            Determines whether the initialized method is an event adder.
            </summary>
            <returns>
            Returns true if initialized method is an event adder; false otherwise.
            </returns>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.MethodIsEventRemover">
            <summary>
            Determines whether the initialized method is an event remover.
            </summary>
            <returns>
            Returns true if initialized method is an event remover; false otherwise.
            </returns>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.DescribeAsProperty(System.IO.TextWriter)">
            <summary>
            Describes the property with parameters to the specified <paramref name="writer"/>.
            </summary>
            <param name="writer">The writer where the description is written to.</param>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.DescribeAsIndexerGetter(System.IO.TextWriter)">
            <summary>
            Describes the index setter with parameters to the specified <paramref name="writer"/>.
            </summary>
            <param name="writer">The writer where the description is written to.</param>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.DescribeAsIndexerSetter(System.IO.TextWriter)">
            <summary>
            Describes the index setter with parameters to the specified <paramref name="writer"/>.
            </summary>
            <param name="writer">The writer where the description is written to.</param>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.DescribeNormalMethod(System.IO.TextWriter)">
            <summary>
            Describes the method with parameters to the specified <paramref name="writer"/>.
            </summary>
            <param name="writer">The writer where the description is written to.</param>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.WriteTypeParams(System.IO.TextWriter)">
            <summary>
            Writes the generic parameters of the method to the specified <paramref name="writer"/>.
            </summary>
            <param name="writer">The writer where the description is written to.</param>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.WriteParameterList(System.IO.TextWriter,System.Int32)">
            <summary>
            Writes the parameter list to the specified <paramref name="writer"/>.
            </summary>
            <param name="writer">The writer where the description is written to.</param>
            <param name="count">The count of parameters to describe.</param>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.DescribeAsEventAdder(System.IO.TextWriter)">
            <summary>
            Describes the event adder to the specified <paramref name="writer"/>.
            </summary>
            <param name="writer">The writer where the description is written to.</param>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.DescribeAsEventRemover(System.IO.TextWriter)">
            <summary>
            Describes the event remover to the specified <paramref name="writer"/>.
            </summary>
            <param name="writer">The writer where the description is written to.</param>
        </member>
        <member name="M:NMock2.Monitoring.Invocation.DescribeType(System.Object)">
            <summary>
            Describes the interfaces used for <see cref="M:NMock2.Monitoring.Invocation.DescribeTo(System.IO.TextWriter)"/>.
            </summary>
            <param name="obj">The object which interfaces to describe.</param>
            <returns>
            Returns a string containing the description of the given object's interfaces.
            </returns>
        </member>
        <member name="P:NMock2.Monitoring.Invocation.Result">
            <summary>
            Gets or sets the result of the invocation.
            </summary>
            <value>The result.</value>
        </member>
        <member name="P:NMock2.Monitoring.Invocation.Exception">
            <summary>
            Gets or sets the exception that is thrown on the invocation.
            </summary>
            <value>The exception.</value>
        </member>
        <member name="P:NMock2.Monitoring.Invocation.IsThrowing">
            <summary>
            Gets a value indicating whether an exception is thrown an this invocation.
            </summary>
            <value>
                <c>true</c> if this invocation is throwing an exception; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:NMock2.ResolveTypeDelegate">
            <summary>
            Delegate used to override default type returned in stub behavior.
            </summary>
            <param name="mock">The mock that has to return a value.</param>
            <param name="requestedType">Type of the return value.</param>
            <returns>The object to return as return value for the requested type.</returns>
        </member>
        <member name="T:NMock2.Mockery">
            <summary>
            The mockery is used to create dynamic mocks and check that all expectations were met during a unit test.
            </summary>
            <remarks>Name inspired by Ivan Moore.</remarks>
        </member>
        <member name="F:NMock2.Mockery.availableMockObjectFactories">
            <summary>
            In the rare case where the default mock object factory is replaced, we hold on to the
            previous factory (or factories) in case we need to switch back to them.
            </summary>
        </member>
        <member name="F:NMock2.Mockery.currentMockObjectFactory">
            <summary>
            The mock object factory that is being used by this Mockery instance.
            </summary>
        </member>
        <member name="F:NMock2.Mockery.stubMockStyleDictionary">
            <summary>
            Holds all mapping from mocks/types to mock styles.
            </summary>
        </member>
        <member name="F:NMock2.Mockery.defaultMockObjectFactory">
            <summary>
            The mock object factory that will be used when a new Mockery instance is created
            </summary>
        </member>
        <member name="F:NMock2.Mockery.depth">
            <summary>
            Depth of cascaded ordered, unordered expectation blocks.
            </summary>
        </member>
        <member name="F:NMock2.Mockery.expectations">
            <summary>
            All expectations.
            </summary>
        </member>
        <member name="F:NMock2.Mockery.topOrdering">
            <summary>
            Expectations at current cascade level.
            </summary>
        </member>
        <member name="F:NMock2.Mockery.thrownUnexpectedInvocationException">
            <summary>
            If an unexpected invocation exception is thrown then it is stored here to re-throw it in the 
            <see cref="M:NMock2.Mockery.VerifyAllExpectationsHaveBeenMet"/> method - exception cannot be swallowed by tested code.
            </summary>
        </member>
        <member name="F:NMock2.Mockery.resolveTypeDelegate">
            <summary>
            The delegate used to resolve the default type returned as return value in calls to mocks with stub behavior.
            </summary>
        </member>
        <member name="M:NMock2.Mockery.#cctor">
            <summary>
            Initializes static members of the <see cref="T:NMock2.Mockery"/> class.
            </summary>
        </member>
        <member name="M:NMock2.Mockery.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Mockery"/> class.
            Clears all expectations.
            </summary>
        </member>
        <member name="M:NMock2.Mockery.ChangeDefaultMockObjectFactory(System.Type)">
            <summary>
            Allows the default <see cref="T:NMock2.Monitoring.IMockObjectFactory"/> to be replaced with a different implementation.
            </summary>
            <param name="factoryType">The System.Type of the <see cref="T:NMock2.Monitoring.IMockObjectFactory"/> implementation to use.
            This is expected to implement <see cref="T:NMock2.Monitoring.IMockObjectFactory"/> and have a default constructor.</param>
        </member>
        <member name="M:NMock2.Mockery.NewMock(System.Type,NMock2.IMockDefinition)">
            <summary>
            Creates a new dynamic mock of the specified type using the supplied definition.
            </summary>
            <param name="mockedType">The type to mock.</param>
            <param name="definition">An <see cref="T:NMock2.IMockDefinition"/> to create the mock from.</param>
            <returns>A dynamic mock for the specified type.</returns>
        </member>
        <member name="M:NMock2.Mockery.NewMock(System.Type,System.Object[])">
            <summary>
            Creates a new dynamic mock of the specified type.
            </summary>
            <param name="mockedType">The type to mock.</param>
            <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
            <returns>A dynamic mock for the specified type.</returns>
        </member>
        <member name="M:NMock2.Mockery.NewMock(System.Type,NMock2.MockStyle,System.Object[])">
            <summary>
            Creates a new dynamic mock of the specified type.
            </summary>
            <param name="mockedType">The type to mock.</param>
            <param name="mockStyle">Specifies how the mock object should behave when first created.</param>
            <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
            <returns>A named dynamic mock for the specified type.</returns>
        </member>
        <member name="M:NMock2.Mockery.NewMock``1(NMock2.IMockDefinition)">
            <summary>
            Creates a new dynamic mock of the specified type using the supplied definition.
            </summary>
            <typeparam name="TMockedType">The type to mock.</typeparam>
            <param name="definition">An <see cref="T:NMock2.IMockDefinition"/> to create the mock from.</param>
            <returns>A dynamic mock for the specified type.</returns>
        </member>
        <member name="M:NMock2.Mockery.NewMock``1(System.Object[])">
            <summary>
            Creates a new dynamic mock of the specified type.
            </summary>
            <typeparam name="TMockedType">The type to mock.</typeparam>
            <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
            <returns>A dynamic mock for the specified type.</returns>
        </member>
        <member name="M:NMock2.Mockery.NewMock``1(NMock2.MockStyle,System.Object[])">
            <summary>
            Creates a new dynamic mock of the specified type.
            </summary>
            <typeparam name="TMockedType">The type to mock.</typeparam>
            <param name="mockStyle">Specifies how the mock object should behave when first created.</param>
            <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
            <returns>A dynamic mock for the specified type.</returns>
        </member>
        <member name="M:NMock2.Mockery.NewNamedMock(System.Type,System.String,System.Object[])">
            <summary>
            Creates a new named dynamic mock of the specified type.
            </summary>
            <param name="mockedType">The type to mock.</param>
            <param name="name">A name for the mock that will be used in error messages.</param>
            <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
            <returns>A named mock.</returns>
        </member>
        <member name="M:NMock2.Mockery.NewNamedMock(System.Type,System.String,NMock2.MockStyle,System.Object[])">
            <summary>
            Creates a new named dynamic mock of the specified type and allows the style
            of the mock to be specified.
            </summary>
            <param name="mockedType">The type to mock.</param>
            <param name="name">A name for the mock that will be used in error messages.</param>
            <param name="mockStyle">Specifies how the mock object should behave when first created.</param>
            <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
            <returns>A named mock.</returns>
        </member>
        <member name="M:NMock2.Mockery.NewNamedMock``1(System.String,System.Object[])">
            <summary>
            Creates a new named dynamic mock of the specified type.
            </summary>
            <typeparam name="TMockedType">The type to mock.</typeparam>
            <param name="name">A name for the mock that will be used in error messages.</param>
            <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
            <returns>A named mock.</returns>
        </member>
        <member name="M:NMock2.Mockery.NewNamedMock``1(System.String,NMock2.MockStyle,System.Object[])">
            <summary>
            Creates a new named dynamic mock of the specified type and allows the style
            of the mock to be specified.
            </summary>
            <typeparam name="TMockedType">The type to mock.</typeparam>
            <param name="name">A name for the mock that will be used in error messages.</param>
            <param name="mockStyle">Specifies how the mock object should behave when first created.</param>
            <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
            <returns>A named mock.</returns>
        </member>
        <member name="M:NMock2.Mockery.VerifyAllExpectationsHaveBeenMet">
            <summary>
            Verifies that all expectations have been met.
            Will be called in <see cref="M:NMock2.Mockery.Dispose"/>, too. 
            </summary>
        </member>
        <member name="M:NMock2.Mockery.Dispose">
            <summary>
            Disposes the mockery be verifying that all expectations were met.
            </summary>
        </member>
        <member name="M:NMock2.Mockery.SetResolveTypeHandler(NMock2.ResolveTypeDelegate)">
            <summary>
            Sets the resolve type handler used to override default values returned by stubs.
            </summary>
            <param name="resolveTypeHandler">The resolve type handler.</param>
        </member>
        <member name="M:NMock2.Mockery.SetStubMockStyle(System.Object,NMock2.MockStyle)">
            <summary>
            Sets the mock style used for all properties and methods returning a value of any type of the <paramref name="mock"/>.
            Can be overridden with a type specific mock style with <see cref="M:NMock2.Mockery.SetStubMockStyle``1(System.Object,NMock2.MockStyle)"/>.
            </summary>
            <param name="mock">The mock (with mock style Stub).</param>
            <param name="nestedMockStyle">The nested mock style.</param>
        </member>
        <member name="M:NMock2.Mockery.SetStubMockStyle``1(System.Object,NMock2.MockStyle)">
            <summary>
            Sets the mock style used for all properties and methods returning a value of type <typeparamref name="TStub"/>
            of the <paramref name="mock"/>.
            </summary>
            <typeparam name="TStub">The type of the stub.</typeparam>
            <param name="mock">The mock (with mock style Stub).</param>
            <param name="nestedMockStyle">The nested mock style.</param>
        </member>
        <member name="M:NMock2.Mockery.SetStubMockStyle(System.Object,System.Type,NMock2.MockStyle)">
            <summary>
            Sets the mock style used for all properties and methods returning a value of type <paramref name="nestedMockType"/>
            of the <paramref name="mock"/>.
            </summary>
            <param name="mock">The mock (with mock style Stub).</param>
            <param name="nestedMockType">Type of the nested mock.</param>
            <param name="nestedMockStyle">The nested mock style.</param>
        </member>
        <member name="M:NMock2.Mockery.ClearExpectation(System.Object)">
            <summary>
            Clears all expectation on the specified mock.
            </summary>
            <param name="mock">The mock for which all expectations are cleared.</param>
        </member>
        <member name="M:NMock2.Mockery.AddExpectation(NMock2.IExpectation)">
            <summary>
            Adds the expectation.
            </summary>
            <param name="expectation">The expectation.</param>
        </member>
        <member name="M:NMock2.Mockery.ResolveType(System.Object,System.Type)">
            <summary>
            Resolves the return value to be used in a call to a mock with stub behavior.
            </summary>
            <param name="mock">The mock on which the call is made.</param>
            <param name="requestedType">The type of the return value.</param>
            <returns>The object to be returned as return value; or <see cref="F:System.Reflection.Missing.Value"/>
            if the default value should be used.</returns>
        </member>
        <member name="M:NMock2.Mockery.GetDependencyMockStyle(System.Object,System.Type)">
            <summary>
            Gets the mock style to be used for a mock created for a return value of a call to mock with stub behavior.
            </summary>
            <param name="mock">The mock that wants to create a mock.</param>
            <param name="requestedType">The type of the requested mock.</param>
            <returns>The mock style to use on the created mock. Null if <see cref="F:NMock2.MockStyle.Default"/> has to be used.</returns>
        </member>
        <member name="M:NMock2.Mockery.Dispatch(NMock2.Monitoring.Invocation)">
            <summary>
            Dispatches the specified invocation.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.Mockery.HasExpectationFor(NMock2.Monitoring.Invocation)">
            <summary>
            Determines whether there exist expectations for the specified invocation.
            </summary>
            <param name="invocation">The invocation.</param>
            <returns><c>true</c> if there exist expectations for the specified invocation; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NMock2.Mockery.CastToMockObject(System.Object)">
            <summary>
            Casts the argument to <see cref="T:NMock2.Internal.IMockObject"/>.
            </summary>
            <param name="mock">The object to cast.</param>
            <returns>The argument casted to <see cref="T:NMock2.Internal.IMockObject"/></returns>
            <throws cref="T:System.ArgumentNullException">Thrown if <paramref name="mock"/> is null</throws>
            <throws cref="T:System.ArgumentException">Thrown if <paramref name="mock"/> is not a <see cref="T:NMock2.Internal.IMockObject"/></throws>
        </member>
        <member name="M:NMock2.Mockery.ClearExpectations">
            <summary>
            Clears the expectations.
            </summary>
        </member>
        <member name="M:NMock2.Mockery.Push(NMock2.Internal.IExpectationOrdering)">
            <summary>
            Pushes the specified new ordering on the expectations stack.
            </summary>
            <param name="newOrdering">The new ordering.</param>
            <returns>Disposable popper.</returns>
        </member>
        <member name="M:NMock2.Mockery.Pop(NMock2.Internal.IExpectationOrdering)">
            <summary>
            Pops the specified old ordering from the expectations stack.
            </summary>
            <param name="oldOrdering">The old ordering.</param>
        </member>
        <member name="M:NMock2.Mockery.FailUnmetExpectations">
            <summary>
            Throws an exception listing all unmet expectations.
            </summary>
        </member>
        <member name="M:NMock2.Mockery.FailUnexpectedInvocation(NMock2.Monitoring.Invocation)">
            <summary>
            Throws an exception indicating that the specified invocation is not expected.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="P:NMock2.Mockery.Ordered">
            <summary>
            Gets a disposable object and tells the mockery that the following expectations are ordered, i.e. they have to be met in the specified order.
            Dispose the returned value to return to previous mode.
            </summary>
            <value>Disposable object. When this object is disposed then the ordered expectation mode is set back to the mode it was previously
            to call to <see cref="P:NMock2.Mockery.Ordered"/>.</value>
        </member>
        <member name="P:NMock2.Mockery.Unordered">
            <summary>
            Gets a disposable object and tells the mockery that the following expectations are unordered, i.e. they can be met in any order.
            Dispose the returned value to return to previous mode.
            </summary>
            <value>Disposable object. When this object is disposed then the unordered expectation mode is set back to the mode it was previously
            to the call to <see cref="P:NMock2.Mockery.Unordered"/>.</value>
        </member>
        <member name="T:NMock2.Mockery.Popper">
            <summary>
            A popper pops an expectation ordering from the expectations stack on disposal.
            </summary>
        </member>
        <member name="F:NMock2.Mockery.Popper.mockery">
            <summary>
            The mockery.
            </summary>
        </member>
        <member name="F:NMock2.Mockery.Popper.previous">
            <summary>
            The previous expectation ordering.
            </summary>
        </member>
        <member name="M:NMock2.Mockery.Popper.#ctor(NMock2.Mockery,NMock2.Internal.IExpectationOrdering)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Mockery.Popper"/> class.
            </summary>
            <param name="mockery">The mockery.</param>
            <param name="previous">The previous.</param>
        </member>
        <member name="M:NMock2.Mockery.Popper.Dispose">
            <summary>
            Pops the expectation ordering from the stack.
            </summary>
        </member>
        <member name="T:NMock2.Matchers.ToStringMatcher">
            <summary>
            Matcher that checks whether the actual value in string representation (actual.ToString())
            matches with the wrapped matcher.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.ToStringMatcher.matcher">
            <summary>
            Holds the wrapped matcher.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.ToStringMatcher.#ctor(NMock2.Matcher)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.ToStringMatcher"/> class.
            </summary>
            <param name="matcher">The wrapped matcher.</param>
        </member>
        <member name="M:NMock2.Matchers.ToStringMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object in string representation (o.ToString()) matches the wrapped matcher.</returns>
        </member>
        <member name="M:NMock2.Matchers.ToStringMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Matchers.AlwaysMatcher">
            <summary>
            A matcher that will always or never match independent of the value matched but depending on how it is initialized.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.AlwaysMatcher.matches">
            <summary>
            Stores the matcher value which was given at initialization.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.AlwaysMatcher.description">
            <summary>
            Stores the description which was given at initialization.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.AlwaysMatcher.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.AlwaysMatcher"/> class.
            </summary>
            <param name="matches">if set to <c>true</c> the matcher will always match, otherwise it will never match.</param>
            <param name="description">The description which will be printed out when calling <see cref="M:NMock2.Matchers.AlwaysMatcher.DescribeTo(System.IO.TextWriter)"/>.</param>
        </member>
        <member name="M:NMock2.Matchers.AlwaysMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Returns whether the object matches.</returns>
        </member>
        <member name="M:NMock2.Matchers.AlwaysMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.DefinedAs">
            <summary>
            Defines the initial characteristics of a new mock object.
            This is normally used in conjunction with <see cref="M:NMock2.Mockery.NewMock``1(NMock2.IMockDefinition)"/>
            </summary>
        </member>
        <member name="M:NMock2.DefinedAs.Implementing``1">
            <summary>
            Specifies a type that this mock should implement. This may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
            <typeparam name="T">The type to implement.</typeparam>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:NMock2.DefinedAs.Implementing(System.Type[])">
            <summary>
            Specifies the types that this mock should implement. These may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
            <param name="types">The types to implement.</param>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:NMock2.DefinedAs.OfStyle(NMock2.MockStyle)">
            <summary>
            Specifies how the mock object should behave when first created.
            </summary>
            <param name="style">A MockStyle value.</param>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:NMock2.DefinedAs.WithArgs(System.Object[])">
            <summary>
            Specifies the arguments for the constructor of the class to be mocked.
            Only applicable when mocking a class with a non-default constructor.
            </summary>
            <param name="args">The arguments for the class constructor.</param>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:NMock2.DefinedAs.Named(System.String)">
            <summary>
            Specifies a name for the mock. This will be used in error messages,
            and as the return value of ToString() if not mocking a class.
            </summary>
            <param name="name">The name for the mock.</param>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor(Castle.DynamicProxy.IProxyGenerationHook)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions"/> class.
            </summary>
            <param name="hook">The hook.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions"/> class.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewArrayExpression">
            <summary>
            Summary description for NewArrayExpression.
            </summary>
        </member>
        <member name="T:Castle.Core.Smtp.DefaultSmtpSender">
            <summary>
            Default <see cref="T:Castle.Core.Smtp.IEmailSender"/> implementation.
            </summary>
        </member>
        <member name="T:Castle.Core.Smtp.IEmailSender">
            <summary>
            Email sender abstraction.
            </summary>
        </member>
        <member name="M:Castle.Core.Smtp.IEmailSender.Send(System.String,System.String,System.String,System.String)">
            <summary>
            Sends a mail message.
            </summary>
            <param name="from">From field</param>
            <param name="to">To field</param>
            <param name="subject">E-mail's subject</param>
            <param name="messageText">message's body</param>
        </member>
        <member name="M:Castle.Core.Smtp.IEmailSender.Send(System.Net.Mail.MailMessage)">
            <summary>
            Sends a <see cref="T:System.Net.Mail.MailMessage">message</see>. 
            </summary>
            <param name="message"><see cref="T:System.Net.Mail.MailMessage">Message</see> instance</param>
        </member>
        <member name="M:Castle.Core.Smtp.IEmailSender.Send(System.Collections.Generic.IEnumerable{System.Net.Mail.MailMessage})">
            <summary>
            Sends multiple <see cref="T:System.Net.Mail.MailMessage">messages</see>. 
            </summary>
            <param name="messages">List of <see cref="T:System.Net.Mail.MailMessage">messages</see></param>
        </member>
        <member name="M:Castle.Core.Smtp.DefaultSmtpSender.#ctor(System.String)">
            <summary>
            This service implementation
            requires a host name in order to work
            </summary>
            <param name="hostname">The smtp server name</param>
        </member>
        <member name="M:Castle.Core.Smtp.DefaultSmtpSender.Send(System.String,System.String,System.String,System.String)">
            <summary>
            Sends a message. 
            </summary>
            <exception cref="T:System.ArgumentNullException">If any of the parameters is null</exception>
            <param name="from">From field</param>
            <param name="to">To field</param>
            <param name="subject">e-mail's subject</param>
            <param name="messageText">message's body</param>
        </member>
        <member name="M:Castle.Core.Smtp.DefaultSmtpSender.Send(System.Net.Mail.MailMessage)">
            <summary>
            Sends a message. 
            </summary>
            <exception cref="T:System.ArgumentNullException">If the message is null</exception>
            <param name="message">Message instance</param>
        </member>
        <member name="M:Castle.Core.Smtp.DefaultSmtpSender.Configure(System.Net.Mail.SmtpClient)">
            <summary>
            Configures the sender
            with port information and eventual credential
            informed
            </summary>
            <param name="smtpClient">Message instance</param>
        </member>
        <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Port">
            <summary>
            Gets or sets the port used to 
            access the SMTP server
            </summary>
        </member>
        <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Hostname">
            <summary>
            Gets the hostname.
            </summary>
            <value>The hostname.</value>
        </member>
        <member name="P:Castle.Core.Smtp.DefaultSmtpSender.AsyncSend">
            <summary>
            Gets or sets a value which is used to 
            configure if emails are going to be sent asyncrhonously or not.
            </summary>
        </member>
        <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Timeout">
            <summary>
            Gets or sets a value that specifies 
            the amount of time after which a synchronous Send call times out.
            </summary>
        </member>
        <member name="P:Castle.Core.Smtp.DefaultSmtpSender.UseSsl">
            <summary>
            Gets or sets a value indicating whether the email should be sent using 
            a secure communication channel.
            </summary>
            <value><c>true</c> if should use SSL; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Domain">
            <summary>
            Gets or sets the domain.
            </summary>
            <value>The domain.</value>
        </member>
        <member name="P:Castle.Core.Smtp.DefaultSmtpSender.UserName">
            <summary>
            Gets or sets the name of the user.
            </summary>
            <value>The name of the user.</value>
        </member>
        <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Password">
            <summary>
            Gets or sets the password.
            </summary>
            <value>The password.</value>
        </member>
        <member name="P:Castle.Core.Smtp.DefaultSmtpSender.HasCredentials">
            <summary>
            Gets a value indicating whether credentials were informed.
            </summary>
            <value>
            <see langword="true"/> if this instance has credentials; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="T:Castle.Core.MethodMetaModel">
            <summary>
            Represents meta information associated with a method
            (not yet defined)
            </summary>
        </member>
        <member name="M:Castle.Core.MethodMetaModel.#ctor(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.MethodMetaModel"/> class.
            </summary>
            <param name="configNode">The config node.</param>
        </member>
        <member name="P:Castle.Core.MethodMetaModel.ConfigNode">
            <summary>
            Gets the config node.
            </summary>
            <value>The config node.</value>
        </member>
        <member name="T:Castle.Core.ConstructorCandidateCollection">
            <summary>
            Collection of <see cref="T:Castle.Core.ConstructorCandidate"/>
            </summary>
        </member>
        <member name="P:Castle.Core.ConstructorCandidateCollection.FewerArgumentsCandidate">
            <summary>
            Gets the fewer arguments candidate.
            </summary>
            <value>The fewer arguments candidate.</value>
        </member>
        <member name="T:Castle.Core.Logging.NullLogger">
            <summary>
            The Null Logger class.  This is useful for implementations where you need
            to provide a logger to a utility class, but do not want any output from it.
            It also helps when you have a utility that does not have a logger to supply.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.#ctor">
            <summary>
            Creates a new <c>NullLogger</c>.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String)">
            <summary>
            No-op.
            </summary>
            <param name="message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Exception)">
            <summary>
            No-op. 
            </summary>
            <param name="exception">Ignored</param>
            <param name="message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="exception">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="formatProvider">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="exception">Ignored</param>
            <param name="formatProvider">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Info(System.String)">
            <summary>
            No-op.
            </summary>
            <param name="message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Exception)">
            <summary>
            No-op. 
            </summary>
            <param name="exception">Ignored</param>
            <param name="message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="exception">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="formatProvider">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="exception">Ignored</param>
            <param name="formatProvider">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String)">
            <summary>
            No-op.
            </summary>
            <param name="message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Exception)">
            <summary>
            No-op. 
            </summary>
            <param name="exception">Ignored</param>
            <param name="message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="exception">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="formatProvider">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="exception">Ignored</param>
            <param name="formatProvider">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Error(System.String)">
            <summary>
            No-op.
            </summary>
            <param name="message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Exception)">
            <summary>
            No-op. 
            </summary>
            <param name="exception">Ignored</param>
            <param name="message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="exception">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="formatProvider">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="exception">Ignored</param>
            <param name="formatProvider">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String)">
            <summary>
            No-op.
            </summary>
            <param name="message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Exception)">
            <summary>
            No-op.
            </summary>
            <param name="exception">Ignored</param>
            <param name="message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="exception">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="formatProvider">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="exception">Ignored</param>
            <param name="formatProvider">Ignored</param>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalError(System.String)">
            <summary>
            No-op.
            </summary>
            <param name="message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalError(System.String,System.Exception)">
            <summary>
            No-op.
            </summary>
            <param name="message">Ignored</param>
            <param name="exception">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalError(System.String,System.Object[])">
            <summary>
            No-op.
            </summary>
            <param name="format">Ignored</param>
            <param name="args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.CreateChildLogger(System.String)">
            <summary>
            Returns this <c>NullLogger</c>.
            </summary>
            <param name="loggerName">Ignored</param>
            <returns>This ILogger instance.</returns> 
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsDebugEnabled">
            <summary>
            No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsInfoEnabled">
            <summary>
            No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsWarnEnabled">
            <summary>
            No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsErrorEnabled">
            <summary>
            No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsFatalEnabled">
            <summary>
            No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsFatalErrorEnabled">
            <summary>
            No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.GlobalProperties">
            <summary>
            Returns empty context properties.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.ThreadProperties">
            <summary>
            Returns empty context properties.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.ThreadStacks">
            <summary>
            Returns empty context stacks.
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.IContextProperties">
            <summary>
            Interface for Context Properties implementations
            </summary>
            <remarks>
            <para>
            This interface defines a basic property get set accessor.
            </para>
            <para>
            Based on the ContextPropertiesBase of log4net, by Nicko Cadell.
            </para>
            </remarks>
        </member>
        <member name="P:Castle.Core.Logging.IContextProperties.Item(System.String)">
            <summary>
            Gets or sets the value of a property
            </summary>
            <value>
            The value for the property with the specified key
            </value>
            <remarks>
            <para>
            Gets or sets the value of a property
            </para>
            </remarks>
        </member>
        <member name="M:Castle.Core.Interceptor.IProxyTargetAccessor.DynProxyGetTarget">
            <summary>
            Get the proxy target (note that null is a valid target!)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Interceptor.IProxyTargetAccessor.GetInterceptors">
            <summary>
            Gets the interceptors for the proxy
            </summary>
            <returns></returns>
        </member>
        <member name="T:NMock2.Actions.CollectAction">
            <summary>
            Action that returns the n-th element of the arguments to an invocation.
            </summary>
        </member>
        <member name="F:NMock2.Actions.CollectAction.argumentIndex">
            <summary>
            Stores the index of the argument.
            </summary>
        </member>
        <member name="F:NMock2.Actions.CollectAction.collectedArgumentValue">
            <summary>
            Stores the parameter when this action gets invoked.
            </summary>
        </member>
        <member name="M:NMock2.Actions.CollectAction.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Actions.CollectAction"/> class.
            </summary>
            <param name="argumentIndex">Index of the argument to collect.</param>
        </member>
        <member name="M:NMock2.Actions.CollectAction.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Invokes this object.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.Actions.CollectAction.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="P:NMock2.Actions.CollectAction.Parameter">
            <summary>
            Gets the collected parameter.
            </summary>
            <value>The collected parameter (n-th parameter of parameter list of the method's call.</value>
        </member>
        <member name="T:NMock2.Verify">
            <summary>
            Verify that a condition is met.
            </summary>
        </member>
        <member name="M:NMock2.Verify.That(System.Object,NMock2.Matcher,System.String,System.Object[])">
            <summary>
            Verifies that the <paramref name="actualValue"/> is matched by the <paramref name="matcher"/>.
            </summary>
            <param name="actualValue">The actual value to match.</param>
            <param name="matcher">The matcher.</param>
            <param name="message">The error message.</param>
            <param name="formatArgs">The format args for the error message.</param>
            <exception cref="T:NMock2.Internal.ExpectationException">Thrown if value does not match.</exception>
        </member>
        <member name="M:NMock2.Verify.That(System.Object,NMock2.Matcher)">
            <summary>
            Verifies that the <paramref name="actualValue"/> is matched by the <paramref name="matcher"/>.
            </summary>
            <param name="actualValue">The actual value.</param>
            <param name="matcher">The matcher.</param>
            <exception cref="T:NMock2.Internal.ExpectationException">Thrown if value does not match.</exception>
        </member>
        <member name="M:NMock2.Verify.WriteDescriptionOfFailedMatch(System.IO.TextWriter,System.Object,NMock2.Matcher)">
            <summary>
            Writes the description of a failed match to the specified <paramref name="writer"/>.
            </summary>
            <param name="writer">The <see cref="T:System.IO.TextWriter"/> where the description is written to.</param>
            <param name="actualValue">The actual value to be written.</param>
            <param name="matcher">The matcher which is used for the expected value to be written.</param>
        </member>
        <member name="T:Castle.DynamicProxy.ProxyGenerator">
            <summary>
            Provides proxy objects for classes and interfaces.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(Castle.DynamicProxy.IProxyBuilder)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator"/> class.
            </summary>
            <param name="builder">Proxy types builder.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator"/> class.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface"/> on <paramref name="target"/> object with given <paramref name="interceptors"/>.
            </summary>
            <typeparam name="TInterface">Type of the interface implemented by <paramref name="target"/> which will be proxied.</typeparam>
            <param name="target">The target object, calls to which will be intercepted.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>Object proxying calls to members of <typeparamref name="TInterface"/> on <paramref name="target"/> object.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface"/>is not an interface type.</exception>
            <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target"/> object.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target"/> throws an exception.</exception>
            <remarks>
            This method generates new proxy type for each type of <paramref name="target"/>, which affects performance. If you don't want to proxy types differently depending on the type of the target
            use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.Core.Interceptor.IInterceptor[])"/> method.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface"/> on <paramref name="target"/> object with given <paramref name="interceptors"/>.
            </summary>
            <typeparam name="TInterface">Type of the interface implemented by <paramref name="target"/> which will be proxied.</typeparam>
            <param name="target">The target object, calls to which will be intercepted.</param>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <typeparamref name="TInterface"/> on <paramref name="target"/> object.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface"/>is not an interface type.</exception>
            <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target"/> object.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target"/> throws an exception.</exception>
            <remarks>
            This method generates new proxy type for each type of <paramref name="target"/>, which affects performance. If you don't want to proxy types differently depending on the type of the target
            use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])"/> method.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy"/> on <paramref name="target"/> object with given <paramref name="interceptors"/>.
            </summary>
            <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target"/> which will be proxied.</param>
            <param name="target">The target object, calls to which will be intercepted.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy"/> type on <paramref name="target"/> object.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is not an interface type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target"/> does not implement <paramref name="interfaceToProxy"/> interface.</exception>
            <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target"/> object.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target"/> throws an exception.</exception>
            <remarks>
            This method generates new proxy type for each type of <paramref name="target"/>, which affects performance. If you don't want to proxy types differently depending on the type of the target
            use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.Core.Interceptor.IInterceptor[])"/> method.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy"/> on <paramref name="target"/> object with given <paramref name="interceptors"/>.
            </summary>
            <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target"/> which will be proxied.</param>
            <param name="target">The target object, calls to which will be intercepted.</param>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy"/> type on <paramref name="target"/> object.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is not an interface type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target"/> does not implement <paramref name="interfaceToProxy"/> interface.</exception>
            <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target"/> object.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target"/> throws an exception.</exception>
            <remarks>
            This method generates new proxy type for each type of <paramref name="target"/>, which affects performance. If you don't want to proxy types differently depending on the type of the target
            use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])"/> method.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy"/> on <paramref name="target"/> object with given <paramref name="interceptors"/>.
            </summary>
            <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target"/> which will be proxied.</param>
            <param name="target">The target object, calls to which will be intercepted.</param>
            <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy"/> and <paramref name="additionalInterfacesToProxy"/> types  on <paramref name="target"/> object.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is not an interface type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target"/> does not implement <paramref name="interfaceToProxy"/> interface.</exception>
            <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target"/> object.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target"/> throws an exception.</exception>
            <remarks>
            This method generates new proxy type for each type of <paramref name="target"/>, which affects performance. If you don't want to proxy types differently depending on the type of the target
            use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.Core.Interceptor.IInterceptor[])"/> method.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy"/> on <paramref name="target"/> object with given <paramref name="interceptors"/>.
            </summary>
            <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target"/> which will be proxied.</param>
            <param name="target">The target object, calls to which will be intercepted.</param>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy"/> and <paramref name="additionalInterfacesToProxy"/> types on <paramref name="target"/> object.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is not an interface type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target"/> does not implement <paramref name="interfaceToProxy"/> interface.</exception>
            <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target"/> object.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target"/> throws an exception.</exception>
            <remarks>
            This method generates new proxy type for each type of <paramref name="target"/>, which affects performance. If you don't want to proxy types differently depending on the type of the target
            use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])"/> method.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy"/> on <paramref name="target"/> object with given <paramref name="interceptors"/>.
            Interceptors can use <see cref="T:Castle.Core.Interceptor.IChangeProxyTarget"/> interface to provide other target for method invocation than default <paramref name="target"/>.
            </summary>
            <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target"/> which will be proxied.</param>
            <param name="target">The target object, calls to which will be intercepted.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy"/> type on <paramref name="target"/> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is not an interface type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target"/> does not implement <paramref name="interfaceToProxy"/> interface.</exception>
            <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target"/> object.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface"/> on <paramref name="target"/> object with given <paramref name="interceptors"/>.
            Interceptors can use <see cref="T:Castle.Core.Interceptor.IChangeProxyTarget"/> interface to provide other target for method invocation than default <paramref name="target"/>.
            </summary>
            <typeparam name="TInterface">Type of the interface implemented by <paramref name="target"/> which will be proxied.</typeparam>
            <param name="target">The target object, calls to which will be intercepted.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <typeparamref name="TInterface"/> type on <paramref name="target"/> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface"/> is not an interface type.</exception>
            <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target"/> object.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface"/> on <paramref name="target"/> object with given <paramref name="interceptors"/>.
            Interceptors can use <see cref="T:Castle.Core.Interceptor.IChangeProxyTarget"/> interface to provide other target for method invocation than default <paramref name="target"/>.
            </summary>
            <typeparam name="TInterface">Type of the interface implemented by <paramref name="target"/> which will be proxied.</typeparam>
            <param name="target">The target object, calls to which will be intercepted.</param>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <typeparamref name="TInterface"/> type on <paramref name="target"/> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface"/> is not an interface type.</exception>
            <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target"/> object.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy"/> on <paramref name="target"/> object with given <paramref name="interceptors"/>.
            Interceptors can use <see cref="T:Castle.Core.Interceptor.IChangeProxyTarget"/> interface to provide other target for method invocation than default <paramref name="target"/>.
            </summary>
            <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target"/> which will be proxied.</param>
            <param name="target">The target object, calls to which will be intercepted.</param>
            <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy"/> and <paramref name="additionalInterfacesToProxy"/> types on <paramref name="target"/> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is not an interface type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target"/> does not implement <paramref name="interfaceToProxy"/> interface.</exception>
            <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target"/> object.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy"/> on <paramref name="target"/> object with given <paramref name="interceptors"/>.
            Interceptors can use <see cref="T:Castle.Core.Interceptor.IChangeProxyTarget"/> interface to provide other target for method invocation than default <paramref name="target"/>.
            </summary>
            <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target"/> which will be proxied.</param>
            <param name="target">The target object, calls to which will be intercepted.</param>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy"/> type on <paramref name="target"/> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is not an interface type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target"/> does not implement <paramref name="interfaceToProxy"/> interface.</exception>
            <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target"/> object.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy"/> on <paramref name="target"/> object with given <paramref name="interceptors"/>.
            Interceptors can use <see cref="T:Castle.Core.Interceptor.IChangeProxyTarget"/> interface to provide other target for method invocation than default <paramref name="target"/>.
            </summary>
            <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target"/> which will be proxied.</param>
            <param name="target">The target object, calls to which will be intercepted.</param>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy"/> and <paramref name="additionalInterfacesToProxy"/> types on <paramref name="target"/> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is not an interface type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target"/> does not implement <paramref name="interfaceToProxy"/> interface.</exception>
            <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target"/> object.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.Core.Interceptor.IInterceptor)">
            <summary>
            Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface"/> on target object generated at runtime with given <paramref name="interceptor"/>.
            </summary>
            <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
            <param name="interceptor">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <typeparamref name="TInterface"/> types on generated target object.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptor"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface"/> is not an interface type.</exception>
            <remarks>
            Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.Core.Interceptor.IInterceptor"/> implementations.
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed"/>, since there's no actual implementation to proceed with.
            As a result of that also at least one <see cref="T:Castle.Core.Interceptor.IInterceptor"/> implementation must be provided.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface"/> on target object generated at runtime with given <paramref name="interceptors"/>.
            </summary>
            <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <typeparamref name="TInterface"/> types on generated target object.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface"/> is not an interface type.</exception>
            <remarks>
            Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.Core.Interceptor.IInterceptor"/> implementations.
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed"/>, since there's no actual implementation to proceed with.
            As a result of that also at least one <see cref="T:Castle.Core.Interceptor.IInterceptor"/> implementation must be provided.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface"/> on target object generated at runtime with given <paramref name="interceptors"/>.
            </summary>
            <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <typeparamref name="TInterface"/> types on generated target object.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface"/> is not an interface type.</exception>
            <remarks>
            Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.Core.Interceptor.IInterceptor"/> implementations.
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed"/>, since there's no actual implementation to proceed with.
            As a result of that also at least one <see cref="T:Castle.Core.Interceptor.IInterceptor"/> implementation must be provided.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.Core.Interceptor.IInterceptor)">
            <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy"/> on target object generated at runtime with given <paramref name="interceptor"/>.
            </summary>
            <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name="interceptor">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy"/> type on generated target object.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptor"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is not an interface type.</exception>
            <remarks>
            Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.Core.Interceptor.IInterceptor"/> implementations.
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed"/>, since there's no actual implementation to proceed with.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy"/> on target object generated at runtime with given <paramref name="interceptors"/>.
            </summary>
            <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy"/> type on generated target object.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is not an interface type.</exception>
            <remarks>
            Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.Core.Interceptor.IInterceptor"/> implementations.
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed"/>, since there's no actual implementation to proceed with.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy"/> on target object generated at runtime with given <paramref name="interceptors"/>.
            </summary>
            <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy"/> and <paramref name="additionalInterfacesToProxy"/> types on generated target object.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is not an interface type.</exception>
            <remarks>
            Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.Core.Interceptor.IInterceptor"/> implementations.
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed"/>, since there's no actual implementation to proceed with.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy"/> on target object generated at runtime with given <paramref name="interceptors"/>.
            </summary>
            <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy"/> on generated target object.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/>  is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is not an interface type.</exception>
            <remarks>
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed"/>, since there's no actual implementation to proceed with.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy"/> on target object generated at runtime with given <paramref name="interceptors"/>.
            </summary>
            <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy"/> and <paramref name="additionalInterfacesToProxy"/> types on generated target object.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors"/> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy"/> is not an interface type.</exception>
            <remarks>
            Since this method uses an empty-shell implementation of <paramref name="additionalInterfacesToProxy"/> to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.Core.Interceptor.IInterceptor"/> implementations.
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed"/>, since there's no actual implementation to proceed with.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass"/> on newly created instance of that type with given <paramref name="interceptors"/>.
            </summary>
            <typeparam name="TClass">Type of class which will be proxied.</typeparam>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            New object of type <typeparamref name="TClass"/> proxying calls to virtual members of <typeparamref name="TClass"/> type.
            </returns>
            <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass"/> is not a class type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass"/>.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass"/> on newly created instance of that type with given <paramref name="interceptors"/>.
            </summary>
            <typeparam name="TClass">Type of class which will be proxied.</typeparam>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            New object of type <typeparamref name="TClass"/> proxying calls to virtual members of <typeparamref name="TClass"/> type.
            </returns>
            <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass"/> is not a class type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass"/>.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy"/> on newly created instance of that type with given <paramref name="interceptors"/>.
            </summary>
            <param name="classToProxy">Type of class which will be proxied.</param>
            <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            New object of type <paramref name="classToProxy"/> proxying calls to virtual members of <paramref name="classToProxy"/> and <paramref name="additionalInterfacesToProxy"/> types.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> is not a class type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy"/>.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.Core.Interceptor.IInterceptor[],System.Object[])">
            <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy"/> on newly created instance of that type with given <paramref name="interceptors"/>.
            </summary>
            <param name="classToProxy">Type of class which will be proxied.</param>
            <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy"/> which should be used to create a new instance of that type.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            New object of type <paramref name="classToProxy"/> proxying calls to virtual members of <paramref name="classToProxy"/> type.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> is not a class type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy"/> with parameters matching <paramref name="constructorArguments"/>.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy"/> on newly created instance of that type with given <paramref name="interceptors"/>.
            </summary>
            <param name="classToProxy">Type of class which will be proxied.</param>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy"/> which should be used to create a new instance of that type.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            New object of type <paramref name="classToProxy"/> proxying calls to virtual members of <paramref name="classToProxy"/> type.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> is not a class type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy"/> with parameters matching <paramref name="constructorArguments"/>.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Object[],Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy"/> on newly created instance of that type with given <paramref name="interceptors"/>.
            </summary>
            <param name="classToProxy">Type of class which will be proxied.</param>
            <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy"/> which should be used to create a new instance of that type.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            New object of type <paramref name="classToProxy"/> proxying calls to virtual members of <paramref name="classToProxy"/> type.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> is not a class type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy"/> with parameters matching <paramref name="constructorArguments"/>.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy"/> on newly created instance of that type with given <paramref name="interceptors"/>.
            </summary>
            <param name="classToProxy">Type of class which will be proxied.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            New object of type <paramref name="classToProxy"/> proxying calls to virtual members of <paramref name="classToProxy"/> type.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> is not a class type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when no parameterless constructor exists on type <paramref name="classToProxy"/>.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy"/> on newly created instance of that type with given <paramref name="interceptors"/>.
            </summary>
            <param name="classToProxy">Type of class which will be proxied.</param>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            New object of type <paramref name="classToProxy"/> proxying calls to virtual members of <paramref name="classToProxy"/> type.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> is not a class type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy"/>.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy"/> on newly created instance of that type with given <paramref name="interceptors"/>.
            </summary>
            <param name="classToProxy">Type of class which will be proxied.</param>
            <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            New object of type <paramref name="classToProxy"/> proxying calls to virtual members of <paramref name="classToProxy"/> and <paramref name="additionalInterfacesToProxy"/> types.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> is not a class type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy"/>.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.Core.Interceptor.IInterceptor[])">
            <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy"/> on newly created instance of that type with given <paramref name="interceptors"/>.
            </summary>
            <param name="classToProxy">Type of class which will be proxied.</param>
            <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy"/> which should be used to create a new instance of that type.</param>
            <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
            New object of type <paramref name="classToProxy"/> proxying calls to virtual members of <paramref name="classToProxy"/> and <paramref name="additionalInterfacesToProxy"/> types.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options"/> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> or any of <paramref name="additionalInterfacesToProxy"/> is a generic type definition.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy"/> is not a class type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy"/> with parameters matching <paramref name="constructorArguments"/>.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy"/> throws an exception.</exception>
            <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
            Creates the proxy type for class proxy with given <paramref name="classToProxy"/> class, implementing given <paramref name="additionalInterfacesToProxy"/> and using provided <paramref name="options"/>.
            </summary>
            <param name="classToProxy">The base class for proxy type.</param>
            <param name="additionalInterfacesToProxy">The interfaces that proxy type should implement.</param>
            <param name="options">The options for proxy generation process.</param>
            <returns><see cref="T:System.Type"/> of proxy.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
            Creates the proxy type for interface proxy with target for given <paramref name="interfaceToProxy"/> interface, implementing given <paramref name="additionalInterfacesToProxy"/> on given <paramref name="targetType"/> and using provided <paramref name="options"/>.
            </summary>
            <param name="interfaceToProxy">The interface proxy type should implement.</param>
            <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
            <param name="targetType">Actual type that the proxy type will encompass.</param>
            <param name="options">The options for proxy generation process.</param>
            <returns><see cref="T:System.Type"/> of proxy.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
            Creates the proxy type for interface proxy with target interface for given <paramref name="interfaceToProxy"/> interface, implementing given <paramref name="additionalInterfacesToProxy"/> on given <paramref name="targetType"/> and using provided <paramref name="options"/>.
            </summary>
            <param name="interfaceToProxy">The interface proxy type should implement.</param>
            <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
            <param name="options">The options for proxy generation process.</param>
            <returns><see cref="T:System.Type"/> of proxy.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
            Creates the proxy type for interface proxy without target for given <paramref name="interfaceToProxy"/> interface, implementing given <paramref name="additionalInterfacesToProxy"/> and using provided <paramref name="options"/>.
            </summary>
            <param name="interfaceToProxy">The interface proxy type should implement.</param>
            <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
            <param name="options">The options for proxy generation process.</param>
            <returns><see cref="T:System.Type"/> of proxy.</returns>
        </member>
        <member name="P:Castle.DynamicProxy.ProxyGenerator.Logger">
            <summary>
            Gets or sets the <see cref="T:Castle.Core.Logging.ILogger"/> that this <see cref="T:Castle.DynamicProxy.ProxyGenerator"/> log to.
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.ProxyGenerator.ProxyBuilder">
            <summary>
            Gets the proxy builder instance used to generate proxy types.
            </summary>
            <value>The proxy builder.</value>
        </member>
        <member name="T:Castle.DynamicProxy.PersistentProxyBuilder">
            <summary>
            ProxyBuilder that persists the generated type.
            </summary>
            <remarks>
            The saved assembly contains just the last generated type.
            </remarks>
        </member>
        <member name="T:Castle.DynamicProxy.DefaultProxyBuilder">
            <summary>
            Default implementation of <see cref="T:Castle.DynamicProxy.IProxyBuilder"/> interface producing in-memory proxy assemblies.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.DefaultProxyBuilder"/> class with new <see cref="T:Castle.DynamicProxy.ModuleScope"/>.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor(Castle.DynamicProxy.ModuleScope)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.DefaultProxyBuilder"/> class.
            </summary>
            <param name="scope">The module scope for generated proxy types.</param>
        </member>
        <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.PersistentProxyBuilder"/> class.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.SaveAssembly">
            <summary>
            Saves the generated assembly to a physical file. Note that this renders the <see cref="T:Castle.DynamicProxy.PersistentProxyBuilder"/> unusable.
            </summary>
            <returns>The path of the generated assembly file, or null if no assembly has been generated.</returns>
            <remarks>This method does not support saving multiple files. If both a signed and an unsigned module have been generated, use the 
            respective methods of the <see cref="T:Castle.DynamicProxy.ModuleScope"/>.</remarks>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.LdindOpCodesDictionary">
            <summary>
            Provides appropriate Ldind.X opcode for 
            the type of primitive value to be loaded indirectly.
            </summary>
        </member>
        <member name="T:Castle.Core.Resource.StaticContentResource">
            <summary>
            Adapts a static string content as an <see cref="T:Castle.Core.Resource.IResource"/>
            </summary>
        </member>
        <member name="T:Castle.Core.MethodMetaModelCollection">
            <summary>
            Collection of <see cref="T:Castle.Core.MethodMetaModel"/>
            </summary>
        </member>
        <member name="P:Castle.Core.MethodMetaModelCollection.MethodInfo2Model">
            <summary>
            Gets the method info2 model.
            </summary>
            <value>The method info2 model.</value>
        </member>
        <member name="T:Castle.Core.Configuration.Xml.XmlConfigurationDeserializer">
            <summary>
            Pendent
            </summary>
        </member>
        <member name="M:Castle.Core.Configuration.Xml.XmlConfigurationDeserializer.Deserialize(System.Xml.XmlNode)">
            <summary>
            Deserializes the specified node into an abstract representation of configuration.
            </summary>
            <param name="node">The node.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Configuration.Xml.XmlConfigurationDeserializer.GetConfigValue(System.String)">
            <summary>
            If a config value is an empty string we return null, this is to keep
            backward compability with old code
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.IExtendedLoggerFactory">
            <summary>
            Provides a factory that can produce either <see cref="T:Castle.Core.Logging.ILogger"/> or
            <see cref="T:Castle.Core.Logging.IExtendedLogger"/> classes.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type)">
            <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String)">
            <summary>
            Creates a new extended logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
            <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
            Creates a new extended logger.
            </summary>
        </member>
        <member name="T:NMock2.Matchers.ArgumentsMatcher">
            <summary>
            Matcher that checks whether parameters of a method match with the specified list of matchers.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.ArgumentsMatcher.OutParameter">
            <summary>
            Stores the out parameter.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.ArgumentsMatcher.valueMatchers">
            <summary>
            Stores the valuematchers given at initialization.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.ArgumentsMatcher.#ctor(NMock2.Matcher[])">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.ArgumentsMatcher"/> class.
            </summary>
            <param name="valueMatchers">The value matchers. This is an ordered list of matchers, each matching a single method argument.</param>
        </member>
        <member name="M:NMock2.Matchers.ArgumentsMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object is an <see cref="T:NMock2.Monitoring.Invocation"/> and all method arguments match their corresponding matcher.</returns>
        </member>
        <member name="M:NMock2.Matchers.ArgumentsMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="M:NMock2.Matchers.ArgumentsMatcher.MatcherCount">
            <summary>
            Number of argument matchers.
            </summary>
            <returns>Returns the number of argument matchers.</returns>
        </member>
        <member name="M:NMock2.Matchers.ArgumentsMatcher.LastMatcher">
            <summary>
            Returns the last argument matcher.
            </summary>
            <returns>Argument matcher</returns>
        </member>
        <member name="M:NMock2.Matchers.ArgumentsMatcher.WriteListOfMatchers(System.Int32,System.IO.TextWriter)">
            <summary>
            Writes the list of matchers to a <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="listLength">Length of the list.</param>
            <param name="writer">The writer.</param>
        </member>
        <member name="T:NMock2.Matchers.ArgumentsMatcher.OutMatcher">
            <summary>
            Matcher that matches method out parameters. 
            </summary>
        </member>
        <member name="M:NMock2.Matchers.ArgumentsMatcher.OutMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object mached is an out parameter.</returns>
        </member>
        <member name="M:NMock2.Matchers.ArgumentsMatcher.OutMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Internal.ExpectationException">
            <summary>
            Exception representing an expectation exception.
            </summary>
        </member>
        <member name="M:NMock2.Internal.ExpectationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.ExpectationException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:NMock2.Internal.ExpectationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.ExpectationException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:NMock2.Internal.ExpectationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.ExpectationException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="info"/> parameter is null.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0).
            </exception>
        </member>
        <member name="T:NMock2.Internal.CompositeType">
            <summary>
            Represents one or more types that are to be mocked. Provides operations
            that work over top of all the contained types, as well as a means of
            grouping and identifying unique combinations of types.
            </summary>
            <remarks>Duplicate types are ignored when added. Only interface and class types are
            supported, and there may only be a maximum of one class type per CompositeType instance.</remarks>
        </member>
        <member name="M:NMock2.Internal.CompositeType.#ctor(System.Type[])">
            <summary>
            Initializes a new instance of the CompositeType class from the supplied types.
            </summary>
            <param name="types">The types to include in the CompositeType.</param>
        </member>
        <member name="M:NMock2.Internal.CompositeType.#ctor(System.Type,System.Type[])">
            <summary>
            Initializes a new instance of the CompositeType class from the supplied types.
            </summary>
            <param name="type">The first type to include in the CompositeType. This cannot be null.</param>
            <param name="additionalTypes">Zero or more further types to include in the CompositeType.</param>
            <remarks>This constructor is mostly included for convenience.</remarks>
        </member>
        <member name="M:NMock2.Internal.CompositeType.GetMatchingMethods(NMock2.Matcher,System.Boolean)">
            <summary>
            Gets any methods of the contained type(s) that match the specified matcher.
            </summary>
            <param name="matcher">The matcher.</param>
            <param name="firstMatchOnly">if set to <c>true</c> then only the first match is returned.</param>
            <returns>The methods of the contained type(s) that match the specified matcher.</returns>
            <remarks>Only non-private methods can be matched.</remarks>
        </member>
        <member name="M:NMock2.Internal.CompositeType.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>An Int32 containing the hash code for this instance.</returns>
        </member>
        <member name="M:NMock2.Internal.CompositeType.Equals(System.Object)">
            <summary>
            Determines whether the specified Object is equal to the current CompositeType.
            </summary>
            <param name="obj">The Object to compare with the current CompositeType.</param>
            <returns>true if the specified Object is equal to the current CompositeType; otherwise, false.</returns>
        </member>
        <member name="M:NMock2.Internal.CompositeType.ToString">
            <summary>
            Returns a String that represents the current CompositeType.
            </summary>
            <returns>A String that represents the current CompositeType.</returns>
        </member>
        <member name="M:NMock2.Internal.CompositeType.Equals(NMock2.Internal.CompositeType)">
            <summary>
            Determines whether the specified CompositeType is equal to the current CompositeType.
            </summary>
            <param name="other">The CompositeType to compare with the current CompositeType.</param>
            <returns>true if the specified CompositeType is equal to the current CompositeType; otherwise, false.</returns>
        </member>
        <member name="M:NMock2.Internal.CompositeType.Initialize(System.Type[])">
            <summary>
            Initializes the specified types.
            </summary>
            <param name="types">The types.</param>
        </member>
        <member name="M:NMock2.Internal.CompositeType.GetInterfacesImplementedByType(System.Type)">
            <summary>
            Gets the interfaces implemented by the specified type.
            </summary>
            <param name="type">The interface type to inspect.</param>
            <returns>The interfaces implemented by the specified type.</returns>
        </member>
        <member name="M:NMock2.Internal.CompositeType.IsMethodVisible(System.Reflection.MethodInfo)">
            <summary>
            Filters out private methods.
            </summary>
            <param name="methodInfo">The method to test for visibility.</param>
            <returns>True if the method is not private, otherwise false.</returns>
        </member>
        <member name="P:NMock2.Internal.CompositeType.PrimaryType">
            <summary>
            Gets the 'primary' type we are mocking. This may be a class or an interface
            and will determine the proxy generation method that will be used.
            </summary>
        </member>
        <member name="P:NMock2.Internal.CompositeType.AdditionalInterfaceTypes">
            <summary>
            Gets any additional types to be mocked. These will always be interfaces.
            </summary>
        </member>
        <member name="T:NMock2.Internal.StubMockStyleDictionary">
            <summary>
            Provides functionality to map stubs and specific types of a stub to mock styles.
            </summary>
        </member>
        <member name="F:NMock2.Internal.StubMockStyleDictionary.mockStyleForType">
            <summary>
            holds mappings from stub.type to mock style.
            </summary>
        </member>
        <member name="F:NMock2.Internal.StubMockStyleDictionary.mockStyleForStub">
            <summary>
            holds mappings from stub to mock style (holds for all types unless there is a mapping defined in <see cref="F:NMock2.Internal.StubMockStyleDictionary.mockStyleForType"/>.
            </summary>
        </member>
        <member name="P:NMock2.Internal.StubMockStyleDictionary.Item(NMock2.Internal.IMockObject)">
            <summary>
            Gets or sets the mock style for the specified mock.
            </summary>
            <param name="mock">the mock object</param>
            <value>mock style. null if no value defined.</value>
        </member>
        <member name="P:NMock2.Internal.StubMockStyleDictionary.Item(NMock2.Internal.IMockObject,System.Type)">
            <summary>
            Gets or sets the mock style for the specified mock and type.
            </summary>
            <param name="mock">the mock object</param>
            <param name="nestedMockType">the type of the nested mock.</param>
            <value>mock style. null if no value defined.</value>
        </member>
        <member name="T:NMock2.Internal.StubMockStyleDictionary.Key">
            <summary>
            Key into the <see cref="F:NMock2.Internal.StubMockStyleDictionary.mockStyleForType"/> dictionary.
            </summary>
        </member>
        <member name="M:NMock2.Internal.StubMockStyleDictionary.Key.#ctor(NMock2.Internal.IMockObject,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.StubMockStyleDictionary.Key"/> class.
            </summary>
            <param name="mock">The mock object.</param>
            <param name="nestedMockType">Type of the nested mock.</param>
        </member>
        <member name="M:NMock2.Internal.StubMockStyleDictionary.Key.Equals(System.Object)">
            <summary>
            Whether this instance equals the specified other.
            </summary>
            <param name="other">The other to compare to.</param>
            <returns>A value indicating whether both instances are equal.</returns>
        </member>
        <member name="M:NMock2.Internal.StubMockStyleDictionary.Key.Equals(NMock2.Internal.StubMockStyleDictionary.Key)">
            <summary>
            Whether this instance equals the specified other.
            </summary>
            <param name="other">The other to compare to.</param>
            <returns>A value indicating whether both instances are equal.</returns>
        </member>
        <member name="M:NMock2.Internal.StubMockStyleDictionary.Key.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:NMock2.Internal.StubMockStyleDictionary.Key.Mock">
            <summary>
            Gets the mock.
            </summary>
            <value>The mock object.</value>
        </member>
        <member name="P:NMock2.Internal.StubMockStyleDictionary.Key.NestedMockType">
            <summary>
            Gets the type of the nested mock.
            </summary>
            <value>The type of the nested mock.</value>
        </member>
        <member name="M:Castle.DynamicProxy.RemotableInvocation.Proceed">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Castle.DynamicProxy.RemotableInvocation.Method">
            <summary>
            
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.RemotableInvocation.MethodInvocationTarget">
            <summary>
            For interface proxies, this will point to the
            <see cref="T:System.Reflection.MethodInfo"/> on the target class
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.TypeUtil.GetAllInterfaces(System.Type[])">
            <summary>
            Returns list of all unique interfaces implemented given types, including their base interfaces.
            </summary>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Reflection.MemberInfo,System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.CacheKey"/> class.
            </summary>
            <param name="target">Target element. This is either target type or target method for invocation types.</param>
            <param name="type">The type of the proxy. This is base type for invocation types.</param>
            <param name="interfaces">The interfaces.</param>
            <param name="options">The options.</param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.CacheKey"/> class.
            </summary>
            <param name="target">Type of the target.</param>
            <param name="interfaces">The interfaces.</param>
            <param name="options">The options.</param>
        </member>
        <member name="T:Castle.Core.PropertySet">
            <summary>
            Represents a property and the respective dependency.
            </summary>
        </member>
        <member name="M:Castle.Core.PropertySet.#ctor(System.Reflection.PropertyInfo,Castle.Core.DependencyModel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PropertySet"/> class.
            </summary>
            <param name="propertyInfo">The property info.</param>
            <param name="dependency">The dependency.</param>
        </member>
        <member name="P:Castle.Core.PropertySet.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.Core.PropertySet.Dependency">
            <summary>
            Gets the dependency.
            </summary>
            <value>The dependency.</value>
        </member>
        <member name="T:NMock2.Actions.ReturnCloneAction">
            <summary>
            Action that set the result value of an invocation to a clone of the specified prototype.
            </summary>
        </member>
        <member name="F:NMock2.Actions.ReturnCloneAction.prototype">
            <summary>
            Stores the prototype that will be cloned.
            </summary>
        </member>
        <member name="M:NMock2.Actions.ReturnCloneAction.#ctor(System.ICloneable)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Actions.ReturnCloneAction"/> class.
            </summary>
            <param name="prototype">The prototype.</param>
        </member>
        <member name="M:NMock2.Actions.ReturnCloneAction.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Invokes this object. Sets the result value of the invocation to a clone of the prototype.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.Actions.ReturnCloneAction.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Monitoring.Invoker">
            <summary>
            An invoker invokes an <see cref="T:NMock2.Monitoring.Invocation"/> on a target if
            it is responsible for the target type, otherwise the invocation is passed
            to the next invoker in the 'next' chain.
            </summary>
        </member>
        <member name="F:NMock2.Monitoring.Invoker.targetType">
            <summary>
            Holds the type of the target. Can not be inferred from target because it could be a base type.
            </summary>
        </member>
        <member name="F:NMock2.Monitoring.Invoker.target">
            <summary>
            Holds the target.
            </summary>
        </member>
        <member name="F:NMock2.Monitoring.Invoker.next">
            <summary>
            Holds the next <see cref="T:NMock2.Monitoring.IInvokable"/> to pass the invocation to, 
            if this instance is not responsible for the target type on an invocation.
            </summary>
        </member>
        <member name="M:NMock2.Monitoring.Invoker.#ctor(System.Type,System.Object,NMock2.Monitoring.IInvokable)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Monitoring.Invoker"/> class.
            </summary>
            <param name="targetType">Type of the target. Can not be inferred from <paramref name="target"/> 
            because it could be a base type.</param>
            <param name="target">The target.</param>
            <param name="next">The next <see cref="T:NMock2.Monitoring.IInvokable"/> to pass the invocation to, 
            if this instance is not responsible for the target type on an invocation.</param>
        </member>
        <member name="M:NMock2.Monitoring.Invoker.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Executes the <paramref name="invocation"/> on the target of this instance
            if the targetType of this instance matches the invocation, otherwise the invocation
            is passed to the next <see cref="T:NMock2.Monitoring.IInvokable"/> specified in the constructor.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="T:NMock2.Matchers.IndexGetterArgumentsMatcher">
            <summary>
            Matcher for indexer getters. Checks that the arguments passed to the indexer match.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.IndexGetterArgumentsMatcher.#ctor(NMock2.Matcher[])">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.IndexGetterArgumentsMatcher"/> class.
            </summary>
            <param name="valueMatchers">The value matchers. This is an ordered list of matchers, each matching a single method argument.</param>
        </member>
        <member name="M:NMock2.Matchers.IndexGetterArgumentsMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Matchers.EqualMatcher">
            <summary>
            Matcher that checks whether the expected and actual value are equal.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.EqualMatcher.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.EqualMatcher"/> class.
            </summary>
            <param name="expected">The expected value.</param>
        </member>
        <member name="M:NMock2.Matchers.EqualMatcher.Matches(System.Object)">
            <summary>
            Matcheses the specified actual.
            </summary>
            <param name="actual">The actual value.</param>
            <returns>Whether the expected value is equal to the actual value.</returns>
        </member>
        <member name="M:NMock2.Matchers.EqualMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Internal.DescriptionWriter">
            <summary>
            Used to describe Matchers and other classes for exception handling.
            </summary>
        </member>
        <member name="M:NMock2.Internal.DescriptionWriter.Write(System.Object)">
            <summary>
            Writes the text representation of an object to the text stream by calling ToString on that object.
            </summary>
            <param name="value">The object to write.</param>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.IO.TextWriter"/> is closed.
            </exception>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
        </member>
        <member name="M:NMock2.Internal.DescriptionWriter.FormatValue(System.Object)">
            <summary>
            Formats the given <paramref name="value"/> depending on null and the type of the value.
            </summary>
            <param name="value">The value to format.</param>
            <returns>Returns the formatted string.</returns>
        </member>
        <member name="M:NMock2.Internal.DescriptionWriter.FormatString(System.String)">
            <summary>
            Replaces backslashes with three escaped backslashes.
            </summary>
            <param name="s">The string to replace backslashes.</param>
            <returns>Returns the escaped string.</returns>
        </member>
        <member name="T:NMock2.Internal.MockBuilder">
            <summary>
            Allows a mock object to be incrementally defined, and then finally created.
            </summary>
        </member>
        <member name="F:NMock2.Internal.MockBuilder.EmptyArgsArray">
            <summary>
            A single empty array instance that is used as a default value
            for constructor arguments.
            </summary>
        </member>
        <member name="F:NMock2.Internal.MockBuilder.name">
            <summary>
            The name of the mock object. Null is a valid value.
            </summary>
        </member>
        <member name="F:NMock2.Internal.MockBuilder.types">
            <summary>
            The types that the mock object needs to implement.
            </summary>
        </member>
        <member name="F:NMock2.Internal.MockBuilder.constructorArgs">
            <summary>
            Constructor arguments for any class type that this mock might subclass.
            If not subclassing, or if using a default constructor, then this should
            be an empty array.
            </summary>
        </member>
        <member name="F:NMock2.Internal.MockBuilder.mockStyle">
            <summary>
            The MockStyle for the mock. If not specified, this will ultimately be
            assumed to be MockStyle.Default.
            </summary>
        </member>
        <member name="M:NMock2.Internal.MockBuilder.Implementing``1">
            <summary>
            Specifies a type that this mock should implement. This may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
            <typeparam name="T">The type to implement.</typeparam>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:NMock2.Internal.MockBuilder.Implementing(System.Type[])">
            <summary>
            Specifies the types that this mock should implement. These may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
            <param name="types">The types to implement.</param>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:NMock2.Internal.MockBuilder.OfStyle(NMock2.MockStyle)">
            <summary>
            Specifies how the mock object should behave when first created.
            It is invalid to set the MockStyle of a mock more than once.
            </summary>
            <param name="style">A MockStyle value.</param>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:NMock2.Internal.MockBuilder.WithArgs(System.Object[])">
            <summary>
            Specifies the arguments for the constructor of the class to be mocked.
            Only applicable when mocking a class with a non-default constructor.
            It is invalid to specify the constructor arguments of a mock more than once.
            </summary>
            <param name="args">The arguments for the class constructor.</param>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:NMock2.Internal.MockBuilder.Named(System.String)">
            <summary>
            Specifies a name for the mock. This will be used in error messages,
            and as the return value of ToString() if not mocking a class.
            It is invalid to specify the name of a mock more than once.
            </summary>
            <param name="name">The name for the mock.</param>
            <returns>The mock object definition.</returns>
        </member>
        <member name="M:NMock2.Internal.MockBuilder.Create(System.Type,NMock2.Mockery,NMock2.Monitoring.IMockObjectFactory)">
            <summary>
            This method supports NMock2 infrastructure and is not intended to be called directly from your code.
            </summary>
            <param name="primaryType">The primary type that is being mocked.</param>
            <param name="mockery">The current <see cref="T:NMock2.Mockery"/> instance.</param>
            <param name="mockObjectFactory">An <see cref="T:NMock2.Monitoring.IMockObjectFactory"/> to use when creating the mock.</param>
            <returns>A new mock instance.</returns>
        </member>
        <member name="M:NMock2.Internal.MockBuilder.DefaultNameFor(System.Type)">
            <summary>
            Returns the default name for a type that is used to name mocks.
            </summary>
            <param name="type">The type to get the default name for.</param>
            <returns>Default name for the specified type.</returns>
        </member>
        <member name="M:NMock2.Internal.MockBuilder.FirstLowerCaseChar(System.String)">
            <summary>
            Finds the first lower case char in the specified string.
            </summary>
            <param name="s">The string to inspect.</param>
            <returns>the first lower case char in the specified string.</returns>
        </member>
        <member name="M:NMock2.Internal.MockBuilder.CheckInterfacesDoNotContainToStringMethodDeclaration(NMock2.Internal.CompositeType)">
            <summary>
            Checks that interfaces do not contain ToString method declarations.
            </summary>
            <param name="mockedTypes">The types that are to be mocked.</param>
        </member>
        <member name="T:Castle.DynamicProxy.ModuleScope">
            <summary>
            Summary description for ModuleScope.
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME">
            <summary>
            The default file name used when the assembly is saved using <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME"/>.
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_ASSEMBLY_NAME">
            <summary>
            The default assembly (simple) name used for the assemblies generated by a <see cref="T:Castle.DynamicProxy.ModuleScope"/> instance.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope"/> class; assemblies created by this instance will not be saved.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope"/> class, allowing to specify whether the assemblies generated by this instance
            should be saved.
            </summary>
            <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.String,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope"/> class, allowing to specify whether the assemblies generated by this instance
            should be saved and what simple names are to be assigned to them.
            </summary>
            <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
            <param name="strongAssemblyName">The simple name of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope"/>.</param>
            <param name="strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope"/>.</param>
            <param name="weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope"/>.</param>
            <param name="weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope"/>.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,Castle.DynamicProxy.Generators.INamingScope,System.String,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope"/> class, allowing to specify whether the assemblies generated by this instance
            should be saved and what simple names are to be assigned to them.
            </summary>
            <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
            <param name="namingScope">Naming scope used to provide unique names to generated types and their members (usually via sub-scopes).</param>
            <param name="strongAssemblyName">The simple name of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope"/>.</param>
            <param name="strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope"/>.</param>
            <param name="weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope"/>.</param>
            <param name="weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope"/>.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.GetFromCache(Castle.DynamicProxy.Generators.CacheKey)">
            <summary>
            Returns a type from this scope's type cache, or null if the key cannot be found.
            </summary>
            <param name="key">The key to be looked up in the cache.</param>
            <returns>The type from this scope's type cache matching the key, or null if the key cannot be found</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.RegisterInCache(Castle.DynamicProxy.Generators.CacheKey,System.Type)">
            <summary>
            Registers a type in this scope's type cache.
            </summary>
            <param name="key">The key to be associated with the type.</param>
            <param name="type">The type to be stored in the cache.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.GetKeyPair">
            <summary>
            Gets the key pair used to sign the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModule(System.Boolean)">
            <summary>
            Gets the specified module generated by this scope, creating a new one if none has yet been generated.
            </summary>
            <param name="isStrongNamed">If set to true, a strong-named module is returned; otherwise, a weak-named module is returned.</param>
            <returns>A strong-named or weak-named module generated by this scope, as specified by the <paramref name="isStrongNamed"/> parameter.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithStrongName">
            <summary>
            Gets the strong-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
            <returns>A strong-named module generated by this scope.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithWeakName">
            <summary>
            Gets the weak-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
            <returns>A weak-named module generated by this scope.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly">
            <summary>
            Saves the generated assembly with the name and directory information given when this <see cref="T:Castle.DynamicProxy.ModuleScope"/> instance was created (or with
            the <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME"/> and current directory if none was given).
            </summary>
            <remarks>
            <para>
            This method stores the generated assembly in the directory passed as part of the module information specified when this instance was
            constructed (if any, else the current directory is used). If both a strong-named and a weak-named assembly
            have been generated, it will throw an exception; in this case, use the <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)"/> overload.
            </para>
            <para>
            If this <see cref="T:Castle.DynamicProxy.ModuleScope"/> was created without indicating that the assembly should be saved, this method does nothing.
            </para></remarks>
            <exception cref="T:System.InvalidOperationException">Both a strong-named and a weak-named assembly have been generated.</exception>
            <returns>The path of the generated assembly file, or null if no file has been generated.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)">
            <summary>
            Saves the specified generated assembly with the name and directory information given when this <see cref="T:Castle.DynamicProxy.ModuleScope"/> instance was created
            (or with the <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME"/> and current directory if none was given).
            </summary>
            <param name="strongNamed">True if the generated assembly with a strong name should be saved (see <see cref="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule"/>);
              false if the generated assembly without a strong name should be saved (see <see cref="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule"/>.</param>
            <remarks>
            <para>
            This method stores the specified generated assembly in the directory passed as part of the module information specified when this instance was
            constructed (if any, else the current directory is used).
            </para>
            <para>
            If this <see cref="T:Castle.DynamicProxy.ModuleScope"/> was created without indicating that the assembly should be saved, this method does nothing.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">No assembly has been generated that matches the <paramref name="strongNamed"/> parameter.
            </exception>
            <returns>The path of the generated assembly file, or null if no file has been generated.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.LoadAssemblyIntoCache(System.Reflection.Assembly)">
            <summary>
            Loads the generated types from the given assembly into this <see cref="T:Castle.DynamicProxy.ModuleScope"/>'s cache.
            </summary>
            <param name="assembly">The assembly to load types from. This assembly must have been saved via <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)"/> or
            <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly"/>, or it must have the <see cref="T:Castle.DynamicProxy.CacheMappingsAttribute"/> manually applied.</param>
            <remarks>
            This method can be used to load previously generated and persisted proxy types from disk into this scope's type cache, eg. in order
            to avoid the performance hit associated with proxy generation.
            </remarks>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.Lock">
            <summary>
            Users of this <see cref="T:Castle.DynamicProxy.ModuleScope"/> should use this lock when accessing the cache.
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule">
            <summary>
            Gets the strong-named module generated by this scope, or <see langword="null"/> if none has yet been generated.
            </summary>
            <value>The strong-named module generated by this scope, or <see langword="null"/> if none has yet been generated.</value>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleName">
            <summary>
            Gets the file name of the strongly named module generated by this scope.
            </summary>
            <value>The file name of the strongly named module generated by this scope.</value>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleDirectory">
            <summary>
            Gets the directory where the strongly named module generated by this scope will be saved, or <see langword="null"/> if the current directory
            is used.
            </summary>
            <value>The directory where the strongly named module generated by this scope will be saved when <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly"/> is called
            (if this scope was created to save modules).</value>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule">
            <summary>
            Gets the weak-named module generated by this scope, or <see langword="null"/> if none has yet been generated.
            </summary>
            <value>The weak-named module generated by this scope, or <see langword="null"/> if none has yet been generated.</value>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleName">
            <summary>
            Gets the file name of the weakly named module generated by this scope.
            </summary>
            <value>The file name of the weakly named module generated by this scope.</value>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleDirectory">
            <summary>
            Gets the directory where the weakly named module generated by this scope will be saved, or <see langword="null"/> if the current directory
            is used.
            </summary>
            <value>The directory where the weakly named module generated by this scope will be saved when <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly"/> is called
            (if this scope was created to save modules).</value>
        </member>
        <member name="T:Castle.Core.Configuration.ConfigurationCollection">
            <summary>
            A collection of <see cref="T:Castle.Core.Configuration.IConfiguration"/> objects.
            </summary>
        </member>
        <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor">
            <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
        </member>
        <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor(System.Collections.Generic.IEnumerable{Castle.Core.Configuration.IConfiguration})">
            <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.DiagnosticsLogger">
            <summary>
            The Logger using standart Diagnostics namespace.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String)">
            <summary>
            Creates a logger based on <see cref="T:System.Diagnostics.EventLog"/>.
            </summary>
            <param name="logName"><see cref="P:System.Diagnostics.EventLog.Log"/></param>
        </member>
        <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String)">
            <summary>
            Creates a logger based on <see cref="T:System.Diagnostics.EventLog"/>.
            </summary>
            <param name="logName"><see cref="P:System.Diagnostics.EventLog.Log"/></param>
            <param name="source"><see cref="P:System.Diagnostics.EventLog.Source"/></param>
        </member>
        <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a logger based on <see cref="T:System.Diagnostics.EventLog"/>.
            </summary>
            <param name="logName"><see cref="P:System.Diagnostics.EventLog.Log"/></param>
            <param name="machineName"><see cref="P:System.Diagnostics.EventLog.MachineName"/></param>
            <param name="source"><see cref="P:System.Diagnostics.EventLog.Source"/></param>
        </member>
        <member name="T:Castle.Core.Logging.LoggerLevel">
            <summary>
            Supporting Logger levels.
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Off">
            <summary>
            Logging will be off
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Fatal">
            <summary>
            Fatal logging level
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Error">
            <summary>
            Error logging level
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Warn">
            <summary>
            Warn logging level
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Info">
            <summary>
            Info logging level
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Debug">
            <summary>
            Debug logging level
            </summary>
        </member>
        <member name="T:Castle.Core.IServiceEnabledComponent">
            <summary>
            Defines that the implementation wants a 
            <see cref="T:System.IServiceProvider"/> in order to 
            access other components. The creator must be aware
            that the component might (or might not) implement 
            the interface.
            </summary>
            <remarks>
            Used by Castle Project components to, for example, 
            gather logging factories
            </remarks>
        </member>
        <member name="T:NMock2.Actions.ThrowAction">
            <summary>
            Action that sets the exception of an invocation.
            </summary>
        </member>
        <member name="F:NMock2.Actions.ThrowAction.exception">
            <summary>
            Stores the exception to be thrown.
            </summary>
        </member>
        <member name="M:NMock2.Actions.ThrowAction.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Actions.ThrowAction"/> class.
            </summary>
            <param name="exception">The exception.</param>
        </member>
        <member name="M:NMock2.Actions.ThrowAction.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Invokes this object. Sets the exception the invocation will throw.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.Actions.ThrowAction.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Actions.SignalAction">
            <summary>
            Action that signals an event.
            You can use this action to synchronize threads when an expectation is invoked.
            </summary>
        </member>
        <member name="F:NMock2.Actions.SignalAction.signal">
            <summary>
            Stores the wait handle to be signalled.
            </summary>
        </member>
        <member name="M:NMock2.Actions.SignalAction.#ctor(System.Threading.EventWaitHandle)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Actions.SignalAction"/> class.
            </summary>
            <param name="signal">The signal.</param>
        </member>
        <member name="M:NMock2.Actions.SignalAction.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Invokes this object by signaling the event.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.Actions.SignalAction.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="P:NMock2.Actions.SignalAction.Signal">
            <summary>
            Gets the signal.
            You can use this signal to wait for this action beeing invoked.
            </summary>
            <value>The signal.</value>
        </member>
        <member name="T:NMock2.Matchers.StringContainsMatcher">
            <summary>
            Matcher that checks whether the actual value contains the expected substring.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.StringContainsMatcher.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.StringContainsMatcher"/> class.
            </summary>
            <param name="substring">The substring that is expected.</param>
        </member>
        <member name="M:NMock2.Matchers.StringContainsMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object is a string and contains the expected substring.</returns>
        </member>
        <member name="M:NMock2.Matchers.StringContainsMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Matchers.NotMatcher">
            <summary>
            Matcher that negates another matcher.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.NotMatcher.negated">
            <summary>
            Holds the matcher to negate.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.NotMatcher.#ctor(NMock2.Matcher)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.NotMatcher"/> class.
            </summary>
            <param name="negated">The matcher to negate.</param>
        </member>
        <member name="M:NMock2.Matchers.NotMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The object to match.</param>
            <returns>Whether the object does not matche the wrapped matcher.</returns>
        </member>
        <member name="M:NMock2.Matchers.NotMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:Castle.DynamicProxy.CacheMappingsAttribute">
            <summary>
            Applied to the assemblies saved by <see cref="T:Castle.DynamicProxy.ModuleScope"/> in order to persist the cache data included in the persisted assembly.
            </summary>
        </member>
        <member name="T:Castle.Core.InterceptorReferenceCollection">
            <summary>
            Collection of <see cref="T:Castle.Core.InterceptorReference"/>
            </summary>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.Add(Castle.Core.InterceptorReference)">
            <summary>
            Adds the specified item.
            </summary>
            <param name="item">The interceptor.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.AddFirst(Castle.Core.InterceptorReference)">
            <summary>
            Adds the specified interceptor as the first.
            </summary>
            <param name="item">The interceptor.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.AddLast(Castle.Core.InterceptorReference)">
            <summary>
            Adds the specified interceptor as the last.
            </summary>
            <param name="item">The interceptor.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.Insert(System.Int32,Castle.Core.InterceptorReference)">
            <summary>
            Inserts the specified interceptor at the specified index.
            </summary>
            <param name="index">The index.</param>
            <param name="item">The interceptor.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.CopyTo(System.Array,System.Int32)">
            <summary>
            When implemented by a class, copies the elements of
            the <see cref="T:System.Collections.ICollection"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="array"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is less than zero.</exception>
            <exception cref="T:System.ArgumentException">
            	<para>
            		<paramref name="array"/> is multidimensional.</para>
            	<para>-or-</para>
            	<para>
            		<paramref name="index"/> is equal to or greater than the length of <paramref name="array"/>.</para>
            	<para>-or-</para>
            	<para>The number of elements in the source <see cref="T:System.Collections.ICollection"/> is greater than the available space from <paramref name="index"/> to the end of the destination <paramref name="array"/>.</para>
            </exception>
            <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the destination <paramref name="array"/>.</exception>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/>
            that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.AddIfNotInCollection(Castle.Core.InterceptorReference)">
            <summary>
            Adds the interceptor to the end of the interceptors list if it does not exist already.
            </summary>
            <param name="interceptorReference">The interceptor reference.</param>
        </member>
        <member name="P:Castle.Core.InterceptorReferenceCollection.HasInterceptors">
            <summary>
            Gets a value indicating whether this instance has interceptors.
            </summary>
            <value>
            	<c>true</c> if this instance has interceptors; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.InterceptorReferenceCollection.Count">
            <summary>
            Gets the number of
            elements contained in the <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.Core.InterceptorReferenceCollection.SyncRoot">
            <summary>
            Gets an object that
            can be used to synchronize access to the <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.Core.InterceptorReferenceCollection.IsSynchronized">
            <summary>
            Gets a value
            indicating whether access to the <see cref="T:System.Collections.ICollection"/> is synchronized
            (thread-safe).
            </summary>
            <value></value>
        </member>
        <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.Type)">
            <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.String)">
            <summary>
            Creates a new extended logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
            <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
            Creates a new extended logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Castle#Core#Logging#ILoggerFactory#Create(System.Type)">
            <summary>
            Creates a new logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Castle#Core#Logging#ILoggerFactory#Create(System.String)">
            <summary>
            Creates a new logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Castle#Core#Logging#ILoggerFactory#Create(System.Type,Castle.Core.Logging.LoggerLevel)">
            <summary>
            Creates a new logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Castle#Core#Logging#ILoggerFactory#Create(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
            Creates a new logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.GetConfigFile(System.String)">
            <summary>
            Gets the configuration file.
            </summary>
            <param name="fileName">i.e. log4net.config</param>
            <returns></returns>
        </member>
        <member name="T:NMock2.Actions.CollectAction`1">
            <summary>
            Action that calls the collect delegate passed to constructor with the n-th element of the arguments to an invocation.
            </summary>
            <typeparam name="T">Type of the argument to collect.</typeparam>
        </member>
        <member name="F:NMock2.Actions.CollectAction`1.argumentIndex">
            <summary>
            Stores the index of the argument.
            </summary>
        </member>
        <member name="F:NMock2.Actions.CollectAction`1.collectDelegate">
            <summary>
            Stores the collect delegate.
            </summary>
        </member>
        <member name="M:NMock2.Actions.CollectAction`1.#ctor(System.Int32,NMock2.Actions.CollectAction{`0}.Collect)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Actions.CollectAction`1"/> class.
            </summary>
            <param name="argumentIndex">Index of the argument.</param>
            <param name="collectDelegate">The collect delegate.</param>
        </member>
        <member name="M:NMock2.Actions.CollectAction`1.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Invokes this object.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.Actions.CollectAction`1.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Actions.CollectAction`1.Collect">
            <summary>
            Delegate that is called on collecting an argument.
            </summary>
            <param name="collectedParameter">The collected generic parameter.</param>
        </member>
        <member name="M:NMock2.Monitoring.MultiInterfaceFactory.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Monitoring.MultiInterfaceFactory"/> class.
            </summary>
            <param name="name">The name of the assembly to generate.</param>
        </member>
        <member name="M:NMock2.Monitoring.MultiInterfaceFactory.TypeId.#ctor(System.Type[])">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Monitoring.MultiInterfaceFactory.TypeId"/> class.
            </summary>
            <param name="types">The types.</param>
        </member>
        <member name="M:NMock2.Internal.BuildableExpectation.#ctor(System.String,NMock2.Matcher,NMock2.Matcher)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Internal.BuildableExpectation"/> class.
            </summary>
            <param name="expectationDescription">The expectation description.</param>
            <param name="requiredCountMatcher">The required count matcher.</param>
            <param name="matchingCountMatcher">The matching count matcher.</param>
        </member>
        <member name="M:NMock2.Internal.BuildableExpectation.Matches(NMock2.Monitoring.Invocation)">
            <summary>
            Checks whether stored expectations matches the specified invocation.
            </summary>
            <param name="invocation">The invocation to check.</param>
            <returns>Returns whether one of the stored expectations has met the specified invocation.</returns>
        </member>
        <member name="M:NMock2.Internal.BuildableExpectation.QueryExpectationsBelongingTo(NMock2.Internal.IMockObject,System.Collections.Generic.IList{NMock2.IExpectation})">
            <summary>
            Adds itself to the <paramref name="result"/> if the <see cref="P:NMock2.Internal.BuildableExpectation.Receiver"/> matches
            the specified <paramref name="mock"/>.
            </summary>
            <param name="mock">The mock for which expectations are queried.</param>
            <param name="result">The result to add matching expectations to.</param>
        </member>
        <member name="M:Castle.DynamicProxy.InternalsHelper.IsInternalToDynamicProxy(System.Reflection.Assembly)">
            <summary>
            Determines whether this assembly has internals visible to dynamic proxy.
            </summary>
            <param name="asm">The assembly to inspect.</param>
        </member>
        <member name="M:Castle.DynamicProxy.InternalsHelper.IsInternal(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the specified method is internal.
            </summary>
            <param name="method">The method.</param>
            <returns>
            	<c>true</c> if the specified method is internal; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.MetaEvent.#ctor(System.String,System.Type,System.Type,Castle.DynamicProxy.Generators.MetaMethod,Castle.DynamicProxy.Generators.MetaMethod,System.Reflection.EventAttributes)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.MetaEvent"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="declaringType">Type declaring the original event being overriten, or null.</param>
            <param name="eventDelegateType"></param>
            <param name="adder">The add method.</param>
            <param name="remover">The remove method.</param>
            <param name="attributes">The attributes.</param>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.PropertiesCollection">
            <summary>
            Summary description for PropertiesCollection.
            </summary>
        </member>
        <member name="T:Castle.Core.IServiceProviderEx">
            <summary>
            Increments <c>IServiceProvider</c> with a generic service resolution operation.
            </summary>
        </member>
        <member name="T:Castle.Core.Interceptor.IChangeProxyTarget">
            <summary>
            Exposes means to change target objects of proxies and invocations
            </summary>
        </member>
        <member name="M:Castle.Core.Interceptor.IChangeProxyTarget.ChangeInvocationTarget(System.Object)">
            <summary>
            Changes the target object (<see cref="P:Castle.Core.Interceptor.IInvocation.InvocationTarget"/>) of current <see cref="T:Castle.Core.Interceptor.IInvocation"/>.
            </summary>
            <param name="target">The new value of target of invocation.</param>
            <remarks>
            Although the method takes <see cref="T:System.Object"/> the actual instance must be of type assignable to <see cref="P:Castle.Core.Interceptor.IInvocation.TargetType"/>, otherwise an <see cref="T:System.InvalidCastException"/> will be thrown.
            Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name="target"/>, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
            In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed"/> or a <see cref="T:System.NotImplementedException"/> will be throws.
            Also while it's technically legal to pass proxy itself as <paramref name="target"/>, this would create stack overflow.
            In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed"/> or a <see cref="T:System.InvalidOperationException"/> will be throws.
            </remarks>
            <exception cref="T:System.InvalidCastException">Thrown when <paramref name="target"/> is not assignable to the proxied type.</exception>
        </member>
        <member name="M:Castle.Core.Interceptor.IChangeProxyTarget.ChangeProxyTarget(System.Object)">
            <summary>
            Permanently changes the target object of the proxy. This does not affect target of the current invocation.
            </summary>
            <param name="target">The new value of target of the proxy.</param>
            <remarks>
            Although the method takes <see cref="T:System.Object"/> the actual instance must be of type assignable to proxy's target type, otherwise an <see cref="T:System.InvalidCastException"/> will be thrown.
            Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name="target"/>, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
            In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed"/> or a <see cref="T:System.NotImplementedException"/> will be throws.
            Also while it's technically legal to pass proxy itself as <paramref name="target"/>, this would create stack overflow.
            In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed"/> or a <see cref="T:System.InvalidOperationException"/> will be throws.
            </remarks>
            <exception cref="T:System.InvalidCastException">Thrown when <paramref name="target"/> is not assignable to the proxied type.</exception>
        </member>
        <member name="T:NMock2.Actions.SetIndexedParameterAction">
            <summary>
            Action that sets a parameter (method argument) of the invocation to the specified value.
            </summary>
        </member>
        <member name="F:NMock2.Actions.SetIndexedParameterAction.index">
            <summary>
            Stores the index of the paremter to set.
            </summary>
        </member>
        <member name="F:NMock2.Actions.SetIndexedParameterAction.value">
            <summary>
            Stores the value of the parameter to set.
            </summary>
        </member>
        <member name="M:NMock2.Actions.SetIndexedParameterAction.#ctor(System.Int32,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Actions.SetIndexedParameterAction"/> class.
            </summary>
            <param name="index">The index of the parameter to set.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NMock2.Actions.SetIndexedParameterAction.Invoke(NMock2.Monitoring.Invocation)">
            <summary>
            Invokes this object. Sets the parameter at the specified index of the invocation to the specified value.
            </summary>
            <param name="invocation">The invocation.</param>
        </member>
        <member name="M:NMock2.Actions.SetIndexedParameterAction.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="M:NMock2.Monitoring.ProxyInvokableAdapter.#ctor(System.Type,NMock2.Monitoring.IInvokable)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Monitoring.ProxyInvokableAdapter"/> class.
            </summary>
            <param name="proxyType">Type of the proxy.</param>
            <param name="invokable">The invokable.</param>
        </member>
        <member name="T:NMock2.Matchers.IndexSetterArgumentsMatcher">
            <summary>
            Matcher for indexer setters. Checks that the arguments passed to the indexer match.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.IndexSetterArgumentsMatcher.#ctor(NMock2.Matcher[])">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.IndexSetterArgumentsMatcher"/> class.
            </summary>
            <param name="valueMatchers">The value matchers. This is an ordered list of matchers, each matching a single method argument.</param>
        </member>
        <member name="M:NMock2.Matchers.IndexSetterArgumentsMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:NMock2.Is">
            <summary>
            Provides shortcuts to <see cref="T:NMock2.Matcher"/>s.
            </summary>
        </member>
        <member name="F:NMock2.Is.Anything">
            <summary>
            Matches anything.
            </summary>
        </member>
        <member name="F:NMock2.Is.Nothing">
            <summary>
            Matches nothing.
            </summary>
        </member>
        <member name="F:NMock2.Is.Null">
            <summary>
            Matches if the value is null.
            </summary>
        </member>
        <member name="F:NMock2.Is.NotNull">
            <summary>
            Matches if the value is not null.
            </summary>
        </member>
        <member name="F:NMock2.Is.Out">
            <summary>
            Matches out parameters of methods.
            </summary>
        </member>
        <member name="M:NMock2.Is.EqualTo(System.Object)">
            <summary>
            Matches objects the are equal to the expected object.
            <seealso cref="M:NMock2.Is.Same(System.Object)"/>
            </summary>
            <param name="expected">The expected.</param>
            <returns>Returns a new instance of the <see cref="T:NMock2.Matchers.EqualMatcher"/> class.</returns>
        </member>
        <member name="M:NMock2.Is.Same(System.Object)">
            <summary>
            Matches an expected object.
            <seealso cref="M:NMock2.Is.EqualTo(System.Object)"/>
            </summary>
            <param name="expected">The expected object.</param>
            <returns>Returns a new instance of the <see cref="T:NMock2.Matchers.SameMatcher"/> class.</returns>
        </member>
        <member name="M:NMock2.Is.StringContaining(System.String)">
            <summary>
            Matches strings containing the specified <paramref name="substring"/>.
            </summary>
            <param name="substring">The substring.</param>
            <returns>Returns a new instance of the <see cref="T:NMock2.Matchers.StringContainsMatcher"/> class.</returns>
        </member>
        <member name="M:NMock2.Is.GreaterThan(System.IComparable)">
            <summary>
            Matches objects that are greater than <paramref name="value"/>.
            </summary>
            <param name="value">The value to compare.</param>
            <returns>Returns a new instance of the <see cref="T:NMock2.Matchers.ComparisonMatcher"/> class.</returns>
        </member>
        <member name="M:NMock2.Is.AtLeast(System.IComparable)">
            <summary>
            Matches objects that are at least equal to <paramref name="value"/>.
            </summary>
            <param name="value">The value to compare.</param>
            <returns>Returns a new instance of the <see cref="T:NMock2.Matchers.ComparisonMatcher"/> class.</returns>
        </member>
        <member name="M:NMock2.Is.LessThan(System.IComparable)">
            <summary>
            Matches objects less than <paramref name="value"/>.
            </summary>
            <param name="value">The value to compare.</param>
            <returns>Returns a new instance of the <see cref="T:NMock2.Matchers.ComparisonMatcher"/> class.</returns>
        </member>
        <member name="M:NMock2.Is.AtMost(System.IComparable)">
            <summary>
            Matches objects that are less or equal to <paramref name="value"/>.
            </summary>
            <param name="value">The value to compare.</param>
            <returns>Returns a new instance of the <see cref="T:NMock2.Matchers.ComparisonMatcher"/> class.</returns>
        </member>
        <member name="M:NMock2.Is.In(System.Collections.ICollection)">
            <summary>
            Matches objects in the specified collection.
            </summary>
            <param name="collection">The collection with objects to match.</param>
            <returns>Returns a new instance of the <see cref="T:NMock2.Matchers.ElementMatcher"/> class.</returns>
        </member>
        <member name="M:NMock2.Is.OneOf(System.Object[])">
            <summary>
            Matches objects in the specified elements.
            </summary>
            <param name="elements">The elements to match.</param>
            <returns>Returns a new instance of the <see cref="T:NMock2.Matchers.ElementMatcher"/> class.</returns>
        </member>
        <member name="M:NMock2.Is.TypeOf(System.Type)">
            <summary>
            Matches objects of the specified type.
            </summary>
            <param name="type">The type to match.</param>
            <returns>Returns a new instance of the <see cref="T:NMock2.Matchers.TypeMatcher"/> class.</returns>
        </member>
        <member name="M:NMock2.Is.TypeOf``1">
            <summary>
            Matches objects of the specified type.
            </summary>
            <typeparam name="T">The type to match.</typeparam>
            <returns>
            Returns a new instance of the <see cref="T:NMock2.Matchers.TypeMatcher"/> class.
            </returns>
        </member>
        <member name="M:NMock2.Is.Match``1(NMock2.Matchers.GenericMatcher{``0}.MatchExpression)">
            <summary>
            Matches objects against the specified expression.
            </summary>
            <typeparam name="T">Type of the value to match.</typeparam>
            <param name="expression">The match expression.</param>
            <returns>returns a new instance of the <see cref="T:NMock2.Matchers.GenericMatcher`1"/>.</returns>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.StindOpCodesDictionary">
            <summary>
            Provides appropriate Stind.X opcode 
            for the type of primitive value to be stored indirectly.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.MethodEmitter.CopyParametersAndReturnTypeFrom(System.Reflection.MethodInfo,Castle.DynamicProxy.Generators.Emitters.AbstractTypeEmitter)">
            <summary>
            Inspect the base method for generic definitions
            and set the return type and the parameters
            accordingly
            </summary>
        </member>
        <member name="T:Castle.Core.Resource.FileResourceFactory">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.Core.PropertySetCollection">
            <summary>
            Collection of <see cref="T:Castle.Core.PropertySet"/>
            </summary>
        </member>
        <member name="M:Castle.Core.PropertySetCollection.FindByPropertyInfo(System.Reflection.PropertyInfo)">
            <summary>
            Finds a PropertySet the by PropertyInfo.
            </summary>
            <param name="info">The info.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.Core.ParameterModelCollection">
            <summary>
            Collection of <see cref="T:Castle.Core.ParameterModel"/>
            </summary>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,System.String)">
            <summary>
            Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="configNode">The config node.</param>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Contains(System.Object)">
            <summary>
            Determines whether this collection contains the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns>
            <c>true</c> if yes; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Add(System.Object,System.Object)">
            <summary>
            Adds the specified key.
            </summary>
            <remarks>
            Not implemented
            </remarks>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Clear">
            <summary>
            Clears this instance.
            </summary>
            <remarks>
            Not implemented
            </remarks>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Remove(System.Object)">
            <summary>
            Removes the specified key.
            </summary>
            <param name="key">The key.</param>
            <remarks>
            Not implemented
            </remarks>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.CopyTo(System.Array,System.Int32)">
            <summary>
            Copy the content to the specified array
            </summary>
            <param name="array">target array</param>
            <param name="index">target index</param>
            <remarks>
            Not implemented
            </remarks>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/>
            that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.Keys">
            <summary>
            Gets the keys.
            </summary>
            <value>The keys.</value>
            <remarks>
            Not implemented
            </remarks>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.Values">
            <summary>
            Gets the values.
            </summary>
            <value>The values.</value>
            <remarks>
            Not implemented
            </remarks>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.IsReadOnly">
            <summary>
            Gets a value indicating whether this instance is read only.
            </summary>
            <value>
            	<c>true</c> if this instance is read only; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.IsFixedSize">
            <summary>
            Gets a value indicating whether this instance is fixed size.
            </summary>
            <value>
            	<c>true</c> if this instance is fixed size; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Castle.Core.ParameterModel"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.Count">
            <summary>
            Gets the count.
            </summary>
            <value>The count.</value>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.SyncRoot">
            <summary>
            Gets the sync root.
            </summary>
            <value>The sync root.</value>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.IsSynchronized">
            <summary>
            Gets a value indicating whether this instance is synchronized.
            </summary>
            <value>
            	<c>true</c> if this instance is synchronized; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Castle.Core.ParameterModel">
            <summary>
            Represents a parameter. Usually the parameter
            comes from the external world, ie, an external configuration.
            </summary>
        </member>
        <member name="M:Castle.Core.ParameterModel.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Castle.Core.ParameterModel.#ctor(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:Castle.Core.ParameterModel.Name">
            <summary>
            Gets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Castle.Core.ParameterModel.Value">
            <summary>
            Gets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="P:Castle.Core.ParameterModel.ConfigValue">
            <summary>
            Gets the config value.
            </summary>
            <value>The config value.</value>
        </member>
        <member name="T:Castle.Core.LifestyleType">
            <summary>
            Enumeration used to mark the component's lifestyle.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Undefined">
            <summary>
            No lifestyle specified.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Singleton">
            <summary>
            Singleton components are instantiated once, and shared
            between all clients.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Thread">
            <summary>
            Thread components have a unique instance per thread.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Transient">
            <summary>
            Transient components are created on demand.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Pooled">
            <summary>
            Optimization of transient components that keeps
            instance in a pool instead of always creating them.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.PerWebRequest">
            <summary>
            PerWebRequest components are created once per Http Request
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Custom">
            <summary>
            Any other logic to create/release components.
            </summary>
        </member>
        <member name="T:Castle.Core.PropertiesInspectionBehavior">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.Core.ComponentModel">
            <summary>
            Represents the collection of information and
            meta information collected about a component.
            </summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.name">
            <summary>Name (key) of the component</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.service">
            <summary>Service exposed</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.implementation">
            <summary>Implementation for the service</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.extended">
            <summary>Extended properties</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.lifestyleType">
            <summary>Lifestyle for the component</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.customLifestyle">
            <summary>Custom lifestyle, if any</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.customComponentActivator">
            <summary>Custom activator, if any</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.dependencies">
            <summary>Dependencies the kernel must resolve</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.constructors">
            <summary>All available constructors</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.properties">
            <summary>All potential properties that can be setted by the kernel</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.lifecycleSteps">
            <summary>Steps of lifecycle</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.parameters">
            <summary>External parameters</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.configuration">
            <summary>Configuration node associated</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.interceptors">
            <summary>Interceptors associated</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.customDependencies">
            <summary>/// Custom dependencies/// </summary>
        </member>
        <member name="M:Castle.Core.ComponentModel.#ctor(System.String,System.Type,System.Type)">
            <summary>
            Constructs a ComponentModel
            </summary>
        </member>
        <member name="M:Castle.Core.ComponentModel.Requires(System.Predicate{Castle.Core.PropertySet}[])">
            <summary>
            Requires the selected property dependencies.
            </summary>
            <param name="selectors">The property selector.</param>
        </member>
        <member name="M:Castle.Core.ComponentModel.Requires``1">
            <summary>
            Requires the property dependencies of type <typeparamref name="D"/>.
            </summary>
            <typeparam name="D">The dependency type.</typeparam>
        </member>
        <member name="P:Castle.Core.ComponentModel.Name">
            <summary>
            Sets or returns the component key
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentModel.Service">
            <summary>
            Gets or sets the service exposed.
            </summary>
            <value>The service.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Implementation">
            <summary>
            Gets or sets the component implementation.
            </summary>
            <value>The implementation.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.RequiresGenericArguments">
            <summary>
            Gets or sets a value indicating whether the component requires generic arguments.
            </summary>
            <value>
            <c>true</c> if generic arguments are required; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.ComponentModel.ExtendedProperties">
            <summary>
            Gets or sets the extended properties.
            </summary>
            <value>The extended properties.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Constructors">
            <summary>
            Gets the constructors candidates.
            </summary>
            <value>The constructors.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Properties">
            <summary>
            Gets the properties set.
            </summary>
            <value>The properties.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Configuration">
            <summary>
            Gets or sets the configuration.
            </summary>
            <value>The configuration.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.LifecycleSteps">
            <summary>
            Gets the lifecycle steps.
            </summary>
            <value>The lifecycle steps.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.LifestyleType">
            <summary>
            Gets or sets the lifestyle type.
            </summary>
            <value>The type of the lifestyle.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.InspectionBehavior">
            <summary>
            Gets or sets the strategy for
            inspecting public properties 
            on the components
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentModel.CustomLifestyle">
            <summary>
            Gets or sets the custom lifestyle.
            </summary>
            <value>The custom lifestyle.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.CustomComponentActivator">
            <summary>
            Gets or sets the custom component activator.
            </summary>
            <value>The custom component activator.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Interceptors">
            <summary>
            Gets the interceptors.
            </summary>
            <value>The interceptors.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Parameters">
            <summary>
            Gets the parameter collection.
            </summary>
            <value>The parameters.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Dependencies">
            <summary>
            Dependencies are kept within constructors and
            properties. Others dependencies must be 
            registered here, so the kernel (as a matter 
            of fact the handler) can check them
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentModel.CustomDependencies">
            <summary>
            Gets the custom dependencies.
            </summary>
            <value>The custom dependencies.</value>
        </member>
        <member name="T:Castle.Core.CastleComponentAttribute">
            <summary>
            This attribute is usefull only when you want to register all components
            on an assembly as a batch process. 
            By doing so, the batch register will look 
            for this attribute to distinguish components from other classes.
            </summary>
        </member>
        <member name="M:Castle.Core.CastleComponentAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CastleComponentAttribute"/> class.
            </summary>
            <param name="key">The key.</param>
        </member>
        <member name="M:Castle.Core.CastleComponentAttribute.#ctor(System.String,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CastleComponentAttribute"/> class.
            </summary>
            <param name="key">The key.</param>
            <param name="service">The service.</param>
        </member>
        <member name="M:Castle.Core.CastleComponentAttribute.#ctor(System.String,System.Type,Castle.Core.LifestyleType)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CastleComponentAttribute"/> class.
            </summary>
            <param name="key">The key.</param>
            <param name="service">The service.</param>
            <param name="lifestyle">The lifestyle.</param>
        </member>
        <member name="P:Castle.Core.CastleComponentAttribute.Service">
            <summary>
            Gets the service.
            </summary>
            <value>The service.</value>
        </member>
        <member name="P:Castle.Core.CastleComponentAttribute.Key">
            <summary>
            Gets the key.
            </summary>
            <value>The key.</value>
        </member>
        <member name="T:NMock2.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NMock2.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NMock2.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:NMock2.Matchers.MethodNameMatcher">
            <summary>
            Matcher that checks whether the actual object is a <see cref="T:System.Reflection.MethodInfo"/> and its name is equal to the expected name.
            </summary>
        </member>
        <member name="F:NMock2.Matchers.MethodNameMatcher.methodName">
            <summary>
            Holds the expected name of the mocked method.
            </summary>
        </member>
        <member name="M:NMock2.Matchers.MethodNameMatcher.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NMock2.Matchers.MethodNameMatcher"/> class.
            </summary>
            <param name="methodName">The expected name of the method.</param>
        </member>
        <member name="M:NMock2.Matchers.MethodNameMatcher.Matches(System.Object)">
            <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
            <param name="o">The MethodInfo to match.</param>
            <returns>Whether the object is a MethodInfo and its name matches the expected one.</returns>
        </member>
        <member name="M:NMock2.Matchers.MethodNameMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>
            Describes this object.
            </summary>
            <param name="writer">The text writer the description is added to.</param>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.MethodFinder">
            <summary>
            Returns the methods implemented by a type. Use this instead of Type.GetMethods() to work around a CLR issue
            where duplicate MethodInfos are returned by Type.GetMethods() after a token of a generic type's method was loaded.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.HandleError(System.Type,System.Exception)">
            <summary>
            Handles error during disassembly process
            </summary>
            <param name="attributeType">Type of the attribute being disassembled</param>
            <param name="exception">Exception thrown during the process</param>
            <returns>usually null, or (re)throws the exception</returns>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.InitializeConstructorArgs(System.Type,System.Attribute,System.Object[],System.Reflection.ParameterInfo[])">
            <summary>
            Here we try to match a constructor argument to its value.
            Since we can't get the values from the assembly, we use some heuristics to get it.
            a/ we first try to match all the properties on the attributes by name (case insensitive) to the argument
            b/ if we fail we try to match them by property type, with some smarts about convertions (i,e: can use Guid for string).
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ReplaceIfBetterMatch(System.Reflection.ParameterInfo,System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)">
            <summary>
            We have the following rules here.
            Try to find a matching type, failing that, if the parameter is string, get the first property (under the assumption that
            we can convert it.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ConvertValue(System.Object,System.Type)">
            <summary>
            Attributes can only accept simple types, so we return null for null,
            if the value is passed as string we call to string (should help with converting), 
            otherwise, we use the value as is (enums, integer, etc).
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.NullLogFactory">
            <summary>
            NullLogFactory used when logging is turned off.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String)">
            <summary>
            Creates an instance of ILogger with the specified name.
            </summary>
            <param name="name">Name.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
            Creates an instance of ILogger with the specified name and LoggerLevel.
            </summary>
            <param name="name">Name.</param>
            <param name="level">Level.</param>
            <returns></returns>
        </member>
        <member name="F:Castle.Core.Internal.VertexColor.White">
            <summary>
            The node has not been visited yet
            </summary>
        </member>
        <member name="F:Castle.Core.Internal.VertexColor.Gray">
            <summary>
            This node is in the process of being visited
            </summary>
        </member>
        <member name="F:Castle.Core.Internal.VertexColor.Black">
            <summary>
            This now was visited
            </summary>
        </member>
        <member name="T:Castle.Core.Internal.ColorsSet">
            <summary>
            Represents a collection of objects
            which are guaranted to be unique 
            and holds a color for them
            </summary>
        </member>
        <member name="T:Castle.Core.Internal.TimestampSet">
            <summary>
            Holds a timestamp (integer) 
            for a given item
            </summary>
        </member>
    </members>
</doc>
