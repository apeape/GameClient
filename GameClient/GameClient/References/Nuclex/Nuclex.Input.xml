<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nuclex.Input</name>
    </assembly>
    <members>
        <member name="T:Nuclex.Input.Devices.MouseButtonEventDelegate">
            <summary>Delegate used to report a mouse event</summary>
            <param name="button">Button that has been pressed or released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.MouseWheelEventDelegate">
            <summary>Delegate used to report a mouse event</summary>
            <param name="ticks">Number of ticks the mouse wheel was rotated</param>
        </member>
        <member name="T:Nuclex.Input.Devices.MouseMoveEventDelegate">
            <summary>Delegate used to report a mouse event</summary>
            <param name="x">X coordinate of the mouse cursor</param>
            <param name="y">Y coordinate or the mouse cursor</param>
        </member>
        <member name="T:Nuclex.Input.Devices.IMouseMessageSource">
            <summary>
              Sends out notifications for intercepted window messages related to the mouse
            </summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouseMessageSource.MouseButtonPressed">
            <summary>Triggered when a mouse button has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouseMessageSource.MouseButtonReleased">
            <summary>Triggered when a mouse button has been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouseMessageSource.MouseMoved">
            <summary>Triggered when the mouse has been moved</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouseMessageSource.MouseWheelRotated">
            <summary>Triggered when the mouse wheel has been rotated</summary>
        </member>
        <member name="T:Nuclex.Input.ControllerEventArgsTest">
            <summary>Unit tests for the controller detector</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerEventArgsTest.TestDefaultConstructor">
            <summary>Verifies that the default constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerEventArgsTest.TestPlayerIndexConstructor">
            <summary>Verifies that the PlayerIndex constructor is working</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.XnaKeyboard">
            <summary>Interfaces with an XBox 360 chat pad via XNA (XINPUT)</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.IKeyboard">
            <summary>Specialized input device for keyboard-like controllers</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.IInputDevice">
            <summary>Generic input device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.IInputDevice.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.IInputDevice.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="P:Nuclex.Input.Devices.IInputDevice.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.IInputDevice.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.IKeyboard.GetState">
            <summary>Retrieves the current state of the keyboard</summary>
            <returns>The current state of the keyboard</returns>
        </member>
        <member name="E:Nuclex.Input.Devices.IKeyboard.KeyPressed">
            <summary>Fired when a key has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IKeyboard.KeyReleased">
            <summary>Fired when a key has been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IKeyboard.CharacterEntered">
            <summary>Fired when the user has entered a character</summary>
            <remarks>
              This provides the complete, translated character the user has entered.
              Handling of international keyboard layouts, shift key, accents and
              other special cases is done by Windows according to the current users'
              country and selected keyboard layout.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.#ctor(Microsoft.Xna.Framework.PlayerIndex,Nuclex.Input.Devices.IGamePad)">
            <summary>Initializes a new XNA-based keyboard device</summary>
            <param name="playerIndex">Index of the player whose chat pad will be queried</param>
            <param name="gamePad">Game pad the chat pad is attached to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.GetState">
            <summary>Retrieves the current state of the keyboard</summary>
            <returns>The current state of the keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.OnKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Fires the KeyPressed event</summary>
            <param name="key">Key to report as having been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.OnKeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Fires the KeyReleased event</summary>
            <param name="key">Key to report as having been releaed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.OnCharacterEntered(System.Char)">
            <summary>Fires the CharacterEntered event</summary>
            <param name="character">Character to report as having been entered</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.getAllValidKeys">
            <summary>Returns all entries in the XNA Keys enumeration</summary>
            <returns>All entries in the keys enumeration</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.updateImmediateState">
            <summary>Updates the immediate (non-buffered) state of the keyboard</summary>
            <remarks>
              Only called when the game is not using the Update() and TakeSnapshot() methods
              to buffer input.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.generateEvents(Microsoft.Xna.Framework.Input.KeyboardState@,Microsoft.Xna.Framework.Input.KeyboardState@)">
            <summary>Generates events for the differences between two states</summary>
            <param name="previous">Previous state the keyboard reported</param>
            <param name="current">Current state reported by the keyboard</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.generateCharacterEvent(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Generates the character entered event for the chat pad</summary>
            <param name="key">Key that has been pressed on the chat pad</param>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaKeyboard.validKeys">
            <summary>Contains all keys listed in the Keys enumeration</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaKeyboard.playerIndex">
            <summary>Index of the player this device represents</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaKeyboard.gamePad">
            <summary>Game pad the chat pad is attached to</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaKeyboard.states">
            <summary>Snapshots of the keyboard state waiting to be processed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaKeyboard.current">
            <summary>Currently published keyboard state</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaKeyboard.characterMap">
            <summary>Maps the keys enumeration to characters</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.XnaKeyboard.KeyPressed">
            <summary>Fired when a key has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.XnaKeyboard.KeyReleased">
            <summary>Fired when a key has been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.XnaKeyboard.CharacterEntered">
            <summary>Fired when the user has entered a character</summary>
            <remarks>
              This provides the complete, translated character the user has entered.
              Handling of international keyboard layouts, shift key, accents and
              other special cases is done by Windows according to the current users'
              country and selected keyboard layout.
            </remarks>
        </member>
        <member name="P:Nuclex.Input.Devices.XnaKeyboard.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.XnaKeyboard.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.WindowMessageMouse">
            <summary>Interfaces with a PC mouse via window messages</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedMouse">
            <summary>Mouse that buffers mouse events until Update() is called</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.IMouse">
            <summary>Specializd input devices for mouse-like controllers</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.IMouse.GetState">
            <summary>Retrieves the current state of the mouse</summary>
            <returns>The current state of the mouse</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.IMouse.MoveTo(System.Single,System.Single)">
            <summary>Moves the mouse cursor to the specified location</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouse.MouseMoved">
            <summary>Fired when the mouse has been moved</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouse.MouseButtonPressed">
            <summary>Fired when one or more mouse buttons have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouse.MouseButtonReleased">
            <summary>Fired when one or more mouse buttons have been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouse.MouseWheelRotated">
            <summary>Fired when the mouse wheel has been rotated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.#ctor">
            <summary>Initializes a new buffered mouse device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.GetState">
            <summary>Retrieves the current state of the mouse</summary>
            <returns>The current state of the mouse</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.MoveTo(System.Single,System.Single)">
            <summary>Moves the mouse cursor to the specified location</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.OnButtonPressed(Nuclex.Input.MouseButtons)">
            <summary>Records a mouse button press in the event queue</summary>
            <param name="buttons">Buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.OnButtonReleased(Nuclex.Input.MouseButtons)">
            <summary>Records a mouse button release in the event queue</summary>
            <param name="buttons">Buttons that have been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.OnWheelRotated(System.Single)">
            <summary>Records a mouse wheel rotation in the event queue</summary>
            <param name="ticks">Ticks the mouse wheel has been rotated</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.OnMouseMoved(System.Single,System.Single)">
            <summary>Records a mouse cursor movement in the event queue</summary>
            <param name="x">X coordinate the mouse cursor has been moved to</param>
            <param name="y">Y coordinate the mouse cursor has been moved to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.BufferButtonPress(Nuclex.Input.MouseButtons)">
            <summary>Records a mouse button press in the event queue</summary>
            <param name="buttons">Buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.BufferButtonRelease(Nuclex.Input.MouseButtons)">
            <summary>Records a mouse button release in the event queue</summary>
            <param name="buttons">Buttons that have been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.BufferWheelRotation(System.Single)">
            <summary>Records a mouse wheel rotation in the event queue</summary>
            <param name="ticks">Ticks the mouse wheel has been rotated</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.BufferCursorMovement(System.Single,System.Single)">
            <summary>Records a mouse cursor movement in the event queue</summary>
            <param name="x">X coordinate the mouse cursor has been moved to</param>
            <param name="y">Y coordinate the mouse cursor has been moved to</param>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.pressedButtons">
            <summary>Mouse buttons currently pressed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.wheelPosition">
            <summary>Cumulative position of the mouse wheel</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.x">
            <summary>X coordinate of the mouse cursor</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.y">
            <summary>Y coordinate of the mouse cursor</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.queuedEvents">
            <summary>Queued mouse events</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedMouse.MouseMoved">
            <summary>Fired when the mouse has been moved</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedMouse.MouseButtonPressed">
            <summary>Fired when one or more mouse buttons have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedMouse.MouseButtonReleased">
            <summary>Fired when one or more mouse buttons have been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedMouse.MouseWheelRotated">
            <summary>Fired when the mouse wheel has been rotated</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedMouse.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedMouse.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedMouse.EventType">
            <summary>Types of event the buffered mouse can queue</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.EventType.ButtonPress">
            <summary>A button has been pressed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.EventType.ButtonRelease">
            <summary>A button has been released</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.EventType.WheelRotation">
            <summary>The mouse wheel has been rotated</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.EventType.Movement">
            <summary>The mouse cursor has been moved</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.EventType.Snapshot">
            <summary>A snapshot was taken at this point in time</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedMouse.MouseEvent">
            <summary>Stores the properties of a mouse event</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.MouseEvent.ButtonPress(Nuclex.Input.MouseButtons)">
            <summary>Creates a new mouse event for a button press</summary>
            <param name="button">Button that has been pressed</param>
            <returns>The new mouse event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.MouseEvent.ButtonRelease(Nuclex.Input.MouseButtons)">
            <summary>Creates a new mouse event for a button release</summary>
            <param name="button">Button that has been released</param>
            <returns>The new mouse event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.MouseEvent.WheelRotation(System.Single)">
            <summary>Creates a new mouse event for a mouse wheel rotation</summary>
            <param name="ticks">Number of ticks wheel has been rotated</param>
            <returns>The new mouse event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.MouseEvent.Movement(System.Single,System.Single)">
            <summary>Creates a new mouse event for a mouse cursor movement</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
            <returns>The new mouse event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.MouseEvent.Snapshot">
            <summary>Creates a new mouse event for a snapshot point</summary>
            <returns>The new mouse event</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.MouseEvent.EventType">
            <summary>Type of the event</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.MouseEvent.Button">
            <summary>Mouse buttons that were pressed or released</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.MouseEvent.Ticks">
            <summary>Number of ticks the mouse wheel was rotated</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.MouseEvent.X">
            <summary>New X coordinate of the mouse</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.MouseEvent.Y">
            <summary>New Y coordinate of the mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageMouse.#ctor(Nuclex.Input.Devices.IMouseMessageSource)">
            <summary>Initializes a new window message based mouse</summary>
            <param name="messageSource">Source the window messages are obtained from</param>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageMouse.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageMouse.MoveTo(System.Single,System.Single)">
            <summary>Moves the mouse cursor to the specified location</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageMouse.buttonPressedDelegate">
            <summary>Delegate for the buttonPressed() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageMouse.buttonReleasedDelegate">
            <summary>Delegate for the buttonReleased() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageMouse.wheelRotatedDelegate">
            <summary>Delegate for the wheelRotated() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageMouse.cursorMovedDelegate">
            <summary>Delegate for the cursorMoved() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageMouse.messageSource">
            <summary>Window message source the instance is currently subscribed to</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.WindowMessageMouse.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.WindowMessageMouse.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadConverter">
            <summary>Converts DirectInput joystick states into XNA game pad states</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.#ctor(SlimDX.DirectInput.Joystick)">
            <summary>Initializes a new game pad converter</summary>
            <param name="joystick">Joystick whose data will be converted</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.Convert(SlimDX.DirectInput.JoystickState@)">
            <summary>Converts the provided joystick state into a game pad state</summary>
            <param name="joystickState">Joystick state that will be converted</param>
            <returns>A game pad state matching the provided joystick state</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.addAxisConverters">
            <summary>Sets up the converters for the game pads axes</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.addSliderConverters">
            <summary>Adds the game pad converters for the sliders / triggers</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.convertButtonsAndPov(Nuclex.Input.Devices.GamePadConverter.FlatGamePadState,SlimDX.DirectInput.JoystickState@)">
            <summary>Converts all digital buttons and the controller's PoV hat</summary>
            <param name="gamePadState">Game pad state that will receive the results</param>
            <param name="joystickState">Joystick state the values are taken from</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.countInstances(System.Collections.Generic.IList{SlimDX.DirectInput.DeviceObjectInstance},System.Guid)">
            <summary>Counts the number of input objects of a certain type</summary>
            <param name="list">List in which the input objects will be counted</param>
            <param name="typeGuid">The guid of the input objects to count</param>
            <returns>The number of input objects of the specified type</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.getInstance(System.Collections.Generic.IList{SlimDX.DirectInput.DeviceObjectInstance},System.Guid,System.Int32)">
            <summary>Returns the nth input object of the specified type</summary>
            <param name="list">List the input objects will be looked up in</param>
            <param name="typeGuid">Guid of the input objects to look up</param>
            <param name="wantedIndex">The index of the desired input object</param>
            <returns>The input object according to the parameters specified</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.buttonOrder">
            <summary>Order in which the buttons reported by DirectInput appear</summary>
            <remarks>
              Tested this with an XBox 360 game pad. An older game pad used a completely
              arbitrary order and there's no way to find out which button resembles what,
              so I'm hoping that the XBox 360's DirectInput driver sets an inofficial
              standard and others copy the order in which its buttons are listed.
            </remarks>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.joystick">
            <summary>Joystick the converter is working with</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.axisCount">
            <summary>The number of axes on the DirectInput joystick</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.buttonCount">
            <summary>The number of buttons on the DirectInput joystick</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.hasPovHat">
            <summary>Whether the DirectInput joystick has a POV hat (or DPAD)</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.convertDelegate">
            <summary>Multi cast delegate invoking all needed conversion methods</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.gamePadState">
            <summary>Modifiable game pad state in which the conversion methods work</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadConverter.FlatGamePadState">
            <summary>Stores all fields of a GamePadState in a flat structure</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.FlatGamePadState.LeftThumbStick">
            <summary>Position of the left thumb stick</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.FlatGamePadState.RightThumbStick">
            <summary>Position of the right thumb stick</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.FlatGamePadState.LeftTrigger">
            <summary>Level of the left trigger</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.FlatGamePadState.RightTrigger">
            <summary>Level of the right trigger</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.FlatGamePadState.Buttons">
            <summary>State of the game pad's digital buttons</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadConverter.ConverterDelegate">
            <summary>Converts a joystick state field to a game pad state field</summary>
            <param name="gamePadState">Game pad state the field will be written to</param>
            <param name="joystickState">Joystick state the field will be written to</param>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadConverter.AxisConverter">
            <summary>Base class for the joystick axis converters</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.AxisConverter.#ctor(System.Int32,System.Int32)">
            <summary>Initializes a new X axis converter</summary>
            <param name="min">Negative range of the axis</param>
            <param name="max">Positive range of the axis</param>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.AxisConverter.Center">
            <summary>The centered position of the axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.AxisConverter.Min">
            <summary>Positive range of the axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.AxisConverter.Max">
            <summary>Negative range of the axis</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadConverter.XAxisConverter">
            <summary>Converts the value of the joystick's X axis</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.XAxisConverter.#ctor(System.Int32,System.Int32)">
            <summary>Initializes a new X axis converter</summary>
            <param name="min">Negative range of the axis</param>
            <param name="max">Positive range of the axis</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.XAxisConverter.Convert(Nuclex.Input.Devices.GamePadConverter.FlatGamePadState,SlimDX.DirectInput.JoystickState@)">
            <summary>Retrieves the current value of the axis</summary>
            <param name="gamePadState">Game pad state that will receive the value</param>
            <param name="joystickState">State from which the axis is retrieved</param>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadConverter.YAxisConverter">
            <summary>Converts the value of the joystick's Y axis</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.YAxisConverter.#ctor(System.Int32,System.Int32)">
            <summary>Initializes a new Y axis converter</summary>
            <param name="min">Negative range of the axis</param>
            <param name="max">Positive range of the axis</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.YAxisConverter.Convert(Nuclex.Input.Devices.GamePadConverter.FlatGamePadState,SlimDX.DirectInput.JoystickState@)">
            <summary>Retrieves the current value of the axis</summary>
            <param name="gamePadState">Game pad state that will receive the value</param>
            <param name="joystickState">State from which the axis is retrieved</param>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadConverter.RotationalXAxisConverter">
            <summary>Converts the value of the joystick's rotational X axis</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.RotationalXAxisConverter.#ctor(System.Int32,System.Int32)">
            <summary>Initializes a new rotational X axis converter</summary>
            <param name="min">Negative range of the axis</param>
            <param name="max">Positive range of the axis</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.RotationalXAxisConverter.Convert(Nuclex.Input.Devices.GamePadConverter.FlatGamePadState,SlimDX.DirectInput.JoystickState@)">
            <summary>Retrieves the current value of the axis</summary>
            <param name="gamePadState">Game pad state that will receive the value</param>
            <param name="joystickState">State from which the axis is retrieved</param>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadConverter.RotationalYAxisConverter">
            <summary>Converts the value of the joystick's rotational Y axis</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.RotationalYAxisConverter.#ctor(System.Int32,System.Int32)">
            <summary>Initializes a new rotational Y axis converter</summary>
            <param name="min">Negative range of the axis</param>
            <param name="max">Positive range of the axis</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.RotationalYAxisConverter.Convert(Nuclex.Input.Devices.GamePadConverter.FlatGamePadState,SlimDX.DirectInput.JoystickState@)">
            <summary>Retrieves the current value of the axis</summary>
            <param name="gamePadState">Game pad state that will receive the value</param>
            <param name="joystickState">State from which the axis is retrieved</param>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadConverter.RotationalZAxisLeftTriggerConverter">
            <summary>Converts the value of the joystick's rotational Z axis</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.RotationalZAxisLeftTriggerConverter.#ctor(System.Int32,System.Int32)">
            <summary>Initializes a new rotational Z axis converter</summary>
            <param name="min">Negative range of the axis</param>
            <param name="max">Positive range of the axis</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.RotationalZAxisLeftTriggerConverter.Convert(Nuclex.Input.Devices.GamePadConverter.FlatGamePadState,SlimDX.DirectInput.JoystickState@)">
            <summary>Retrieves the current value of the axis</summary>
            <param name="gamePadState">Game pad state that will receive the value</param>
            <param name="joystickState">State from which the axis is retrieved</param>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadConverter.SliderLeftTriggerConverter">
            <summary>Converts the value of the joystick's slider axis</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.SliderLeftTriggerConverter.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>Initializes a new rotational Y axis converter</summary>
            <param name="sliderIndex">Index of the slider that will be converted</param>
            <param name="min">Negative range of the axis</param>
            <param name="max">Positive range of the axis</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.SliderLeftTriggerConverter.Convert(Nuclex.Input.Devices.GamePadConverter.FlatGamePadState,SlimDX.DirectInput.JoystickState@)">
            <summary>Retrieves the current value of the axis</summary>
            <param name="gamePadState">Game pad state that will receive the value</param>
            <param name="joystickState">State from which the axis is retrieved</param>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.SliderLeftTriggerConverter.sliderIndex">
            <summary>Index of the slider that will be converted</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.SliderLeftTriggerConverter.min">
            <summary>Negative range of the axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.SliderLeftTriggerConverter.max">
            <summary>Positive range of the axis</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadConverter.SliderRightTriggerConverter">
            <summary>Converts the value of the joystick's slider axis</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.SliderRightTriggerConverter.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>Initializes a new rotational Y axis converter</summary>
            <param name="sliderIndex">Index of the slider that will be converted</param>
            <param name="min">Negative range of the axis</param>
            <param name="max">Positive range of the axis</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverter.SliderRightTriggerConverter.Convert(Nuclex.Input.Devices.GamePadConverter.FlatGamePadState,SlimDX.DirectInput.JoystickState@)">
            <summary>Retrieves the current value of the axis</summary>
            <param name="gamePadState">Game pad state that will receive the value</param>
            <param name="joystickState">State from which the axis is retrieved</param>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.SliderRightTriggerConverter.sliderIndex">
            <summary>Index of the slider that will be converted</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.SliderRightTriggerConverter.min">
            <summary>Negative range of the axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverter.SliderRightTriggerConverter.max">
            <summary>Positive range of the axis</summary>
        </member>
        <member name="T:Nuclex.Input.CollectionHelperTest">
            <summary>Unit tests for the collection helper</summary>
        </member>
        <member name="M:Nuclex.Input.CollectionHelperTest.TestGetIfExists">
            <summary>Verifies that the Contains() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.CollectionHelperTest.TestDisposeItems">
            <summary>Verifies that the DisposeItems() method is working correctly</summary>
        </member>
        <member name="T:Nuclex.Input.CollectionHelperTest.Test">
            <summary>Test implementation of the IDisposable interface</summary>
        </member>
        <member name="T:Nuclex.Input.CollectionHelperTest.TestDisposable">
            <summary>Test implementation of the IDisposable interface</summary>
        </member>
        <member name="M:Nuclex.Input.CollectionHelperTest.TestDisposable.Dispose">
            <summary>Called to dispose the instance</summary>
        </member>
        <member name="F:Nuclex.Input.CollectionHelperTest.TestDisposable.DisposeCallCount">
            <summary>Number of times the Dispose() method has been called</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedMouseTest">
            <summary>Unit tests for the mocked mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestAttachAndDetach">
            <summary>Verifies that the mouse can be attached and detached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestName">
            <summary>Verifies that the mocked mouse's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestPressButton">
            <summary>Verifies that button presses can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestReleaseButton">
            <summary>Verifies that button releases can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestMoveTo">
            <summary>Verifies that mouse movement can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestRotateWheel">
            <summary>Verifies that mouse wheel rotations can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.mockSubscriber">
            <summary>Mocks a subscriber for the buffered keyboard</summary>
            <returns>A subscriber registered to the events of the keyboard</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedMouseTest.mockery">
            <summary>Creates dynamic mock objects for interfaces</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedMouseTest.mouse">
            <summary>Buffered mouse being tested</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedMouseTest.IMouseSubscriber">
            <summary>Subscriber to the events of a mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.IMouseSubscriber.ButtonPressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed</summary>
            <param name="buttons">Button which has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.IMouseSubscriber.ButtonReleased(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released</summary>
            <param name="buttons">Button which has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.IMouseSubscriber.Moved(System.Single,System.Single)">
            <summary>Called when the mouse cursor has been moved</summary>
            <param name="x">X coordinate of the mouse cursor</param>
            <param name="y">Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.IMouseSubscriber.WheelRotated(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks the mouse wheel was rotated</param>
        </member>
        <member name="T:Nuclex.Input.ControllerDetectorTest">
            <summary>Unit tests for the controller detector</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.Setup">
            <summary>Called once before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.TestConstructor">
            <summary>Verifies that the constructor of the class is working</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.TestMouseDetection">
            <summary>
              Verifies that the controller detector detects a mouse button press
            </summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.TestKeyboard">
            <summary>
              Verifies that the controller detector detects a keyboard key press
            </summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.TestChatPad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Verifies that the controller detector detects a chat pad key press
            </summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.TestGamePad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Verifies that the controller detector detects a game pad button press
            </summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.mockSubscriber">
            <summary>Creates a mocked subscriber for the controller detector</summary>
            <returns>The mocked subscriber</returns>
        </member>
        <member name="F:Nuclex.Input.ControllerDetectorTest.detector">
            <summary>Controller detector being tested</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetectorTest.inputManager">
            <summary>Mocked input manager used for unit testing</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetectorTest.mockery">
            <summary>Creates dynamic mock objects for interfaces</summary>
        </member>
        <member name="T:Nuclex.Input.ControllerDetectorTest.IControllerDetectorSubscriber">
            <summary>Subscriber for the events of the controller detector</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.IControllerDetectorSubscriber.ControllerDetected(System.Object,Nuclex.Input.ControllerEventArgs)">
            <summary>
              Called when the controller detector has discovered a controller on
              which a button has been pressed
            </summary>
            <param name="sender">Detector sending the event</param>
            <param name="arguments">
              Contains the index of the player whose controller changed its state
            </param>
        </member>
        <member name="T:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher">
            <summary>Matches controller event args to expected values</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher.#ctor">
            <summary>
              Initializes a new matcher for controller event arguments for the default
              player on a PC system
            </summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher.#ctor(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>Initializes a new matcher for controller event arguments</summary>
            <param name="playerIndex">
              Index of the player to expect in the event arguments
            </param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher.#ctor(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Initializes a new matcher for controller event arguments</summary>
            <param name="playerIndex">
              Index of the player to expect in the event arguments
            </param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>Generates a human-readable description of the matcher</summary>
            <param name="writer">Writer the description is written into</param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher.Matches(System.Object)">
            <summary>Tests whether the provided object matches the expected state</summary>
            <param name="otherObject">Other object that will be checked</param>
            <returns>True if the other object matches the expected state</returns>
        </member>
        <member name="F:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher.playerIndex">
            <summary>Player index the matcher is expecting</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadTest">
            <summary>Unit tests for the game pad base class</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestButtonPressedEvent">
            <summary>Verifies that the ButtonPressed event is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestButtonReleasedEvent">
            <summary>Verifies that the ButtonReleased event is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestStateChangeDetection(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Tests whether state changes are detected by the game pad class</summary>
            <param name="button">Button that the detection will be tested with</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.mockSubscriber">
            <summary>Mocks a subscriber for the game pad</summary>
            <returns>The mocked subscriber</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.makeGamePadState(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Creates a game pad state with the specified button pressed</summary>
            <param name="pressedButton">Button that will be pressed down</param>
            <returns>The new game pad state</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadTest.mockery">
            <summary>Creates dynamic interface-based mock objects</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadTest.testGamePad">
            <summary>Test implementation of a game pad</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadTest.IGamePadSubscriber">
            <summary>Subscriber for the game pad's events</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.IGamePadSubscriber.ButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the game pad is pressed</summary>
            <param name="buttons">Button that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.IGamePadSubscriber.ButtonReleased(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the game pad has been released</summary>
            <param name="buttons">Button that has been released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadTest.TestGamePad">
            <summary>Implementation of a game pad for unit testing</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePad">
            <summary>Interfaces with an XBox 360 controller via XNA (XINPUT)</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.IGamePad">
            <summary>Specialized input device for game pad-like controllers</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.IGamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="E:Nuclex.Input.Devices.IGamePad.ButtonPressed">
            <summary>Called when one or more buttons on the game pad have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IGamePad.ButtonReleased">
            <summary>Called when one or more buttons on the game pad have been released</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.OnButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Fires the ButtonPressed event</summary>
            <param name="buttons">Buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.OnButtonReleased(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Fires the ButtonReleased event</summary>
            <param name="buttons">Buttons that have been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.GenerateEvents(Microsoft.Xna.Framework.Input.GamePadState@,Microsoft.Xna.Framework.Input.GamePadState@)">
            <summary>Checks for state changes and triggers the corresponding events</summary>
            <param name="previous">Previous state of the game pad</param>
            <param name="current">Current state of the game pad</param>
        </member>
        <member name="E:Nuclex.Input.Devices.GamePad.ButtonPressed">
            <summary>Called when one or more buttons on the game pad have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.GamePad.ButtonReleased">
            <summary>Called when one or more buttons on the game pad have been released</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.GamePad.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.GamePad.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.Update">
            <summary>Update the state of all input devices</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.FireButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Triggers the ButtonPressed event</summary>
            <param name="buttons">Buttons that will be reported</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.FireButtonReleased(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Triggers the ButtonReleased event</summary>
            <param name="buttons">Buttons that will be reported</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.GenerateEvents(Microsoft.Xna.Framework.Input.GamePadState@,Microsoft.Xna.Framework.Input.GamePadState@)">
            <summary>Generates events for the difference between the two states</summary>
            <param name="previous">Previous state of the game pad</param>
            <param name="current">Current state of the game pad</param>
        </member>
        <member name="P:Nuclex.Input.Devices.GamePadTest.TestGamePad.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.GamePadTest.TestGamePad.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.InputManagerTest">
            <summary>Unit tests for the input manager</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestDefaultConstructor">
            <summary>Ensures that the default constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestServiceConstructor">
            <summary>Ensures that the service container constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestKeyboardsCollection">
            <summary>Verifies that the keyboards collection isn't empty</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestMiceCollection">
            <summary>Verifies that the mice collection isn't empty</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestGamePadsCollection">
            <summary>Verifies that the game pads collection isn't empty</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestGetMouse">
            <summary>Verifies that a mouse can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestGetKeyboard">
            <summary>Verifies that the main keyboard can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestGetChatPad">
            <summary>Verifies that a chat pad can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestGetXinputGamePad">
            <summary>Verifies that an XINPUT game pad can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestGetDirectInputGamePad">
            <summary>Verifies that a DirectInput game pad can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestSnapshots">
            <summary>Verifies that the snapshot system is working</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestChangeUpdateOrder">
            <summary>Verifies that the UpdateOrder property behaves correctly</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestInitializeGameComponent">
            <summary>
              Verifies that input manager implements the IGameComponent interface
            </summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestEnabledProperty">
            <summary>
              Verifies that input manager provides an enabled property
            </summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestUpdateViaIUpdateable">
            <summary>
              Verifies that the input manager can be updated via the IUpdateable interface
            </summary>
        </member>
        <member name="T:Nuclex.Input.InputManagerTest.IUpdateableSubscriber">
            <summary>Subscriber to an updateable object</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.IUpdateableSubscriber.UpdateOrderChanged(System.Object,System.EventArgs)">
            <summary>Called when the updateable's update order has been changed</summary>
            <param name="sender">Updateable who's update order changed</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.IUpdateableSubscriber.EnabledChanged(System.Object,System.EventArgs)">
            <summary>Called when the updateable is enabled or disabled</summary>
            <param name="sender">Updateable that has been enabled or disabled</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="T:Nuclex.Input.DirectInputManagerTest">
            <summary>Unit tests for the DirectInput manager</summary>
        </member>
        <member name="M:Nuclex.Input.DirectInputManagerTest.TestIsDirectInputAvailable">
            <summary>Verifies that the IsDirectInputAvailable property is working</summary>
        </member>
        <member name="M:Nuclex.Input.DirectInputManagerTest.TestDispose">
            <summary>Tests whether the DirectInput manager can be disposed</summary>
        </member>
        <member name="M:Nuclex.Input.DirectInputManagerTest.TestCreateGamePadsAndIsDeviceAttached">
            <summary>Verifies that the IsDeviceAttached() method works</summary>
        </member>
        <member name="T:Nuclex.Input.CheckAttachedDelegate">
            <summary>Checks whether the specified device is attached</summary>
            <param name="device">Device that will be checked</param>
            <returns>True if the device is attached, false otherwise</returns>
        </member>
        <member name="T:Nuclex.Input.DirectInputManager">
            <summary>Manages DirectInput devices</summary>
        </member>
        <member name="M:Nuclex.Input.DirectInputManager.#ctor(System.IntPtr)">
            <summary>Initializes a new DirectInput manager</summary>
            <param name="windowHandle">Handle of the game's main window</param>
        </member>
        <member name="M:Nuclex.Input.DirectInputManager.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.DirectInputManager.IsDeviceAttached(SlimDX.DirectInput.Device)">
            <summary>Whether the device is currently attached</summary>
            <param name="device">Device that will be checked</param>
            <returns>True if the device is attached, false otherwise</returns>
        </member>
        <member name="M:Nuclex.Input.DirectInputManager.CreateGamePads">
            <summary>Creates game pad wrappers for all DirectInput game pads</summary>
            <returns>An array with wrappers for all DirectInput game pads</returns>
        </member>
        <member name="M:Nuclex.Input.DirectInputManager.isXInputDevice(SlimDX.DirectInput.DeviceInstance)">
            <summary>
              Determines whether the specified DirectInput device is handled by XINPUT
            </summary>
            <param name="deviceInstance">
              The DirectInput device instance that will be checked
            </param>
            <returns>True if this is a device that is handled by XINPUT</returns>
            <remarks>
              XINPUT devices are accessable through both DirectInput and XINPUT.
              Since we're already using XINPUT (through XNA), we need to filter out
              any DirectInput devices that we already access through XINPUT, otherwise,
              each XINPUT game controller would appear twice.
            </remarks>
        </member>
        <member name="F:Nuclex.Input.DirectInputManager.directInput">
            <summary>DirectInput instance used by the manager to query input devices</summary>
        </member>
        <member name="P:Nuclex.Input.DirectInputManager.IsDirectInputAvailable">
            <summary>
              Determines whether DirectInput is available on the current system
            </summary>
        </member>
        <member name="T:Nuclex.Input.CollectionHelper">
            <summary>Provides helper methods for collections</summary>
        </member>
        <member name="M:Nuclex.Input.CollectionHelper.GetIfExists``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Returns an item from a list if the index exists</summary>
            <typeparam name="ItemType">Type of the item that will be returned</typeparam>
            <param name="list">List the item will be taken from</param>
            <param name="index">Index from which the item will be taken</param>
            <returns>The item if the index existed, otherwise a default item</returns>
        </member>
        <member name="M:Nuclex.Input.CollectionHelper.DisposeItems``1(System.Collections.Generic.IList{``0})">
            <summary>Disposes all items in a list</summary>
            <typeparam name="ItemType">Type of item that will be disposed</typeparam>
            <param name="list">List containing the items that will be disposed</param>
        </member>
        <member name="T:Nuclex.Input.Devices.ModifiableKeyboardState">
            <summary>An XNA KeyboardState that can be modified</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ModifiableKeyboardState.#cctor">
            <summary>Initializes the static fields of the class</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ModifiableKeyboardState.#ctor">
            <summary>Initializes a new modifiable keyboard state</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ModifiableKeyboardState.#ctor(Microsoft.Xna.Framework.Input.KeyboardState)">
            <summary>Builds a modifiable keyboard state from the provided state</summary>
            <param name="state">State that will become the initial state</param>
        </member>
        <member name="M:Nuclex.Input.Devices.ModifiableKeyboardState.AddPressedKey(System.Int32)">
            <summary>Adds a pressed key to the keyboard state</summary>
            <param name="key">Key that will be registered as pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.ModifiableKeyboardState.RemovePressedKey(System.Int32)">
            <summary>Removes a pressed key to the keyboard state</summary>
            <param name="key">Key that will be registered as released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.ModifiableKeyboardState.op_Implicit(Nuclex.Input.Devices.ModifiableKeyboardState)~Microsoft.Xna.Framework.Input.KeyboardState">
            <summary>Converts a modifiable keyboard state into a keyboard state</summary>
            <param name="state">The modifiable keyboard state that will be converted</param>
            <returns>The equivalent keyboard state</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.ModifiableKeyboardState.addPressedKeyMethod">
            <summary>Reflection info for the KeyboardState.AddPressedKey() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ModifiableKeyboardState.removePressedKeyMethod">
            <summary>Reflection info for the KeyboardState.RemovePressedKey() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ModifiableKeyboardState.boxedKeys">
            <summary>Contains prepared parameter arrays for all valid keys</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ModifiableKeyboardState.boxedState">
            <summary>The KeyboardState instance being modified</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.XnaGamePadTest">
            <summary>Unit tests for the XNA (XINPUT) game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.TestIsAttached">
            <summary>Verifies that the game pad can be attached and detached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.TestName">
            <summary>Verifies that the mocked game pad's name can be retrieved</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedGamePadTest">
            <summary>Unit tests for the mocked game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestConstructor">
            <summary>Verifies that the constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestAttachAndDetach">
            <summary>Verifies that the game pad can be attached and detached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestName">
            <summary>Verifies that the mocked game pad's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestMoveLeftThumbStick">
            <summary>Tests whether the left thumb stick can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestMoveRightThumbStick">
            <summary>Tests whether the right thumb stick can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestLeftTrigger">
            <summary>Verifies that the left trigger can be moved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestRightTrigger">
            <summary>Verifies that the right trigger can be moved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestButtons(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Verifies that the buttons on the game pad can be pressed</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestDirectionalPad(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Verifies that the directional pad can be simulated</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.KeyDelegate">
            <summary>Delegate used to report key presses and releases</summary>
            <param name="key">Key that has been pressed or released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.CharacterDelegate">
            <summary>Delegate used to report characters typed on a keyboard</summary>
            <param name="character">Character that has been typed</param>
        </member>
        <member name="T:Nuclex.Input.MouseButtons">
            <summary>Available buttons on a mouse</summary>
        </member>
        <member name="F:Nuclex.Input.MouseButtons.Left">
            <summary>Left mouse button</summary>
        </member>
        <member name="F:Nuclex.Input.MouseButtons.Middle">
            <summary>Middle mouse button</summary>
        </member>
        <member name="F:Nuclex.Input.MouseButtons.Right">
            <summary>Right mouse button</summary>
        </member>
        <member name="F:Nuclex.Input.MouseButtons.X1">
            <summary>First extended mouse button</summary>
        </member>
        <member name="F:Nuclex.Input.MouseButtons.X2">
            <summary>Second extended mouse button</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.NoKeyboard">
            <summary>Dummy that takes the place of unfilled keyboard slots</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboard.#ctor">
            <summary>Initializes a new keyboard dummy</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboard.GetState">
            <summary>Retrieves the current state of the keyboard</summary>
            <returns>The current state of the keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboard.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboard.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="E:Nuclex.Input.Devices.NoKeyboard.KeyPressed">
            <summary>Fired when a key has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoKeyboard.KeyReleased">
            <summary>Fired when a key has been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoKeyboard.CharacterEntered">
            <summary>Fired when the user has entered a character</summary>
            <remarks>
              This provides the complete, translated character the user has entered.
              Handling of international keyboard layouts, shift key, accents and
              other special cases is done by Windows according to the current users'
              country and selected keyboard layout.
            </remarks>
        </member>
        <member name="P:Nuclex.Input.Devices.NoKeyboard.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.NoKeyboard.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.ControllerEventArgs">
            <summary>Carries the arguments for the controller detection event</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerEventArgs.#ctor">
            <summary>Initializes a new argument container for keyboard/mouse input</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerEventArgs.#ctor(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>Initializes a new argument container with a controller index</summary>
            <param name="playerIndex">Player whose controller was detected</param>
        </member>
        <member name="F:Nuclex.Input.ControllerEventArgs.playerIndex">
            <summary>Index of the detected controller</summary>
        </member>
        <member name="P:Nuclex.Input.ControllerEventArgs.PlayerIndex">
            <summary>Index of the controller on which a button was pressed</summary>
            <remarks>
              If this is null, the player pressed a button/key on his mouse/keyboard.
            </remarks>
        </member>
        <member name="T:Nuclex.Input.WindowMessageInterceptorTest">
            <summary>Unit tests for the window message interceptor</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.Setup">
            <summary>Called once before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.Teardown">
            <summary>Called once after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.TestConstructor">
            <summary>Verifies that the constructor of the interceptor is working</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.TestGetDialogCode">
            <summary>Checks whether the dialog code is adjusted by the interceptor</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.TestKeyPressMessage">
            <summary>Verifies that the WM_KEYDOWN message is intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.TestKeyReleaseMessage">
            <summary>Verifies that the WM_KEYDOWN message is intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.TestCharacterEnteredMessage">
            <summary>Verifies that the WM_CHAR message is intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.TestMouseMoveMessage">
            <summary>Verifies that the WM_MOUSEMOVE message is intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.TestMouseButtonPressedMessage(Nuclex.Input.UnsafeNativeMethods.WindowMessages,System.Int32,Nuclex.Input.MouseButtons)">
            <summary>Verifies that the WM_*BUTTONDOWN messages are intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.TestMouseButtonReleasedMessage(Nuclex.Input.UnsafeNativeMethods.WindowMessages,System.Int32,Nuclex.Input.MouseButtons)">
            <summary>Verifies that the WM_*BUTTONUP messages are intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.TestMouseWheelMessage">
            <summary>Verifies that WM_MOUSEWHEEL messages are intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.TestMouseLeaveMessage">
            <summary>Verifies that WM_MOUSELEAVE messages are intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.sendMessage(Nuclex.Input.UnsafeNativeMethods.WindowMessages,System.Int32,System.Int32)">
            <summary>Sends a message to the game's window</summary>
            <param name="message">Message that will be sent</param>
            <param name="wParam">Value for the message's wParam</param>
            <param name="lParam">Value for the message's lParam</param>
            <returns>The value returned by the window procedure for the message</returns>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.mockMouseSubscriber">
            <summary>
              Mocks a mouse message subscriber and registers it to the interceptor's events
            </summary>
            <returns>The new mouse message subscriber</returns>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.mockKeyboardSubscriber">
            <summary>
              Mocks a keyboard message subscriber and registers it to the interceptor's events
            </summary>
            <returns>The new keyboard message subscriber</returns>
        </member>
        <member name="F:Nuclex.Input.WindowMessageInterceptorTest.MouseButtonDownMessage">
            <summary>Called when a mouse button has been pressed</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageInterceptorTest.MouseButtonUpMessage">
            <summary>Called when a mouse button has been released</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageInterceptorTest.form">
            <summary>Form used to test interception of window messages</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageInterceptorTest.interceptor">
            <summary>Message interceptor for the form</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageInterceptorTest.mockery">
            <summary>Creates dynamic mock objects based on interfaces</summary>
        </member>
        <member name="T:Nuclex.Input.WindowMessageInterceptorTest.IKeyboardMessageSubscriber">
            <summary>Subscriber to keyboard messages arriving at the window</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.IKeyboardMessageSubscriber.KeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key is pressed on the keyboard</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.IKeyboardMessageSubscriber.KeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been released</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.IKeyboardMessageSubscriber.CharacterEntered(System.Char)">
            <summary>Called when the user has entered a character</summary>
            <param name="character">Character the user has entered</param>
        </member>
        <member name="T:Nuclex.Input.WindowMessageInterceptorTest.IMouseMessageSubscriber">
            <summary>Subscriber to mouse messages arriving at the window</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.IMouseMessageSubscriber.MouseButtonPressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed</summary>
            <param name="buttons">Buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.IMouseMessageSubscriber.MouseButtonReleased(Nuclex.Input.MouseButtons)">
            <summary>Called when a button on the mouse has been released</summary>
            <param name="buttons">Button that has been released</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.IMouseMessageSubscriber.MouseMoved(System.Single,System.Single)">
            <summary>Called when the mouse cursor has been moved</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptorTest.IMouseMessageSubscriber.MouseWheelRotated(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks the mouse wheel was rotated</param>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedMouse">
            <summary>Code-controllable mouse for unit testing</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.#ctor">
            <summary>Initializes a new window message based mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.MoveTo(System.Single,System.Single)">
            <summary>Moves the mouse cursor to the specified location</summary>
            <param name="x">X coordinate the mouse cursor will be moved to</param>
            <param name="y">Y coordinate the mouse cursor will be moved to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.Press(Nuclex.Input.MouseButtons)">
            <summary>Presses a button on the mouse</summary>
            <param name="button">Button that will be pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.Release(Nuclex.Input.MouseButtons)">
            <summary>Buffers a button release on the mouse</summary>
            <param name="button">Button that will be released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.RotateWheel(System.Single)">
            <summary>Rotates the mouse wheel by the specified number of ticks</summary>
            <param name="ticks">Number of ticks the mouse wheel will be rotated</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.Attach">
            <summary>Attaches (connects) the game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.Detach">
            <summary>Detaches (disconnects) the game pad</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedMouse.isAttached">
            <summary>Whether the game pad is attached</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedMouse.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedMouse.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods">
            <summary>Provides access to some P/Invoke-imported native methods</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.DLGC_WANTCHARS">
            <summary>
              Flag returned by a window in response to WM_GETDLGCODE to indicate that it
              is interested in receiving WM_CHAR messages
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.DLGC_WANTALLKEYS">
            <summary>
              Flag returned by a window in response to WM_GETDLGCODE to indicate that it
              wants to process all keyboard input from the user
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.TME_LEAVE">
            <summary>
              The caller wants leave notification. Notification is delivered as
              a WM_MOUSELEAVE message.
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WM_KEYDOWN_WASDOWN">
            <summary>
              Bit in lparam that indicates whether a WM_KEYDOWN is being generated due
              to the keyboard's auto-repeat
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.HID_USAGE_PAGE_GENERIC">
            <summary>Category for generic HID devices</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.HID_USAGE_GENERIC_MOUSE">
            <summary>Generic HID mouse device</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RID_INPUT">
            <summary>Command ID for retrieving input data</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RIDEV_INPUTSINK">
            <summary>
              Enables the caller to receive the input even when the caller is not in
              the foreground. Note that WindowHandle must be specified.
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RIDEV_CAPTUREMOUSE">
            <summary>Mouse button click does not activate the other window</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RIDEV_NOLEGACY">
            <summary>Prevents any devices from generating legacy messages</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RIM_TYPEMOUSE">
            <summary>Indicates that the retrieve raw input came from the mouse</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MOUSE_MOVE_RELATIVE">
            <summary>Mouse movement is specified as offset to the last position</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MOUSE_MOVE_ABSOLUTE">
            <summary>Mouse movement is specified in absolute coordinates</summary>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.RegisterRawInputDevices(Nuclex.Input.UnsafeNativeMethods.RAWINPUTDEVICE@,System.Int32,System.Int32)">
            <summary>Registers a raw input device</summary>
            <param name="rawInputDevice">Array of raw input devices</param>
            <param name="deviceCount">Number of devices</param>
            <param name="size">Size of the RAWINPUTDEVICE structure</param>
            <returns>TRUE if successful, FALSE if not</returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.GetRawInputData(System.IntPtr,System.Int32,Nuclex.Input.UnsafeNativeMethods.RAWINPUT@,System.Int32@,System.Int32)">
            <summary>Retrieves the raw input from the specified device</summary>
            <param name="rawInputHandle">
              Handle to the raw input structure (provided by WM_INPUT)
            </param>
            <param name="command">Command flag indicating what will be retrieved</param>
            <param name="data">Receives the data that comes from the RAWINPUT structure</param>
            <param name="size">
              Size of the data buffer, receives amount of data retrieved
            </param>
            <param name="headerSize">Size, in bytes, of the RAWINPUTHEADER structure</param>
            <returns>
              If pData is NULL and the function is successful, the return value is 0.
              If pData is not NULL and the function is successful, the return value is
              the number of bytes copied into pData. -1 on error.
            </returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.TrackMouseEvent(Nuclex.Input.UnsafeNativeMethods.TRACKMOUSEEVENT@)">
            <summary>
              Posts messages when the mouse pointer leaves a window or hovers over a window
              for a specified amount of time
            </summary>
            <param name="eventTrack">
              Pointer to a TRACKMOUSEEVENT structure that contains tracking information
            </param>
            <returns>If the function succeeds, the return value is nonzero</returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.MapVirtualKey(System.UInt32,System.UInt32)">
            <summary>
              Translates (maps) a virtual-key code into a scan code or character value,
              or translates a scan code into a virtual-key code
            </summary>
            <param name="code">Virtual-key code or scan code for a key</param>
            <param name="mapType">Translation to perform</param>
            <returns>
              A scan code, virtual key code or character value depending on
              the translation peformed. Zero if no translation could be performed.
            </returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.PostMessage(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
              Places (posts) a message in the message queue associated with the thread that
              created the specified window and returns without waiting for the thread to
              process the message.
            </summary>
            <param name="windowHandle">
              Handle to the window whose window procedure is to receive the message
            </param>
            <param name="messageId">Specifies the message to be posted</param>
            <param name="wParam">Specifies additional message-specific information</param>
            <param name="lParam">Specifies additional message-specific information</param>
            <returns></returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.SendMessage(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>Sends the specified message to a window or windows</summary>
            <param name="windowHandle">
              Handle to the window whose window procedure will receive the message
            </param>
            <param name="messageId">Specifies the message to be sent</param>
            <param name="wParam">Specifies additional message-specific information</param>
            <param name="lParam">Specifies additional message-specific information</param>
            <returns>Depends on the message being sent</returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.LoadLibrary(System.String)">
            <summary>
              Loads the specified module into the address space of the calling process
            </summary>
            <param name="filename">Name of the module that will be loaded</param>
            <returns>
              If successful, the handle of the loaded module, otherwise NULL
            </returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.FreeLibrary(System.IntPtr)">
            <summary>
              Frees the loaded dynamic-link library (DLL) module and, if necessary,
              decrements its reference count
            </summary>
            <param name="moduleHandle">A handle to the loaded library module</param>
            <returns>Any non-zero value on success, otherwise zero</returns>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.MapTypes">
            <summary>Translation to perform</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MapTypes.VirtualKeyToScanCode">
            <summary>
              Virtual-key code is translated into a scan code. Does not distinguish
              between left- and right-hand keys.
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MapTypes.ScanCodeToVirtualKey">
            <summary>
              Scan code is translated into a virtual-key code that does not distinguish
              between left- and right-hand keys.
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MapTypes.VirtualKeyToChar">
            <summary>
              Virtual-key code is translated into an unshifted character value
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MapTypes.ScanCodeToVirtualKeyEx">
            <summary>
              Scan code is translated into a virtual-key code that distinguishes between
              left- and right-hand keys.
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MapTypes.VirtualKeytoScanCodeEx">
            <summary>
              Virtual-key code is translated into a scan code. Distinguishes between
              left- and right-hand keys.
            </summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.WindowMessages">
            <summary>List of window message relevant to the input capturer</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_GETDLGCODE">
            <summary>Sent to a window to ask which types of input it processes</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_INPUT">
            <summary>Transmits raw input data to the window</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_KEYDOWN">
            <summary>Indicates that the user has pressed a key on the keyboard</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_KEYUP">
            <summary>Indicates that the user has released a key on the keyboard</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_CHAR">
            <summary>Indicates that the user has entered text</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_UNICHAR">
            <summary>Indicates that the user has entered text (UTF-32 variant)</summary>
            <remarks>
              This is only required if the window is an ANSI window (created by
              CreateWindowA() and not reset to unicode). In this case, windows will
              send WM_CHAR with ANSI characters and WM_UNICHAR with UTF-32 characters.
            </remarks>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MOUSEMOVE">
            <summary>Indicates that the mouse cursor has been moved</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_LBUTTONDOWN">
            <summary>Indicates that the left mouse button was pressed down</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_LBUTTONUP">
            <summary>Indicates that the left mouse button was released again</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_LBUTTONDBLCLK">
            <summary>Indicates that the left mouse button was double-clicked</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_RBUTTONDOWN">
            <summary>Indicates that the right mouse button was pressed down</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_RBUTTONUP">
            <summary>Indicates that the right mouse button was released again</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_RBUTTONDBLCLK">
            <summary>Indicates that the right mouse button was double-clicked</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MBUTTONDOWN">
            <summary>Indicates that the middle mouse button was pressed down</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MBUTTONUP">
            <summary>Indicates that the middle mouse button was released again</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MBUTTONDBLCLK">
            <summary>Indicates that the middle mouse button was double-clicked</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MOUSEHWHEEL">
            <summary>Indicates that the mouse wheel has been rotated</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_XBUTTONDOWN">
            <summary>Indicates that an extended mouse button was pressed down</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_XBUTTONUP">
            <summary>Indicates that an extended mouse button was released again</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_XBUTTONDBLCLK">
            <summary>Indicates that an extended mouse button was double-clicked</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MOUSEHWHEEL_TILT">
            <summary>Indicates that the mouse wheel has been rotated or tilted</summary>
            <remarks>
              This window message is only supported by Windows Vista. Mouse drivers may,
              however, emulate it on Windows XP by directly communicating with
              the low-level driver and injecting this message into the active window.
            </remarks>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MOUSELEAVE">
            <summary>Sent to the window when the mouse cursor has left it</summary>
            <remarks>
              To receive this message, the window has to set up the notification using
              the TrackMouseEvent() function when the mouse enters the window.
            </remarks>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.RAWINPUTDEVICE">
            <summary>Identifies a raw input device</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTDEVICE.UsagePage">
            <summary>Top level collection Usage page for the raw input device</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTDEVICE.Usage">
            <summary>Top level collection Usage for the raw input device</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTDEVICE.Flags">
            <summary>
              Mode flag that specifies how to interpret the information provided
              by UsagePage and Usage
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTDEVICE.WindowHandle">
            <summary>
              Handle to the target window. If NULL it follows the keyboard focus
            </summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.TRACKMOUSEEVENT">
            <summary>
              Used by the TrackMouseEvent function to track when the mouse pointer leaves
              a window or hovers over a window
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.TRACKMOUSEEVENT.structureSize">
            <summary>The size of the TRACKMOUSEEVENT structure</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.TRACKMOUSEEVENT.flags">
            <summary>Specifies the services requested</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.TRACKMOUSEEVENT.trackWindowHandle">
            <summary>Specifies a handle to the window to track</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.TRACKMOUSEEVENT.hoverTime">
            <summary>
              Specifies the hover time-out (if TME_HOVER was specified in dwFlags),
              in milliseconds
            </summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.RAWINPUTHEADER">
            <summary>Header information that is part of the raw input data</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTHEADER.Type">
            <summary>Type of device the input is coming from.</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTHEADER.Size">
            <summary>Size of the packet of data.</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTHEADER.Device">
            <summary>Handle to the device sending the data.</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTHEADER.wParam">
            <summary>wParam from the window message.</summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE">
            <summary>
            Value type for raw input from a mouse.
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.Flags">
            <summary>Specifies what kind of data is being transmitted</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.ButtonData">
            <summary>
              If the mouse wheel is rotated, this will contain the delta amount
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.ButtonFlags">
            <summary>State transition of the mouse buttons</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.RawButtons">
            <summary>Raw state of the mouse buttons</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.LastX">
            <summary>Position or offset in X direction, depending on the flags</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.LastY">
            <summary>Position or offset in Y direction, depending on the flags</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.ExtraInformation">
            <summary>Additional device-specific informations about the event</summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.RAWHID">
            <summary>
              Describes the format of the raw input from a Human Interface Device
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWHID.Size">
            <summary>Size, in bytes, of the HID data</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWHID.Count">
            <summary>Number of HID inputs contained in the data</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWHID.Data">
            <summary>Raw input data as an array of bytes</summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.RAWINPUT">
            <summary>Contains the raw input from a device</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUT.Header">
            <summary>Describes the data contained in the event</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUT.Mouse">
            <summary>Contains mouse-specific data if this is a mouse event</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUT.HID">
            <summary>Contains generic input data if this is an HID</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.NoMouseTest">
            <summary>Unit tests for the dummy mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestConstructor">
            <summary>Verifies that the constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestIsAttached">
            <summary>Verifies that the keyboard dummy is not attached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestName">
            <summary>Verifies that the keyboard dummy's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestTakeSnapshot">
            <summary>Verifies that the TakeSnapshot() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestUpdate">
            <summary>Verifies that the Update() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestEvents">
            <summary>Tests whether the no mouse class' events can be subscribed</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.mouseMoved(System.Single,System.Single)">
            <summary>Dummy subscriber for the MouseMoved event</summary>
            <param name="x">X coordinate of the mouse cursor</param>
            <param name="y">Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.mouseButton(Nuclex.Input.MouseButtons)">
            <summary>Dummy subscriber for the MouseButtonPressed/Released event</summary>
            <param name="buttons">Buttons that have been pressed/released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.mouseWheel(System.Single)">
            <summary>Dummy subscriber for the MouseWheelRotated event</summary>
            <param name="ticks">Ticks the wheel has been rotated</param>
        </member>
        <member name="T:Nuclex.Input.Devices.NoGamePad">
            <summary>Dummy that takes the place of unfilled player slots</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePad.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePad.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="E:Nuclex.Input.Devices.NoGamePad.ButtonPressed">
            <summary>Called when one or more buttons on the game pad have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoGamePad.ButtonReleased">
            <summary>Called when one or more buttons on the game pad have been released</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.NoGamePad.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.NoGamePad.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MouseMoveDelegate">
            <summary>Delegate used to report movement of the mouse cursor</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="T:Nuclex.Input.Devices.MouseButtonDelegate">
            <summary>
              Delegate used to report a press or released of one or more mouse buttons
            </summary>
            <param name="buttons">Button or buttons that have been pressed or released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.MouseWheelDelegate">
            <summary>Delegate used to report a rotation of the mouse wheel</summary>
            <param name="ticks">Number of ticks the mouse wheel has been rotated</param>
        </member>
        <member name="T:Nuclex.Input.Devices.NoMouse">
            <summary>Dummy that takes the place on unfilled mouse slots</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouse.#ctor">
            <summary>Initializes a new window message based mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouse.GetState">
            <summary>Retrieves the current state of the mouse</summary>
            <returns>The current state of the mouse</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouse.MoveTo(System.Single,System.Single)">
            <summary>Moves the mouse cursor to the specified location</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouse.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouse.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="E:Nuclex.Input.Devices.NoMouse.MouseMoved">
            <summary>Fired when the mouse has been moved</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoMouse.MouseButtonPressed">
            <summary>Fired when one or more mouse buttons have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoMouse.MouseButtonReleased">
            <summary>Fired when one or more mouse buttons have been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoMouse.MouseWheelRotated">
            <summary>Fired when the mouse wheel has been rotated</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.NoMouse.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.NoMouse.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.NoKeyboardTest">
            <summary>Unit tests for the keyboard dummy</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestConstructor">
            <summary>Verifies that the constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestIsAttached">
            <summary>Verifies that the keyboard dummy is not attached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestName">
            <summary>Verifies that the keyboard dummy's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestTakeSnapshot">
            <summary>Verifies that the TakeSnapshot() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestUpdate">
            <summary>Verifies that the Update() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestEvents">
            <summary>Tests whether the no keyboard class' events can be subscribed</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.key(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Dummy subscriber for KeyPressed/Released events</summary>
            <param name="key">Key that has been pressed/released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.characterEntered(System.Char)">
            <summary>Dummy subscriber for the CharacterEntered event</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="T:Nuclex.Input.IInputService">
            <summary>Provides access to the game's input devices</summary>
            <remarks>
              This interface provides a uniform way to access all input devices available
              to the system. It also allows XNA games to interface with standard game pads
              and joysticks through DirectInput.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.IInputService.GetMouse">
            <summary>Returns the primary mouse input device</summary>
            <returns>The primary mouse</returns>
        </member>
        <member name="M:Nuclex.Input.IInputService.GetKeyboard">
            <summary>Returns the keyboard on a PC</summary>
            <returns>The keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.IInputService.GetKeyboard(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the chat pad for the specified player</summary>
            <param name="playerIndex">Player whose chat pad will be returned</param>
            <returns>The chat pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.IInputService.GetGamePad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
            <remarks>
              This will only return the XINPUT devices (aka XBox 360 controllers)
              attached. Any standard game pads attached to a PC can only be
              returned through the ExtendedPlayerIndex overload where they will
              take the places of game pads for player 5 and upwards.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.IInputService.GetGamePad(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.IInputService.Update">
            <summary>Updates the state of all input devices</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will
                query the state of all input devices immediately, raising events
                for any changed states. This way, you can ignore the entire
                snapshot system if you just want basic input device access.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state of all active devices.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.IInputService.TakeSnapshot">
            <summary>Takes a snapshot of the current state of all input devices</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="P:Nuclex.Input.IInputService.Keyboards">
            <summary>All keyboards known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.IInputService.Mice">
            <summary>All mice known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.IInputService.GamePads">
            <summary>All game pads known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.IInputService.SnapshotCount">
            <summary>Number of snapshots currently in the queue</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.WindowMessageKeyboardTest">
            <summary>Unit tests for the window message based keyboard</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageKeyboardTest.TestIsAttached">
            <summary>Verifies that the IsAttached property is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageKeyboardTest.TestName">
            <summary>Verifies that the IsAttached property is working</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.WindowMessageKeyboardTest.TestKeyboardMessageSource">
            <summary>Dummy implementation of a keyboard message source</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.IKeyboardMessageSource">
            <summary>
              Sends out notifications for intercepted window messages related to the keyboard
            </summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IKeyboardMessageSource.KeyPressed">
            <summary>Triggered when a key has been pressed down</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IKeyboardMessageSource.KeyReleased">
            <summary>Triggered when a key has been released again</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IKeyboardMessageSource.CharacterEntered">
            <summary>Triggered when the user has entered a character</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageKeyboardTest.TestKeyboardMessageSource.KeyPressed">
            <summary>Triggered when a key has been pressed down</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageKeyboardTest.TestKeyboardMessageSource.KeyReleased">
            <summary>Triggered when a key has been released again</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageKeyboardTest.TestKeyboardMessageSource.CharacterEntered">
            <summary>Triggered when the user has entered a character</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedKeyboard">
            <summary>Code-controllable keyboard for unit testing</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedKeyboard">
            <summary>Keyboard that buffers key presses until Update() is called</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.#ctor">
            <summary>Initialize a new buffered keyboard device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.GetState">
            <summary>Retrieves the current state of the keyboard</summary>
            <returns>The current state of the keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.OnKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Records a key press in the event queue</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.OnKeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Records a key release in the event queue</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.OnCharacterEntered(System.Char)">
            <summary>Records a character in the event queue</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.BufferKeyPress(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Records a key press in the event queue</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.BufferKeyRelease(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Records a key release in the event queue</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.BufferCharacterEntry(System.Char)">
            <summary>Records a character in the event queue</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.queuedEvents">
            <summary>Keyboard events waiting to be processed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.current">
            <summary>Current state of the keyboard</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedKeyboard.KeyPressed">
            <summary>Fired when a key has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedKeyboard.KeyReleased">
            <summary>Fired when a key has been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedKeyboard.CharacterEntered">
            <summary>Fired when the user has entered a character</summary>
            <remarks>
              This provides the complete, translated character the user has entered.
              Handling of international keyboard layouts, shift key, accents and
              other special cases is done by Windows according to the current users'
              country and selected keyboard layout.
            </remarks>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedKeyboard.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedKeyboard.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedKeyboard.EventType">
            <summary>Types of event the buffered keyboard can queue</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.EventType.KeyPress">
            <summary>A key has been pressed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.EventType.KeyRelease">
            <summary>A key has been released</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.EventType.Character">
            <summary>A character has been entered</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.EventType.Snapshot">
            <summary>A snapshot was taken at this point in time</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent">
            <summary>Stores the properties of a keyboard event</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.KeyPress(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Creates a new keyboard event for a key press</summary>
            <param name="key">Key that has been pressed</param>
            <returns>The new keyboard event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.KeyRelease(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Creates a new keyboard event for a key release</summary>
            <param name="key">Key that has been released</param>
            <returns>The new keyboard event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.CharacterEntry(System.Char)">
            <summary>Creates a new keyboard event for an entered character</summary>
            <param name="character">Character that has been entered</param>
            <returns>The new keyboard event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.Snapshot">
            <summary>Creates a new keyboard event for a snapshot point</summary>
            <returns>The new keyboard event</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.EventType">
            <summary>Type of the event</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.Key">
            <summary>The key that was pressed or released</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.Character">
            <summary>The character that was entered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.#ctor">
            <summary>Initializes a new mocked keyboard</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.Enter(System.Char)">
            <summary>Types the specified character on the keyboard</summary>
            <param name="character">Character that will be typed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.Type(System.String)">
            <summary>Types the specified text on the keyboard</summary>
            <param name="text">Text that will be typed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.Press(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Presses the specified key on the keyboard</summary>
            <param name="key">Key that will be pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.Release(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Releases the specified key on the keyboard</summary>
            <param name="key">Key that will be released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.Attach">
            <summary>Attaches (connects) the game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.Detach">
            <summary>Detaches (disconnects) the game pad</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedKeyboard.isAttached">
            <summary>Whether the game pad is attached</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedKeyboard.keyMap">
            <summary>Maps characters to the keys enumeration</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedKeyboard.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedKeyboard.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputGamePad">
            <summary>Interfaces with a game pad-like controller through DirectInput</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.#ctor(SlimDX.DirectInput.Joystick,Nuclex.Input.CheckAttachedDelegate)">
            <summary>Initializes a new DirectInput-based game pad</summary>
            <param name="joystick">The DirectInput joystick this instance will query</param>
            <param name="checkAttachedDelegate">
              Delegate through which the instance can check if the device is attached
            </param>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.queryState">
            <summary>Tries to retrieve the current state of the input device</summary>
            <returns>True if the state was successfully retrieved</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePad.joystick">
            <summary>The DirectInput joystick wrapped by this instance</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePad.checkAttachedDelegate">
            <summary>
              Delegate through which the instance can check if the device is attached
            </summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePad.currentlyAcquired">
            <summary>Whether the device should currently be in the acquired state</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePad.currentJoystickState">
            <summary>The current state as provided by DirectInput</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePad.states">
            <summary>Snapshots of the game pad state waiting to be processed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePad.converter">
            <summary>Converts joystick states into game pad states</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePad.current">
            <summary>Currently published game pad state</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.DirectInputGamePad.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.DirectInputGamePad.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.InputManager">
            <summary>Manages and polls input devices</summary>
        </member>
        <member name="M:Nuclex.Input.InputManager.#ctor">
            <summary>Initializes a new input manager</summary>
            <remarks>
              This overload is offered for convenience and takes the window handle
              from XNA's Mouse class. It will only work if your game is either based
              on the XNA Game class or if you assign the Mouse.WindowHandle
              property sourself.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.InputManager.#ctor(System.IntPtr)">
            <summary>Initializes a new input manager</summary>
            <param name="windowHandle">Handle of the game's main window</param>
        </member>
        <member name="M:Nuclex.Input.InputManager.#ctor(Microsoft.Xna.Framework.GameServiceContainer)">
            <summary>Initializs a new input manager</summary>
            <param name="services">Game service container the manager registers to</param>
        </member>
        <member name="M:Nuclex.Input.InputManager.#ctor(Microsoft.Xna.Framework.GameServiceContainer,System.IntPtr)">
            <summary>Initializs a new input manager</summary>
            <param name="services">Game service container the manager registers to</param>
            <param name="windowHandle">Handle of the game's main window</param>
        </member>
        <member name="M:Nuclex.Input.InputManager.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.InputManager.GetMouse">
            <summary>Returns the primary mouse input device</summary>
            <returns>The primary mouse</returns>
        </member>
        <member name="M:Nuclex.Input.InputManager.GetKeyboard">
            <summary>Returns the keyboard on a PC</summary>
            <returns>The keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.InputManager.GetKeyboard(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the chat pad for the specified player</summary>
            <param name="playerIndex">Player whose chat pad will be returned</param>
            <returns>The chat pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.InputManager.GetGamePad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
            <remarks>
              This will only return the XINPUT devices (aka XBox 360 controllers)
              attached. Any standard game pads attached to a PC can only be
              returned through the ExtendedPlayerIndex overload where they will
              take the places of game pads for player 5 and upwards.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.InputManager.GetGamePad(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.InputManager.Update">
            <summary>Updates the state of all input devices</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will
                query the state of all input devices immediately, raising events
                for any changed states. This way, you can ignore the entire
                snapshot system if you just want basic input device access.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state of all active devices.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.InputManager.TakeSnapshot">
            <summary>Takes a snapshot of the current state of all input devices</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.InputManager.OnUpdateOrderChanged">
            <summary>Fires the UpdateOrderChanged event</summary>
        </member>
        <member name="M:Nuclex.Input.InputManager.Microsoft#Xna#Framework#IGameComponent#Initialize">
            <summary>Only exists to implement IGameComponent</summary>
        </member>
        <member name="M:Nuclex.Input.InputManager.Microsoft#Xna#Framework#IUpdateable#Update(Microsoft.Xna.Framework.GameTime)">
            <summary>Updates the state of all input devices</summary>
            <param name="gameTime">Not used</param>
        </member>
        <member name="M:Nuclex.Input.InputManager.setupGamePads">
            <summary>Sets up the collection of available game pads</summary>
        </member>
        <member name="M:Nuclex.Input.InputManager.setupMouse">
            <summary>Sets up the collection of available mice</summary>
        </member>
        <member name="M:Nuclex.Input.InputManager.setupKeyboards">
            <summary>Sets up the collection of available game keyboards</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.directInputManager">
            <summary>Manages DirectInput, if DirectInput is installed</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.windowMessageInterceptor">
            <summary>Intercepts input-related messages to XNA's main window</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.gamePads">
            <summary>Collection of all game pads known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.mice">
            <summary>Collection of all mice known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.keyboards">
            <summary>Collection of all keyboards known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.snapshotCount">
            <summary>Number of state snap shots currently queued</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.updateOrder">
            <summary>
              Controls the order in which this game component is updated relative
              to other game components.
            </summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.gameServices">
            <summary>Game service container, saved to unregister on dispose</summary>
        </member>
        <member name="E:Nuclex.Input.InputManager.UpdateOrderChanged">
            <summary>Fired when the UpdateOrder property changes its  value</summary>
        </member>
        <member name="E:Nuclex.Input.InputManager.EnabledChanged">
            <summary>Fired when the Enabled property changes its value</summary>
        </member>
        <member name="P:Nuclex.Input.InputManager.Keyboards">
            <summary>All keyboards known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.InputManager.Mice">
            <summary>All mice known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.InputManager.GamePads">
            <summary>All game pads known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.InputManager.SnapshotCount">
            <summary>Number of snapshots currently in the queue</summary>
        </member>
        <member name="P:Nuclex.Input.InputManager.UpdateOrder">
            <summary>
              Indicates when the game component should be updated relative to other game
              components. Lower values are updated first.
            </summary>
        </member>
        <member name="P:Nuclex.Input.InputManager.Microsoft#Xna#Framework#IUpdateable#Enabled">
            <summary>Whether the component is currently enabled</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.KeyboardKeyEventDelegate">
            <summary>Delegate used to report a keyboard event</summary>
            <param name="key">Key that was pressed or released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.KeyboardCharacterEventDelegate">
            <summary>Delegate used to report a keyboard event</summary>
            <param name="character">Character that ha been entered</param>
        </member>
        <member name="T:Nuclex.Input.Devices.WindowMessageKeyboard">
            <summary>Interfaces with a PC keyboard via window messages</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageKeyboard.#ctor(Nuclex.Input.Devices.IKeyboardMessageSource)">
            <summary>Initialize a new window message-based keyboard device</summary>
            <param name="messageSource">Source the window messages are obtained from</param>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageKeyboard.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageKeyboard.bufferKeyPressDelegate">
            <summary>Delegate for the keyPressed() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageKeyboard.bufferKeyReleaseDelegate">
            <summary>Delegate for the keyReleased() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageKeyboard.bufferCharacterEntryDelegate">
            <summary>Delegate for the characterEntered() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageKeyboard.messageSource">
            <summary>Window message source the instance is currently subscribed to</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.WindowMessageKeyboard.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.WindowMessageKeyboard.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedGamePad">
            <summary>Code-controllable game pad for unit testing</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.#ctor">
            <summary>Initializes a new mocked game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.Press(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Presses the specified buttons on the game pad</summary>
            <param name="buttons">Buttons that will be pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.Release(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Releases the specified buttons on the game pad</summary>
            <param name="buttons">Buttons that will be released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.MoveLeftThumbStick(System.Single,System.Single)">
            <summary>Moves the left thumb stick to the specified position</summary>
            <param name="x">X coordinate of the thumb stick's position</param>
            <param name="y">Y coordinate of the thumb stick's position</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.MoveRightThumbStick(System.Single,System.Single)">
            <summary>Moves the right thumb stick to the specified position</summary>
            <param name="x">X coordinate of the thumb stick's position</param>
            <param name="y">Y coordinate of the thumb stick's position</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.PushLeftTrigger(System.Single)">
            <summary>Pushes the left analog trigger to the specified depth</summary>
            <param name="depth">Depth the left analog trigger will be pushed to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.PushRightTrigger(System.Single)">
            <summary>Pushes the right analog trigger to the specified depth</summary>
            <param name="depth">Depth the right analog trigger will be pushed to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.Attach">
            <summary>Attaches (connects) the game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.Detach">
            <summary>Detaches (disconnects) the game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.buildState">
            <summary>Builds a game pad state from the current settings</summary>
            <returns>The new game pad state</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.states">
            <summary>Snapshots of the game pad state waiting to be processed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.current">
            <summary>Currently published game pad state</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.isAttached">
            <summary>Whether the game pad is attached</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.leftThumbStick">
            <summary>Current position of the left thumb stick</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.rightThumbStick">
            <summary>Current position of the right thumb stick</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.leftTrigger">
            <summary>Current depth the left trigger is pushed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.rightTrigger">
            <summary>Current depth the right trigger is pushed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.buttons">
            <summary>Buttons that are currently pressed on the game pad</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedGamePad.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedGamePad.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedMouseTest">
            <summary>Unit tests for the buffered mouse class</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferButtonPress">
            <summary>Verifies that button presses can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferButtonRelease">
            <summary>Verifies that button releases can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferMouseMovement">
            <summary>Verifies that mouse movements can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferWheelRotation">
            <summary>Verifies that mouse wheel rotations can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.mockSubscriber">
            <summary>Mocks a subscriber for the buffered keyboard</summary>
            <returns>A subscriber registered to the events of the keyboard</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouseTest.mockery">
            <summary>Creates dynamic mock objects for interfaces</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouseTest.mouse">
            <summary>Buffered mouse being tested</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse">
            <summary>Test implementation of a buffered mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.MoveTo(System.Single,System.Single)">
            <summary>Moves the mouse cursor to the specified location</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.BufferButtonPress(Nuclex.Input.MouseButtons)">
            <summary>Records a mouse button press in the event queue</summary>
            <param name="buttons">Buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.BufferButtonRelease(Nuclex.Input.MouseButtons)">
            <summary>Records a mouse button release in the event queue</summary>
            <param name="buttons">Buttons that have been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.BufferWheelRotation(System.Single)">
            <summary>Records a mouse wheel rotation in the event queue</summary>
            <param name="ticks">Ticks the mouse wheel has been rotated</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.BufferCursorMovement(System.Single,System.Single)">
            <summary>Records a mouse cursor movement in the event queue</summary>
            <param name="x">X coordinate the mouse cursor has been moved to</param>
            <param name="y">Y coordinate the mouse cursor has been moved to</param>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedMouseTest.IMouseSubscriber">
            <summary>Subscriber to the events of a mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.IMouseSubscriber.ButtonPressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed</summary>
            <param name="buttons">Button which has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.IMouseSubscriber.ButtonReleased(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released</summary>
            <param name="buttons">Button which has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.IMouseSubscriber.Moved(System.Single,System.Single)">
            <summary>Called when the mouse cursor has been moved</summary>
            <param name="x">X coordinate of the mouse cursor</param>
            <param name="y">Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.IMouseSubscriber.WheelRotated(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks the mouse wheel was rotated</param>
        </member>
        <member name="T:Nuclex.Input.Devices.XnaGamePad">
            <summary>Interfaces with an XBox 360 controller via XNA (XINPUT)</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePad.#ctor(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Initializes a new XNA-based keyboard device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePad.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePad.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaGamePad.playerIndex">
            <summary>Index of the player this device represents</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaGamePad.states">
            <summary>Snapshots of the game pad state waiting to be processed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaGamePad.current">
            <summary>Currently published game pad state</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.XnaGamePad.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.XnaGamePad.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.WindowMessageMouseTest">
            <summary>Unit tests for the window message based mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageMouseTest.TestIsAttached">
            <summary>Verifies that the IsAttached property is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageMouseTest.TestName">
            <summary>Verifies that the IsAttached property is working</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.WindowMessageMouseTest.TestMouseMessageSource">
            <summary>Dummy implementation of a mouse message source</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageMouseTest.TestMouseMessageSource.MouseButtonPressed">
            <summary>Triggered when a mouse button has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageMouseTest.TestMouseMessageSource.MouseButtonReleased">
            <summary>Triggered when a mouse button has been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageMouseTest.TestMouseMessageSource.MouseMoved">
            <summary>Triggered when the mouse has been moved</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageMouseTest.TestMouseMessageSource.MouseWheelRotated">
            <summary>Triggered when the mouse wheel has been rotated</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.NoGamePadTest">
            <summary>Unit tests for the game pad dummy</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestConstructor">
            <summary>Verifies that the constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestIsAttached">
            <summary>Verifies that the game pad dummy is not attached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestName">
            <summary>Verifies that the game pad dummy's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestTakeSnapshot">
            <summary>Verifies that the TakeSnapshot() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestUpdate">
            <summary>Verifies that the Update() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestEvents">
            <summary>Tests whether the no game pad class' events can be subscribed</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.button(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Dummy subscriber for the ButtonPressed/Released event</summary>
            <param name="buttons">Buttons that have been pressed/released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.ModifiableKeyboardStateTest">
            <summary>Unit tests for the modifiable keyboard state</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedKeyboardTest">
            <summary>Unit tests for the mocked keyboard</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestAttachAndDetach">
            <summary>Verifies that the game pad can be attached and detached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestName">
            <summary>Verifies that the mocked keyboard's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestPressKey">
            <summary>Verifies that key presses can be simulation</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestReleaseKey">
            <summary>Verifies that key releases can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestEnterCharacter">
            <summary>Verifies that character entries can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestTypeText">
            <summary>Verifies that text entries can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.mockSubscriber">
            <summary>Mocks a subscriber for the buffered keyboard</summary>
            <returns>A subscriber registered to the events of the keyboard</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedKeyboardTest.mockery">
            <summary>Creates dynamic mock objects for interfaces</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedKeyboardTest.keyboard">
            <summary>Buffered keyboard being tested</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedKeyboardTest.IKeyboardSubscriber">
            <summary>Subscriber to the </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.IKeyboardSubscriber.KeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key has been pressed</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.IKeyboardSubscriber.KeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key has been released</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.IKeyboardSubscriber.CharacterEntered(System.Char)">
            <summary>Called when a character has been entered</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="T:Nuclex.Input.ControllerDetector">
            <summary>Detects which controller the player is using</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.#ctor(Nuclex.Input.IInputService)">
            <summary>Initializes a new controller detector</summary>
            <param name="inputService">
              Input service the detector uses to find out the controller
            </param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.Start">
            <summary>Begins monitoring input devices</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.Stop">
            <summary>Stops monitoring input devices</summary>
            <remarks>
              After the detection event was triggered once, this is automatically called.
              You do not need to explicitly call this unless you want to abort detection.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.OnControllerDetected(System.Nullable{Nuclex.Input.ExtendedPlayerIndex})">
            <summary>Fires the ControllerDetected event</summary>
            <param name="playerIndex">Event that will be fired</param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.detected(System.Nullable{Nuclex.Input.ExtendedPlayerIndex})">
            <summary>Called when a key/button press has been detected</summary>
            <param name="playerIndex">Index of the player who pressed a key/button</param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.subscribeAllEvents">
            <summary>Subscribes the detector to all input devices</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.unsubscribeAllEvents">
            <summary>Unsubscribes the detector from all input devices</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.inputService">
            <summary>Input service the detector uses to access the controllers</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.started">
            <summary>Whether the detection is currently running</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.subscribedKeyReporters">
            <summary>Currently subscribed key press reporters</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.subscribedMouseReporters">
            <summary>Currently subscribed mouse button press reporters</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.subscribedGamePadReporters">
            <summary>Currently subscribed game pad button press reporters</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.detectedDelegate">
            <summary>Delegate for the controllerDetected() method</summary>
        </member>
        <member name="E:Nuclex.Input.ControllerDetector.ControllerDetected">
            <summary>
              Called when the player pressed a button on one of the controllers
            </summary>
        </member>
        <member name="T:Nuclex.Input.ControllerDetector.DetectionDelegate">
            <summary>Reports the index of the player who pressed a key/button</summary>
            <param name="playerIndex">Reported player index</param>
        </member>
        <member name="T:Nuclex.Input.ControllerDetector.Reporter">
            <summary>Base class for key/button press reporters</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.Reporter.#ctor(Nuclex.Input.ControllerDetector.DetectionDelegate,System.Nullable{Nuclex.Input.ExtendedPlayerIndex})">
            <summary>Initializes a new reporter</summary>
            <param name="callback">Callback the reporter uses to report</param>
            <param name="playerIndex">Player index the reporter will report</param>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.Reporter.Callback">
            <summary>Callback the reporter invokes on a button/key press</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.Reporter.PlayerIndex">
            <summary>Player index the reporter will provide to the callback</summary>
        </member>
        <member name="T:Nuclex.Input.ControllerDetector.KeyReporter">
            <summary>Reports key presses on a keyboard</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.KeyReporter.#ctor(Nuclex.Input.ControllerDetector.DetectionDelegate,System.Nullable{Nuclex.Input.ExtendedPlayerIndex})">
            <summary>Initializes a new keyboard reporter</summary>
            <param name="callback">Callback the reporter uses to report</param>
            <param name="playerIndex">Player index the reporter will report</param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.KeyReporter.KeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Subscribable callback for a key press</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="T:Nuclex.Input.ControllerDetector.MouseButtonReporter">
            <summary>Reports buttons pressed on a mouse</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.MouseButtonReporter.#ctor(Nuclex.Input.ControllerDetector.DetectionDelegate,System.Nullable{Nuclex.Input.ExtendedPlayerIndex})">
            <summary>Initializes a new mouse reporter</summary>
            <param name="callback">Callback the reporter uses to report</param>
            <param name="playerIndex">Player index the reporter will report</param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.MouseButtonReporter.MouseButtonPressed(Nuclex.Input.MouseButtons)">
            <summary>Subscribable callback for a mouse button press</summary>
            <param name="buttons">Mouse buttons that have been pressed</param>
        </member>
        <member name="T:Nuclex.Input.ControllerDetector.GamePadButtonReporter">
            <summary>Reports buttons pressed on a game pad</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.GamePadButtonReporter.#ctor(Nuclex.Input.ControllerDetector.DetectionDelegate,System.Nullable{Nuclex.Input.ExtendedPlayerIndex})">
            <summary>Initializes a new game pad reporter</summary>
            <param name="callback">Callback the reporter uses to report</param>
            <param name="playerIndex">Player index the reporter will report</param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.GamePadButtonReporter.ButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Subscribable callback for a game pad button press</summary>
            <param name="buttons">Game pad buttons that have been pressed</param>
        </member>
        <member name="T:Nuclex.Input.MockInputManager">
            <summary>Manages a set of fake input devices</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.#ctor">
            <summary>Initializes a new mock input manager</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.#ctor(Microsoft.Xna.Framework.GameServiceContainer)">
            <summary>Initializs a new mock input manager</summary>
            <param name="services">Game service container the manager registers to</param>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.GetMouse">
            <summary>Returns the primary mouse input device</summary>
            <returns>The primary mouse</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.GetKeyboard">
            <summary>Returns the keyboard on a PC</summary>
            <returns>The keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.GetKeyboard(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the chat pad for the specified player</summary>
            <param name="playerIndex">Player whose chat pad will be returned</param>
            <returns>The chat pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.GetGamePad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
            <remarks>
              This will only return the XINPUT devices (aka XBox 360 controllers)
              attached. Any standard game pads attached to a PC can only be
              returned through the ExtendedPlayerIndex overload where they will
              take the places of game pads for player 5 and upwards.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.GetGamePad(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Update">
            <summary>Updates the state of all input devices</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will
                query the state of all input devices immediately, raising events
                for any changed states. This way, you can ignore the entire
                snapshot system if you just want basic input device access.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state of all active devices.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.TakeSnapshot">
            <summary>Takes a snapshot of the current state of all input devices</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#GetMouse">
            <summary>Returns the primary mouse input device</summary>
            <returns>The primary mouse</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#GetKeyboard">
            <summary>Returns the keyboard on a PC</summary>
            <returns>The keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#GetKeyboard(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the chat pad for the specified player</summary>
            <param name="playerIndex">Player whose chat pad will be returned</param>
            <returns>The chat pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#GetGamePad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
            <remarks>
              This will only return the XINPUT devices (aka XBox 360 controllers)
              attached. Any standard game pads attached to a PC can only be
              returned through the ExtendedPlayerIndex overload where they will
              take the places of game pads for player 5 and upwards.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#GetGamePad(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.setupGamePads">
            <summary>Sets up the collection of available game pads</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.setupMouse">
            <summary>Sets up the collection of available mice</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.setupKeyboards">
            <summary>Sets up the collection of available game keyboards</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.snapshotCount">
            <summary>Number of state snap shots currently queued</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.gamePads">
            <summary>Collection of all game pads known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.mice">
            <summary>Collection of all mice known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.keyboards">
            <summary>Collection of all keyboards known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.interfaceGamePads">
            <summary>Collection of all game pads known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.interfaceMice">
            <summary>Collection of all mice known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.interfaceKeyboards">
            <summary>Collection of all keyboards known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.gameServices">
            <summary>Game service container, saved to unregister on dispose</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.Keyboards">
            <summary>All keyboards known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.Mice">
            <summary>All mice known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.GamePads">
            <summary>All game pads known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.SnapshotCount">
            <summary>Number of snapshots currently in the queue</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#Keyboards">
            <summary>All keyboards known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#Mice">
            <summary>All mice known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#GamePads">
            <summary>All game pads known to the system</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.XnaKeyboardTest">
            <summary>Unit tests for the XNA (XINPUT) based chat pad class</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboardTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboardTest.TestIsAttached">
            <summary>Verifies that the game pad can be attached and detached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboardTest.TestName">
            <summary>Verifies that the mocked game pad's name can be retrieved</summary>
        </member>
        <member name="T:Nuclex.Input.GamePadButtonsHelper">
            <summary>Contains helper methods for the GamePadButtons enumeration</summary>
        </member>
        <member name="M:Nuclex.Input.GamePadButtonsHelper.Contains(Microsoft.Xna.Framework.Input.Buttons,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Checks whether buttons are contained in a button flag field</summary>
            <param name="buttons">Button flag field that will be checked</param>
            <param name="button">Buttons for which the method will check</param>
            <returns>True if all specified buttons appear in the flag field</returns>
        </member>
        <member name="T:Nuclex.Input.ExtendedPlayerIndex">
            <summary>Player index enumeration with additional slots for 8 players</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.One">
            <summary>First player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Two">
            <summary>Second player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Three">
            <summary>Third player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Four">
            <summary>Fourth player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Five">
            <summary>Fifth player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Six">
            <summary>Sixth player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Seven">
            <summary>Seventh player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Eight">
            <summary>Eigth player</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadConverterTest">
            <summary>Unit tests for the DirectInput to XNA game pad state converter</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverterTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverterTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverterTest.TestConstructor">
            <summary>Verifies that the constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadConverterTest.requireAttachedJoystick">
            <summary>Requires a joystick to be attached to the system</summary>
            <remarks>
              Requiring hardware for a unit test is a big no-no, but SlimDX' wrappers arent
              all based on funky interfaces, so there's no way to mock the darn thing.
              Adding another layer of abstraction would only mean having no test coverage
              for that layer of abstraction.
            </remarks>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverterTest.directInput">
            <summary>DirectInput interface the game pad will be based on</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadConverterTest.joystick">
            <summary>DirectInput joystick that will be used for testing</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputGamePadTest">
            <summary>Unit tests for the DirectInput-based game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.TestConstructor">
            <summary>Verifies that the constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.TestName">
            <summary>Verifies that the Name method returns the correct result</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.TestAttached(System.Boolean)">
            <summary>Verifies that the IsAttached method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.isAttachedMock(SlimDX.DirectInput.Device)">
            <summary>Reports that a device is attached</summary>
            <param name="device">Not used</param>
            <returns>Always true</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.isNotAttachedMock(SlimDX.DirectInput.Device)">
            <summary>Reports that a device is not attached</summary>
            <param name="device">Not used</param>
            <returns>Always false</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.requireAttachedJoystick">
            <summary>Requires a joystick to be attached to the system</summary>
            <remarks>
              Requiring hardware for a unit test is a big no-no, but SlimDX' wrappers arent
              all based on funky interfaces, so there's no way to mock the darn thing.
              Adding another layer of abstraction would only mean having no test coverage
              for that layer of abstraction.
            </remarks>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePadTest.directInput">
            <summary>DirectInput interface the game pad will be based on</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePadTest.joystick">
            <summary>DirectInput joystick that will be used for testing</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedKeyboardTest">
            <summary>Unit tests for the buffered keyboard class</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferKeyPress">
            <summary>Verifies that key presses can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferKeyRelease">
            <summary>Verifies that key releases can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferCharacterEntry">
            <summary>Verifies that character entries can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.mockSubscriber">
            <summary>Mocks a subscriber for the buffered keyboard</summary>
            <returns>A subscriber registered to the events of the keyboard</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboardTest.mockery">
            <summary>Creates dynamic mock objects for interfaces</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboardTest.keyboard">
            <summary>Buffered keyboard being tested</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferedKeyboard">
            <summary>Test implementation of a buffered keyboard</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferedKeyboard.BufferKeyPress(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Records a key press in the event queue</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferedKeyboard.BufferKeyRelease(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Records a key release in the event queue</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferedKeyboard.BufferCharacterEntry(System.Char)">
            <summary>Records a character in the event queue</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferedKeyboard.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferedKeyboard.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedKeyboardTest.IKeyboardSubscriber">
            <summary>Subscriber to the </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.IKeyboardSubscriber.KeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key has been pressed</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.IKeyboardSubscriber.KeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key has been released</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.IKeyboardSubscriber.CharacterEntered(System.Char)">
            <summary>Called when a character has been entered</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="T:Nuclex.Input.WindowMessageInterceptor">
            <summary>Intercepts input-related messages for another window</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageInterceptor.DlgCodeFlags">
            <summary>Flags that will be added to the result of WM_GETDLGCODE</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptor.#ctor(System.IntPtr)">
            <summary>Initializes a new window message interceptor</summary>
            <param name="windowHandle">
              Handle of the window for which messages will be intercepted
            </param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptor.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptor.WndProc(System.Windows.Forms.Message@)">
            <summary>
              Overridden window message callback used to capture input for the window
            </summary>
            <param name="message">Window message sent to the window</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptor.OnKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Fires the KeyPressed event</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptor.OnKeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Fires the KeyReleased event</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptor.OnCharacterEntered(System.Char)">
            <summary>Fires the CharacterEntered event</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptor.OnMouseButtonPressed(Nuclex.Input.MouseButtons)">
            <summary>Fires the MouseButtonPressed event</summary>
            <param name="buttons">Mouse buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptor.OnMouseButtonReleased(Nuclex.Input.MouseButtons)">
            <summary>Fires the MouseButtonReleased event</summary>
            <param name="buttons">Mouse buttons that have been released</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptor.OnMouseMoved(System.Single,System.Single)">
            <summary>Fires the MouseMoved event</summary>
            <param name="x">New X coordinate of the mouse</param>
            <param name="y">New Y coordinate of the mouse</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageInterceptor.OnMouseWheelRotated(System.Single)">
            <summary>Fires the MouseWheelRotated event</summary>
            <param name="ticks">Number of ticks the mouse wheel has been rotated</param>
        </member>
        <member name="F:Nuclex.Input.WindowMessageInterceptor.mouseEventTrackData">
            <summary>
              Provides Informations about how the mouse cusor should be tracked on
              the window to the TrackMouseEvent() function.
            </summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageInterceptor.trackingMouse">
            <summary>True when the mouse cursor is currently being tracked</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageInterceptor.disposed">
            <summary>True when the object has been disposed</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageInterceptor.KeyPressed">
            <summary>Triggered when a key has been pressed down</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageInterceptor.KeyReleased">
            <summary>Triggered when a key has been released again</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageInterceptor.CharacterEntered">
            <summary>Triggered when the user has entered a character</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageInterceptor.MouseButtonPressed">
            <summary>Triggered when a mouse button has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageInterceptor.MouseButtonReleased">
            <summary>Triggered when a mouse button has been released</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageInterceptor.MouseMoved">
            <summary>Triggered when the mouse has been moved</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageInterceptor.MouseWheelRotated">
            <summary>Triggered when the mouse wheel has been rotated</summary>
        </member>
        <member name="T:Nuclex.Input.MockInputManagerTest">
            <summary>Unit tests for the fake input device provider</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestDefaultConstructor">
            <summary>Ensures that the default constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestServiceConstructor">
            <summary>Ensures that the service container constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestKeyboardCollection">
            <summary>
              Verifies that the expected number of keyboards are in the keyboards collection
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestMouseCollection">
            <summary>
              Verifies that the expected number of mice are in the mice collection
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestGamePadCollection">
            <summary>
              Verifies that the expected number of game pads are in the game pads collection
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestGetMouse">
            <summary>
              Verifies that the mouse can be retrieved from the input manager
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestGetKeyboard">
            <summary>
              Verifies that the PC keyboard can be retrieved from the input manager
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestGetChatPad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Verifies that XBox 360 chat pads can be retrieved from the input manager
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestGetXinputGamePad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Verifies that game pads can be retrieved from the input manager
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestGetDirectInputGamePad(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>
              Verifies that game pads can be retrieved from the input manager
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestSnapshots">
            <summary>
              Verifies that the snap shot system is working in the mocked input manager
            </summary>
        </member>
        <member name="T:Nuclex.Input.GamePadButtonsHelperTest">
            <summary>Unit tests for the game pad buttons helper</summary>
        </member>
        <member name="M:Nuclex.Input.GamePadButtonsHelperTest.TestContains">
            <summary>Verifies that the Contains() method is working</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadButtonDelegate">
            <summary>Delegate use to report presses and releases of game pad buttons</summary>
            <param name="buttons">Button or buttons that have been pressed or released</param>
        </member>
    </members>
</doc>
